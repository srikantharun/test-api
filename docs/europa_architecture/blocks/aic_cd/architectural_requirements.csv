category,optional_description,index,description,criticality,comment,pillar,unique_name
CONN,,0,The ACD should have a command FIFO of depth 16 accessible via the 64-bit AXI subordinate port,bronze,,UVM,ACD_CONN_0
CONN,,1,The ACD should have a CSR accessible via the 64-bit AXI subordinate port,bronze,,UVM,ACD_CONN_1
CONN,,2,The ACD should have a 64-bit AXI manager port which can access both the SPM and the AIC datapath blocks,bronze,,UVM,ACD_CONN_2
CONN,,3,The ACD should have an IRQ signal connected to the PLIC,bronze,,UVM,ACD_CONN_3
CONN,,4,The ACD should be part of the intra-core and top-level token network,bronze,,UVM,ACD_CONN_4
CONN,,5,The ACD should be connected to the timestamp unit with a 2-bit trigger signal,bronze,,UVM,ACD_CONN_5
CONN,,6,The ACD should be able to receive a command execution done signal from each datapath block,bronze,,UVM,ACD_CONN_6
CONN,,7,The ACD should have an address vector input port to indicate the `aic_base_addr` to be applied to all addresses found in its commands and instructions,bronze,,UVM,ACD_CONN_7
FEAT,,0,The ACD should be able to execute a sequential list of tasks/instructions provided by a command with a pointer and length,silver,,UVM,ACD_FEAT_0
FEAT,,1,The ACD should be able to decode instructions based on the major and minor opcode and execute them accordingly,silver,,UVM,ACD_FEAT_1
FEAT,,2,The ACD should offset any control data pointers in its commands and instructions by the `ctrl_data_base_addr` provided in the CSR,silver,,UVM,ACD_FEAT_2
FEAT,,3,The ACD should be able to provide an IRQ upon completion of the task list including any outstanding transactions,silver,,UVM,ACD_FEAT_3
FEAT,,4,"The ACD should provide its status continuously via CSR, e.g. idle or busy state",silver,,UVM,ACD_FEAT_4
FEAT,,5,The ACD should have a configurable address map of the AIC datapath blocks' command FIFO and program memory stored in CSR,silver,,UVM,ACD_FEAT_5
FEAT,,6,The ACD should be able to reference the configurable address map via the destination ID in its `send_cmd` and `send_prg` instructions,silver,,UVM,ACD_FEAT_6
FEAT,,7,The ACD should be able to execute the 'send_cmd' instruction which sends a datapath command stored at the provided pointer to the targeted destination's command FIFO,silver,,UVM,ACD_FEAT_7
FEAT,,8,The ACD should pessimistically estimate the command FIFO fill statuses of each AIC datapath block based on the ACD sideband sync signals,silver,,UVM,ACD_FEAT_8
FEAT,,9,The ACD should stall the datapath command transfer if the corresponding command FIFO is estimated to not have enough slots,silver,,UVM,ACD_FEAT_9
FEAT,,10,The ACD should be able to patch/offset addresses in the datapath commands based on patch modes configured in CSR and referenced by ID,silver,,UVM,ACD_FEAT_10
FEAT,,11,The ACD should patch datapath command addresses by applying the offset address stored in CSR and referenced by ID,silver,,UVM,ACD_FEAT_11
FEAT,,12,"The ACD should only support patching of addresses which are word aligned, starting at byte 0, and have a width in bytes",silver,,UVM,ACD_FEAT_12
FEAT,,13,The ACD should be able to patch up to two addresses per command with the restriction that word_index_0 is strictly smaller than word_index_1,silver,,UVM,ACD_FEAT_13
FEAT,,14,The ACD should be able to disable the patching by setting the patch_mode to zero,silver,,UVM,ACD_FEAT_14
FEAT,,15,The ACD should be able to store up to 8 patch modes starting with ID of 1 since 0 disables the feature,silver,,UVM,ACD_FEAT_15
FEAT,,16,The ACD should be able to store up to 16 patch addresses in CSR,silver,,UVM,ACD_FEAT_16
FEAT,,17,The ACD should be able to execute the 'send_prg' instruction which sends a datapath program stored at the provided pointer to the targeted destination's program memory,silver,,UVM,ACD_FEAT_17
FEAT,,18,The ACD should be able to store datapath programs at an unaligned offset in the targeted destinations's program memory,silver,,UVM,ACD_FEAT_18
FEAT,,19,The ACD should only support datapath programs which are stored in an aligned fashion with padding if required,silver,,UVM,ACD_FEAT_19
FEAT,,20,The ACD should be able to execute the 'cons_local' instruction which consumes the indicated intra-core tokens and stalls until all required tokens have arrived,silver,,UVM,ACD_FEAT_20
FEAT,,21,The ACD should be able to execute the 'cons_global' instruction which consumes the indicated top-level tokens and stalls until all required tokens have arrived,silver,,UVM,ACD_FEAT_21
FEAT,,22,The ACD should be able to execute the 'prod_local' instruction which produces the indicated intra-core tokens and stalls until all required tokens have been sent,silver,,UVM,ACD_FEAT_22
FEAT,,23,The ACD should be able to execute the 'prod_global' instruction which produces the indicated top-level tokens and stalls until all required tokens have been sent,silver,,UVM,ACD_FEAT_23
FEAT,,24,The ACD should be able to execute the 'timestamp' instruction which produces a timestamp with the provided ID using the timestamp sideband signals,silver,,UVM,ACD_FEAT_24
FEAT,,25,The ACD should be able to offset all datapath command and program pointers in its instructions by the `control_offset` provided in its command,silver,,UVM,ACD_FEAT_25
FEAT,,26,The ACD should only sent out legal AXI transactions whether bursted or not,silver,,UVM,ACD_FEAT_26
FEAT,,27,The ACD should have a 32 word deep copy buffer macro to copy control data from SPM to the AIC datapath blocks,silver,,UVM,ACD_FEAT_27
FEAT,,28,The ACD should calculate the final task list pointer based on the following formula `aic_base_addr + ctrl_data_base_addr + task_list_ptr`,silver,,UVM,ACD_FEAT_28
FEAT,,29,The ACD should calculate the final command source pointer based on the following formula `aic_base_addr + ctrl_data_base_addr + control_offset + command_ptr`,silver,,UVM,ACD_FEAT_29
FEAT,,30,The ACD should calculate the final program source pointer based on the following formula `aic_base_addr + ctrl_data_base_addr + control_offset + program_ptr`,silver,,UVM,ACD_FEAT_30
FEAT,,31,The ACD should calculate the final command destination address based on the following formula `aic_base_addr + local_memory_map[cmd.dst_id]`,silver,,UVM,ACD_FEAT_31
FEAT,,32,The ACD should calculate the final program destination address based on the following formula `aic_base_addr + local_memory_map[prg.dst_id] + dst_address`,silver,,UVM,ACD_FEAT_32
FEAT,,33,The ACD should only support pointers in commands and instructions which are word-aligned including any potential offsets applied,silver,,UVM,ACD_FEAT_33
FEAT,,34,The ACD should be able to provide the control for the entire Drv-FIAT regression without the need of the CVA6V,silver,,Drv-FIAT,ACD_FEAT_34
DBG,,0,The ACD should stop executing any further instructions upon encountering an instruction decode error and report the current failing instruction,gold,,UVM,ACD_DBG_0
DBG,,1,The ACD should upon an AXI error finish any outstanding AXI transactions and then halt its operation and report the error,gold,,UVM,ACD_DBG_1
DBG,,2,"The ACD should halt its operation if it encounters an unsupported copy operation, e.g. due to address misalignment, and report the operation",gold,,UVM,ACD_DBG_2
PERF,,0,The ACD should be able to provide a control throughput which exceeds the CVA6V disregarding initial setup overhead,gold,,Drv-FIAT,ACD_PERF_0
