# Formal Connectivity Checks CSV Generation

The script processes and expands bus connectivity information from a specification provided in a CSV format. It expands this data based on defined communication protocols, generating another CSV with detailed connectivity checks.

## Usage

### Running the Script
Execute the script from the command line with the following command:

```bash
python cc_csv_gen.py --bus_conn_csv=<input_csv_path> --fv_cc_csv=<output_csv_path>
```

#### Arguments
- `--bus_conn_csv` (optional): Path to the input CSV file containing bus connectivity data. Default: `bus_conn.csv`.
- `--fv_cc_csv` (optional): Path to the output CSV file where expanded connectivity checks will be written. Default: `connectivity_checks.csv`.

### Example Command
```bash
python cc_csv_gen.py --bus_conn_csv="path/to/input.csv" --fv_cc_csv="path/to/output.csv"
```

This command processes the connectivity data from `"path/to/input.csv"`, expands it according to signal definitions, and outputs the results to `"path/to/output.csv"`.

## Functional Overview

### Main Steps
1. **Signal Definitions**: The script utilizes a predefined dictionary (`signals_dict`) that lists all standard signal names for supported communication protocols like AXI, AXIS, AXIS-Lite, APB, and OCP-Lite. This dictionary is essential for expanding the connectivity data based on the protocol specified in the input data.

2. **Input Reading**: Connectivity data is read from the specified CSV file using the `--bus_conn_csv` argument. Each row includes details such as source instance, destination instance, source bus, destination bus, interface type, signal name, and enable condition.

3. **Data Expansion**: For each row, based on the interface type and enable condition, the script expands connectivity by appending protocol-specific signal names to each connection, including a conditional enable expression.

4. **Output Writing**: The expanded connectivity checks are then written to a new CSV file as specified by the `--fv_cc_csv` argument. This output includes columns for source expression, destination expression, and enable expression constructed during processing.

### Example Input CSV
Consider an input CSV named `bus_conn.csv` that specifies bus connectivity between various hardware components:

```plaintext
Source Instance,Destination Instance,Source Bus,Destination Bus,Type,Interface Type,Name,Enable Connection
Core_1,Memory_1,AXIBUS1,AXIBUS2,Protocol,AXI4,,N/A
Processor_2,Core_2,BUS1,BUS2,Protocol,AXIS,,N/A
```

This CSV lists connections where:
- `Source Instance` and `Destination Instance` are the paths of .
- `Source Bus` and `Destination Bus` specify the bus connections that need expansion.
- `Interface Type` indicates the type of interface, such as AXI4 or AXIS, which defines the set of signals.
- `Name` used for additional identifiers or signal modifiers.
- `Enable Connection` specifies the conditional logic for enabling the connection.

### Processed Output CSV
Given the script processes this input and expands each entry according to the signal definitions for each protocol and the enable conditions, the output CSV, `connectivity_checks.csv`, would expand each entry to include all relevant signals from the `signals_dict`. The script appends protocol signals and conditional enable expressions. An output example should look like:

```plaintext
##################################################
## Generated for FV connectivity checks
## Generated on     : 2024-07-11 19:22:29
## Generated by     : desekhri
## Generated from   : bus_conn.csv
## Generated using  : cc_csv_gen.py
##################################################
name,source_expr,destination_expr,enable_expr
Core_1.AXIBUS1_awvalid,Core_1.AXIBUS1_awvalid,Memory_1.AXIBUS2_awvalid,1
Core_1.AXIBUS1_awaddr,Core_1.AXIBUS1_awaddr,Memory_1.AXIBUS2_awaddr,1
... (more lines for other signals)
Processor_2.BUS1_tready,Processor_2.BUS1_tready,Core_2.BUS2_tready,1
Processor_2.BUS1_tvalid,Processor_2.BUS1_tvalid,Core_2.BUS2_tvalid,1
```
