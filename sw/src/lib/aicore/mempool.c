// (C) Copyright Axelera AI 2024
// All Rights Reserved
// *** Axelera AI Confidential ***

// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY.
// Use the "blueprint-engine" to regenerate this file.

/* clang-format off */

//==================================================
// INCLUDES
//==================================================

#include "mempool.h"

#include "printf.h"

//==================================================
// MACROS
//==================================================

//==================================================
// DEFINITIONS
//==================================================

//==================================================
// TYPES
//==================================================

//==================================================
// DATA
//==================================================

static const mempool_t* mempool_table = NULL;
static uint32_t mempool_table_count = 0;

//==================================================
// LOCAL FUNCTION DECLARATIONS
//==================================================

//==================================================
// LOCAL FUNCTION DEFINITIONS
//==================================================

//==================================================
// GLOBAL FUNCTION DEFINITIONS
//==================================================

mempool_status_t mempool_init(const mempool_t mempools[], uint32_t count) {
  mempool_table = mempools;
  mempool_table_count = count;

  return MEMPOOL_STATUS_OK;
}

uintptr_t mempool_get_addr(const mempool_address_t* const addr) {
  uintptr_t resolved_addr;

  if (addr->enabled) {
    resolved_addr = mempool_table[addr->idx].addr + addr->offset;
  } else {
    resolved_addr = addr->offset;
  }

  return resolved_addr;
}

bool mempool_is_addr_valid(uintptr_t addr) {
  if (!mempool_table) {
    LOG_ERROR("Memory pool info not available");
    return false;
  }
  for (uint32_t idx = 0; idx < mempool_table_count; idx++) {
    const mempool_t* mp = &mempool_table[idx];
    if ((addr >= mp->addr) && (addr < mp->addr + mp->size)) return true;
  }
  LOG_ERROR("Address %p is not within valid memory pool", (void*) addr);
  return false;
}

void mempool_info_dump(void) {
  if (!mempool_table) {
    LOG_ERROR("Memory pool info not available");
    return;
  }
  LOG_INFO("Memory pools:");
  for (uint32_t idx = 0; idx < mempool_table_count; idx++) {
    LOG_INFO("%d: addr=%p, size=%u (%s)", idx, (void*) mempool_table[idx].addr,
            mempool_table[idx].size, mempool_table[idx].name);
  }
}

void mempool_print_checksums(void) {
  if (!mempool_table) {
    LOG_ERROR("Memory pool info not available");
    return;
  }
  LOG_ERROR("Checksums:");
  for (uint32_t idx = 0; idx < mempool_table_count; idx++) {
#if LOG_LEVEL <= LOG_LEVEL_ERROR
    const mempool_t* mp = &mempool_table[idx];
    uint64_t checksum = 0;
    for (uint32_t i = 0; i < mp->size; i+=8) {
      checksum += *((uint64_t*) (mp->addr + i));
    }
#endif
    LOG_ERROR("checksum=0x%016llx first=0x%016llx last=0x%016llx (%s)",
      checksum,
      *((uint64_t*) mp->addr),
      *((uint64_t*) (mp->addr + mp->size - 8)),
      mp->name
    );
  }
}
