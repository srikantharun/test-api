#include "drv_emmc.h"
#include "emmc_card_regs.h"
#include "emmc_commands.h"
#include "emmc_host_regs.h"
#include "emmc_phy.h"
#include "std/std_basetype.h"
#include "std/std_bit.h"
#include "testutils.h"
#include <clk/drv_clk.h>
#include <interrupt.h>
#include <log.h>
#include <memorymap.h>
#include <platform.h>
#include <printf.h>
#include <std/std_bit.h>
#include <stdbool.h>
#include <stdint.h>
#include <timer.h>
#include <auto-generated/soc_periph_ao_csr.h>

#define EMMC_REG_HRS_BASE SOC_PERIPH_EMMC_BASE
#define EMMC_SDMCLK_FREQ MHz(200)

// Host registers
typedef struct {
  reg32_t general_info;        // 0x00 HRS0
  reg32_t debounce_setting;    // 0x04 HRS1
  reg32_t bus_setting;         // 0x08 HRS2
  reg32_t axi_errors;          // 0x0c HRS3
  reg32_t phy_reg_addr;        // 0x10 HRS4
  reg32_t phy_reg_ptr;         // 0x14 HRS5
  reg32_t emmc_mode;           // 0x18 HRS6
  reg32_t io_delay_info;       // 0x1c HRS7
  reg32_t phy_dll_update;      // 0x20 HRS8
  reg32_t phy_ctrl;            // 0x24 HRS9
  reg32_t host_sdclk_adjust;   // 0x28 HRS10
  reg32_t emmc_rst;            // 0x2c HRS11
  reg32_t host_int_status;     // 0x30 HRS12
  reg32_t host_int_status_en;  // 0x34 HRS13
  reg32_t host_int_en;         // 0x38 HRS14
  reg32_t reserved;            // 0x3c HRS15
  reg32_t output_delay;        // 0x40 HRS16
  reg32_t reserved2[12];       // 0x44 HRS17-28
  reg32_t sd_magic_nb;         // 0x74 HRS29
  reg32_t host_capability;     // 0x78 HRS30
  reg32_t host_version;        // 0x7c HRS31
  reg32_t fsm_monitor;         // 0x80 HRS32
  reg32_t tune_status_0;       // 0x84 HRS33
  reg32_t tune_status_1;       // 0x88 HRS34
  reg32_t reserved3;           // 0x8c HRS35
  reg32_t boot_status;         // 0x90 HRS36
  reg32_t reserved4[3];        // 0x94 HRS37-39
  reg32_t autoconf_base_addr0; // 0xa0 HRS40
  reg32_t autoconf_base_addr1; // 0xa4 HRS41
  reg32_t autoconf_en;         // 0xa8 HRS42
  reg32_t autoconf_err_status; // 0xac HRS43
} emmc_reg_host;

_Static_assert(
    offsetof(emmc_reg_host, autoconf_err_status) == 0x00AC,
    "emmc_reg_host: last register has not the correct address offset");

// Slot registers
#define EMMC_REG_SRS_BASE (SOC_PERIPH_EMMC_BASE + 0x200)

typedef struct {
  reg32_t sdma_system_addr;    // 0x00 SRS0
  reg32_t block_size;          // 0x04 SRS1
  reg32_t cmd_arg1;            // 0x08 SRS2
  reg32_t cmd_xfer_mode;       // 0x0c SRS3
  reg32_t response[4];         // 0x10 SRS4-7
  reg32_t data_buff;           // 0x20 SRS8
  reg32_t present_state;       // 0x24 SRS9
  reg32_t host_ctrl_1;         // 0x28 SRS10
  reg32_t host_ctrl_2;         // 0x2c SRS11
  reg32_t int_status;          // 0x30 SRS12
  reg32_t int_status_en;       // 0x34 SRS13
  reg32_t int_en;              // 0x38 SRS14
  reg32_t auto_cmd_err_status; // 0x3c SRS15
  reg32_t capabilities_1;      // 0x40 SRS16
  reg32_t capabilities_2;      // 0x44 SRS17
  reg32_t capabilities_3;      // 0x48 SRS18
  reg32_t capabilities_4;      // 0x4c SRS19
  reg32_t force_event;         // 0x50 SRS20
  reg32_t adma_err_status;     // 0x54 SRS21
  reg32_t adma_system_addr_1;  // 0x58 SRS22
  reg32_t adma_system_addr_2;  // 0x5c SRS23
  reg32_t preset_values[4];    // 0x60 SRS24-27
  reg32_t reserved[2];         // 0x70 SRS28-29
  reg32_t adma3_id_addr_1;     // 0x78 SRS30
  reg32_t adma3_id_addr_2;     // 0x7c SRS31
} emmc_reg_slot;

_Static_assert(
    offsetof(emmc_reg_slot, adma3_id_addr_2) == 0x007C,
    "emmc_reg_slot: last register has not the correct address offset");

// Command Queue Registers
#define EMMC_REG_CQRS_BASE (SOC_PERIPH_EMMC_BASE + 0x400)

typedef struct {
  reg32_t version;            // 0x00 CQRS00
  reg32_t capabilities;       // 0x04 CQRS01
  reg32_t configuration;      // 0x08 CQRS02
  reg32_t control;            // 0x0c CQRS03
  reg32_t int_status;         // 0x10 CQRS04
  reg32_t int_status_en;      // 0x14 CQRS05
  reg32_t int_en;             // 0x18 CQRS06
  reg32_t int_coalescing;     // 0x1c CQRS07
  reg32_t task_base_addr_lsb; // 0x20 CQRS08
  reg32_t task_base_addr_msb; // 0x24 CQRS09
  reg32_t task_doorbell;      // 0x28 CQRS10
  reg32_t task_notif;         // 0x2c CQRS11
  reg32_t dev_status;         // 0x30 CQRS12
  reg32_t dev_pending;        // 0x34 CQRS13
  reg32_t task_clear;         // 0x38 CQRS14
  reg32_t reserved;           // 0x3c CQRS15
  reg32_t send_status_cfg_1;  // 0x40 CQRS16
  reg32_t send_status_cfg_2;  // 0x44 CQRS17
  reg32_t cmd_resp;           // 0x48 CQRS18
  reg32_t reserved2;          // 0x4c CQRS19
  reg32_t resp_err_mask;      // 0x50 CQRS20
  reg32_t task_error_info;    // 0x54 CQRS21
  reg32_t cmd_resp_idx;       // 0x58 CQRS22
  reg32_t cmd_resp_arg;       // 0x5c CQRS23
} emmc_reg_cmd_queue;

_Static_assert(offsetof(emmc_reg_cmd_queue, cmd_resp_arg) == 0x005C,
               "emmc_reg_cmd_queue: last register has not the correct "
               "address offset");

static struct {
  emmc_reg_host *emmc_host;
  emmc_reg_slot *emmc_slot;
  emmc_reg_cmd_queue *emmc_cmd_queue;
  uint32_t rca_padded;
} emmc = {.emmc_host = (emmc_reg_host *)EMMC_REG_HRS_BASE,
          .emmc_slot = (emmc_reg_slot *)EMMC_REG_SRS_BASE,
          .emmc_cmd_queue = (emmc_reg_cmd_queue *)EMMC_REG_CQRS_BASE,
          .rca_padded = 0};

static volatile uint32_t
    triggered_interrupts; // Keep track of all interrupts triggered

void reset_core(void) {
  emmc.emmc_host->general_info |= HRS0_SWR;
  while ((emmc.emmc_host->general_info & HRS0_SWR) == 1u)
    ;
}

static void phy_set_dll_reset() {
  emmc.emmc_host->phy_ctrl &= ~HRS9_PHY_SW_RESET;
}
static void phy_release_dll_reset() {
  emmc.emmc_host->phy_ctrl |= HRS9_PHY_SW_RESET;
  while ((emmc.emmc_host->phy_ctrl & HRS9_PHY_INIT_COMPLETE) == 0u)
    ;
}

void write_phy_reg(uint32_t addr, uint32_t data) {
  emmc.emmc_host->phy_reg_addr = addr;
  emmc.emmc_host->phy_reg_ptr = data;
}

uint32_t read_phy_reg(uint32_t addr) {
  emmc.emmc_host->phy_reg_addr = addr;
  return emmc.emmc_host->phy_reg_ptr;
}

void emmc_config_phy_sd(void) {
  uint32_t temp;
  phy_set_dll_reset();

  // select phy_dqs_timing_reg - enable phony dqs for card init.
  write_phy_reg(PHY_DQS_TIMING_REG, (USE_EXT_LPBK_DQS | USE_LPBK_DQS |
                                     USE_PHONY_DQS | USE_PHONY_DQS_CMD));

  write_phy_reg(PHY_GATE_LPBK_CTRL_REG,
                (SYNC_METHOD | UNDERRUN_SUPPRESS | GATE_CFG_ALWAYS_ON));

  temp = read_phy_reg(PHY_DLL_MASTER_CTRL_REG);
  temp |= PARAM_DLL_BYPASS_MODE;
  DP_BIT_WRITE_FIELD(temp, PARAM_DLL_START_POINT, 4);
  DP_BIT_WRITE_FIELD(temp, PARAM_PHASE_DETECT_SEL, 2);
  write_phy_reg(PHY_DLL_MASTER_CTRL_REG, temp);

  write_phy_reg(PHY_DLL_SLAVE_CTRL_REG, 0u);

  temp = read_phy_reg(PHY_DLL_CTRL_REG);
  DP_BIT_WRITE_FIELD(temp, PHONY_DQS_TIMING, 0);
  write_phy_reg(PHY_DLL_CTRL_REG, temp);
  phy_release_dll_reset();

  temp = read_phy_reg(PHY_DQ_TIMING_REG);
  temp &= ~IO_MASK_ALWAYS_ON;
  DP_BIT_WRITE_FIELD(temp, IO_MASK_START, 0);
  DP_BIT_WRITE_FIELD(temp, IO_MASK_END, 0);
  DP_BIT_WRITE_FIELD(temp, DATA_SELECT_OE_END, 1);
  write_phy_reg(PHY_DQ_TIMING_REG, temp);

  emmc.emmc_host->phy_ctrl |= HRS9_RDDATA_EN | HRS9_RDCMD_EN |
                              HRS9_EXTENDED_WR_MODE | HRS9_EXTENDED_RD_MODE;

  DP_BIT_WRITE_FIELD(emmc.emmc_host->host_sdclk_adjust, HRS10_HCSDCLKADJ, 2);

  temp = 0u;
  DP_BIT_WRITE_FIELD(temp, HRS16_WRDATA0_DLY, 1);
  DP_BIT_WRITE_FIELD(temp, HRS16_WRCMD0_DLY, 1);
  emmc.emmc_host->output_delay = temp;

  temp = 0;
  DP_BIT_WRITE_FIELD(temp, HRS7_RW_COMPENSATE, 10);
  DP_BIT_WRITE_FIELD(temp, HRS7_IDELAY_VAL, 1);
  emmc.emmc_host->io_delay_info = temp;
}

static void enable_slot_clocks(uint32_t freq_Mhz) {
  uint8_t sdcfsl;
  uint32_t dtcv;
  uint32_t temp = 0;

  sdcfsl = EMMC_SDMCLK_FREQ / (2 * MHz(freq_Mhz));
  dtcv = 0xe; // Max timeout value

  // Disable SD clock and enable internal clock
  temp = 0;
  LOG_DBG("sdcfsl=%lu dtcv=%lu", sdcfsl, dtcv);
  DP_BIT_WRITE_FIELD(temp, SRS11_DTCV, dtcv);
  DP_BIT_WRITE_FIELD(temp, SRS11_SDCFSL, sdcfsl);
  temp |= SRS11_ICE;
  emmc.emmc_slot->host_ctrl_2 = temp;

  // Wait for internal clock to stabilize
  while ((emmc.emmc_slot->host_ctrl_2 & SRS11_ICS) == 0)
    ;

  // set extended_wr_mode
  phy_set_dll_reset();
  if (sdcfsl > 0) {
    emmc.emmc_host->phy_ctrl |= HRS9_EXTENDED_WR_MODE;
  }
  phy_release_dll_reset();
  // Enable SD Clock
  emmc.emmc_slot->host_ctrl_2 |= SRS11_SDCE;
}

void emmc_sd_host_init(void) {
  uint32_t temp = 0;

  emmc.emmc_slot->host_ctrl_2 = 0u;
  udelay(1);

  // Perform a SW reset
  reset_core();
  udelay(200);
  emmc_config_phy_sd();


  // set slot clock to 25Mhz
  enable_slot_clocks(25);

  // enable supply voltage (i.e. sdclk generation)
  // to power inserted card
  // In simulation this avoids reading Xs
  emmc.emmc_slot->host_ctrl_1 |= SRS10_BP;

  // card detection
  while ((emmc.emmc_slot->present_state & SRS9_CI) == 0)
    ; // wait for SRS9.CI = 1

  // embedded card reset
  temp = emmc.emmc_slot->host_ctrl_1 | SRS10_BP;
  DP_BIT_WRITE_FIELD(temp, SRS10_BVS, 7); // Set VDD1 to 3.3V
  emmc.emmc_slot->host_ctrl_1 = temp;
  udelay(2);
  emmc.emmc_slot->host_ctrl_1 &= ~SRS10_BP;

  udelay(1); // ~1us

  // enable back supply voltage
  emmc.emmc_slot->host_ctrl_1 |= SRS10_BP;

  // enable all status flags
  emmc.emmc_slot->int_status_en = SRS12_ALL_FLAGS;

  // Enable CC, TC, DMAINT and Error interrupts for transfers
  HAL_INTERRUPT_ENABLE(IRQ_SOC_PERIPH_EMMC_SOURCE);
  HAL_INTERRUPT_SET_LEVEL(IRQ_SOC_PERIPH_EMMC_SOURCE, IRQ_PRIORITY_DEFAULT);
  emmc.emmc_slot->int_en |= (SRS12_CC | SRS12_ERRORS | SRS12_TC | SRS12_DMAINT);
}

static uint32_t sd_host_send_cmd(uint32_t cmd_xfer_mode, uint32_t cmd_arg) {
  LOG_DBG("Sending cmd: %lu with arg: %lu\n", cmd_xfer_mode, cmd_arg);
  emmc.emmc_slot->int_status = SRS12_ALL_FLAGS; // Clear all flags
  emmc.emmc_slot->cmd_arg1 = cmd_arg;           // set command argument

  emmc.emmc_slot->cmd_xfer_mode = cmd_xfer_mode; // execute command

  triggered_interrupts &= ~SRS12_CC;

#ifdef PLATFORM_QEMU
  for (volatile int i = 0; i < 100000; i++); // Fake delay for QEMU simulation
  triggered_interrupts |= SRS12_CC;         // Simulate Command Complete flag
#endif

  // exit loop when CC (command complete) flag is
  // set to 1 or on error
  while ((triggered_interrupts & (SRS12_CC | SRS12_EINT)) == 0u) {
    asm volatile("wfi");
  }

  return (triggered_interrupts & SRS12_ERRORS);
}

int emmc_card_init(bool low_voltage_en, uint16_t sd_card_rca) {
  uint32_t cmd_xfer_mode = 0;
  // CMD0 - reset all cards to IDLE state
  LOG_DBG("Entering emmc_card_init !\n");
  // WARNING: Value is assuming we set the clock freq to 25 Mhz
  udelay(5); // must be at least 74 clks before first command
  // Issue card reset
  LOG_DBG("Sending CMD0 !\n");
  ASSERT(0 == sd_host_send_cmd(0, 0));
  LOG_DBG("Card idle !\n");

  // CMD1 - send operational condition and go to READY state
  // CMD1 Must be repeated until device has powered up
  do {
    uint32_t ocr = 0u;
    DP_BIT_WRITE_FIELD(ocr, OCR_2_7_3_6_V, 0x1FFu); // 2.7-3.6V supported

    if (low_voltage_en)
      ocr |= OCR_1_7_1_95_V;                     // 1.7-1.95V supported
    DP_BIT_WRITE_FIELD(ocr, OCR_ACCESS_MODE, 2); // Sector address mode

    DP_BIT_WRITE_FIELD(cmd_xfer_mode, SRS3_CIDX, 1);
    DP_BIT_WRITE_FIELD(cmd_xfer_mode, SRS3_RTS, 2);
    LOG_DBG("Setting ocr to 0x%x\n", ocr);
    ASSERT(sd_host_send_cmd(cmd_xfer_mode, ocr) == 0);

    // Wait for card to finish power up
  } while ((emmc.emmc_slot->response[0] & OCR_CARD_POWER_UP) == 0);

  // CMD2 - get CardID - go to IDENT state
  cmd_xfer_mode = 0;
  DP_BIT_WRITE_FIELD(cmd_xfer_mode, SRS3_CIDX, 2);
  cmd_xfer_mode &= ~SRS3_CRCCE;
  DP_BIT_WRITE_FIELD(cmd_xfer_mode, SRS3_RTS, 1);
  ASSERT(sd_host_send_cmd(cmd_xfer_mode, 0) == 0);

  // CMD3 - send RCA to eMMC card and go to STBY
  ASSERT(sd_card_rca != 0); // rca of 0 means deselect card
  emmc.rca_padded =
      ((uint32_t)sd_card_rca << 16u); // RCA is sent at the MSB of cmd_arg1
  cmd_xfer_mode = 0;
  DP_BIT_WRITE_FIELD(cmd_xfer_mode, SRS3_CIDX, 3);
  cmd_xfer_mode |= (SRS3_CRCCE | SRS3_CICE);
  DP_BIT_WRITE_FIELD(cmd_xfer_mode, SRS3_RTS, 2);
  ASSERT(sd_host_send_cmd(cmd_xfer_mode, emmc.rca_padded) == 0);
  (void)emmc.emmc_slot->response[0]; // Read response

  // -- initialization finished --
  return 0;
}

uint32_t emmc_card_get_status() {
  uint32_t cmd_xfer_mode;
  uint32_t cmd_status;

  cmd_xfer_mode = 0;
  DP_BIT_WRITE_FIELD(cmd_xfer_mode, SRS3_CIDX, 13);
  DP_BIT_WRITE_FIELD(cmd_xfer_mode, SRS3_RTS, 2);
  cmd_xfer_mode |= (SRS3_CRCCE | SRS3_CICE);
  cmd_status = sd_host_send_cmd(cmd_xfer_mode, emmc.rca_padded);
  LOG_DBG("Got status: %x\n", cmd_status);
  ASSERT(cmd_status == 0);
  return emmc.emmc_slot->response[0];
}

void emmc_select_card() {
  uint32_t cmd_xfer_mode;

  // CMD7 - select card, go to TRANS state
  cmd_xfer_mode = 0u;
  DP_BIT_WRITE_FIELD(cmd_xfer_mode, SRS3_CIDX, 7);
  DP_BIT_WRITE_FIELD(cmd_xfer_mode, SRS3_RTS, 2);
  cmd_xfer_mode |= (SRS3_CRCCE | SRS3_CICE);
  ASSERT(sd_host_send_cmd(cmd_xfer_mode, emmc.rca_padded) == 0);
}

uint32_t emmc_dma_write_xfer(uint32_t system_addr, uint32_t emmc_addr,
                             uint32_t block_cnt) {
  uint32_t temp;

  // Configure SDMA
  ASSERT(system_addr > 0); // mem_addr is 0 == no DMA transfer
  emmc.emmc_slot->sdma_system_addr = system_addr;
  temp = 0;
  ASSERT(block_cnt > 0);
  DP_BIT_WRITE_FIELD(temp, SRS1_BCCT, block_cnt);
  DP_BIT_WRITE_FIELD(temp, SRS1_SDMABB, 7);
  DP_BIT_WRITE_FIELD(temp, SRS1_TBS, EMMC_MAX_BLOCK_SIZE);
  emmc.emmc_slot->block_size = temp;
  DP_BIT_WRITE_FIELD(emmc.emmc_slot->host_ctrl_1, SRS10_DMASEL, 0);

  // Start transfer - send CMD25 + CMD12 (multi-block) or CMD24 (single-block)
  temp = SRS3_DPS | SRS3_DMAE | SRS3_CRCCE | SRS3_CICE | SRS3_BCE;
  DP_BIT_WRITE_FIELD(temp, SRS3_RTS, 2);
  if (block_cnt > 1) {
    temp |= SRS3_MSBS;
    DP_BIT_WRITE_FIELD(temp, SRS3_ACE, 1);
    DP_BIT_WRITE_FIELD(temp, SRS3_CIDX, 25); // Multi-write transfer
  } else {
    DP_BIT_WRITE_FIELD(temp, SRS3_CIDX, 24); // Single-write transfer
  }

  triggered_interrupts &= ~(SRS12_DMAINT | SRS12_TC);

  ASSERT(sd_host_send_cmd(temp, emmc_addr) == 0);

#ifdef PLATFORM_QEMU
  // Simulate DMA and transfer complete interrupts for QEMU
  for (volatile int i = 0; i < 100000; i++); // Fake delay for simulation
  triggered_interrupts |= SRS12_DMAINT; // Simulate DMA interrupt
  triggered_interrupts |= SRS12_TC;    // Simulate Transfer Complete interrupt
#endif

  do {
    if (triggered_interrupts & SRS12_DMAINT) { // DMA stopped at boundary
      uint32_t dma_addr = emmc.emmc_slot->sdma_system_addr;
      emmc.emmc_slot->int_status &= SRS12_DMAINT; // Clear interrupt
      triggered_interrupts &= ~SRS12_DMAINT;
      emmc.emmc_slot->sdma_system_addr = dma_addr; // Resume transfer
    }
  } while ((triggered_interrupts & (SRS12_TC | SRS12_EINT)) ==
           0); // Exit on transfer complete or error

  return (triggered_interrupts & SRS12_ERRORS);
}

uint32_t emmc_dma_read_xfer(uint32_t emmc_addr, uint32_t system_addr,
                            uint32_t block_cnt) {
  uint32_t temp;

  // Configure SDMA
  ASSERT(system_addr > 0); // mem_addr is 0 == no DMA transfer
  emmc.emmc_slot->sdma_system_addr = system_addr;
  temp = 0;
  ASSERT(block_cnt > 0);
  DP_BIT_WRITE_FIELD(temp, SRS1_BCCT, block_cnt);
  DP_BIT_WRITE_FIELD(temp, SRS1_SDMABB, 7);
  DP_BIT_WRITE_FIELD(temp, SRS1_TBS, EMMC_MAX_BLOCK_SIZE);
  emmc.emmc_slot->block_size = temp;
  DP_BIT_WRITE_FIELD(emmc.emmc_slot->host_ctrl_1, SRS10_DMASEL, 0);

  // Start transfer - send CMD25 + CMD12 (multi-block) or CMD24 (single-block)
  temp = SRS3_DPS | SRS3_DMAE | SRS3_CRCCE | SRS3_CICE | SRS3_BCE | SRS3_DTDS;
  DP_BIT_WRITE_FIELD(temp, SRS3_RTS, 2);
  if (block_cnt > 1) {
    temp |= SRS3_MSBS;
    DP_BIT_WRITE_FIELD(temp, SRS3_ACE, 1);
    DP_BIT_WRITE_FIELD(temp, SRS3_CIDX, 18); // Multi-read transfer
  } else {
    DP_BIT_WRITE_FIELD(temp, SRS3_CIDX, 17); // Single read transfer
  }

  triggered_interrupts &= ~(SRS12_DMAINT | SRS12_TC);

  ASSERT(sd_host_send_cmd(temp, emmc_addr) == 0);

#ifdef PLATFORM_QEMU
  // Simulate DMA and transfer complete interrupts for QEMU
  for (volatile int i = 0; i < 100000; i++); // Fake delay for simulation
  triggered_interrupts |= SRS12_DMAINT; // Simulate DMA interrupt
  triggered_interrupts |= SRS12_TC;    // Simulate Transfer Complete interrupt
#endif

  do {
    if (triggered_interrupts & SRS12_DMAINT) { // DMA stopped at boundary
      uint32_t dma_addr = emmc.emmc_slot->sdma_system_addr;
      emmc.emmc_slot->int_status &= SRS12_DMAINT; // Clear interrupt
      triggered_interrupts &= ~SRS12_DMAINT;
      emmc.emmc_slot->sdma_system_addr = dma_addr; // Resume transfer
    }
  } while ((triggered_interrupts & (SRS12_TC | SRS12_EINT)) ==
           0); // Exit on transfer complete or error

  return (triggered_interrupts & SRS12_ERRORS);
}

static void set_bus_width(uint32_t bit_width) {
  uint32_t temp;
  uint32_t cmd_xfer_mode;
  uint32_t bus_width;

  temp = emmc.emmc_slot->host_ctrl_1;
  switch (bit_width) {
  case 1:
    temp &= (~SRS10_DTW | SRS10_EDTW);
    bus_width = EXT_CSD_BUS_WIDTH_1_BIT;
    break;

  case 4:
    temp |= SRS10_DTW;
    temp &= ~SRS10_EDTW;
    bus_width = EXT_CSD_BUS_WIDTH_4_BIT;
    break;

  case 8:
    temp |= SRS10_EDTW;
    bus_width = EXT_CSD_BUS_WIDTH_8_BIT;
    break;

  default:
    ASSERT(false, "Invalid bit width !");
    break;
  }
  emmc.emmc_slot->host_ctrl_1 = temp;

  // CMD6 - SWITCH select bus width in eMMC card
  cmd_xfer_mode = 0;
  DP_BIT_WRITE_FIELD(cmd_xfer_mode, SRS3_CIDX, 6);
  DP_BIT_WRITE_FIELD(cmd_xfer_mode, SRS3_RTS, 3);
  cmd_xfer_mode |= (SRS3_CICE | SRS3_CRCCE);

  temp = 0;
  DP_BIT_WRITE_FIELD(temp, CMD6_ACCESS, CMD6_ACCESS_BYTE_WRITE);
  DP_BIT_WRITE_FIELD(temp, CMD6_INDEX, EXT_CSD_BUS_WIDTH_OFFSET);
  DP_BIT_WRITE_FIELD(temp, CMD6_VALUE, bus_width);

  triggered_interrupts &= ~SRS12_TC;
  ASSERT(sd_host_send_cmd(cmd_xfer_mode, temp) == 0);

  // response R1b - busy signal is transmitted on the DAT0 line
  // exit loop when TC (command complete) flag is set to 1
  while ((triggered_interrupts & SRS12_TC) == 0)
    ;
}

static void set_hs_timing(uint32_t mode) {
  uint32_t cmd_xfer_mode;
  uint32_t temp;

  ASSERT(mode <= EXT_CSD_HS_TIMING_HS400, "Invalid mode");

  cmd_xfer_mode = 0;
  DP_BIT_WRITE_FIELD(cmd_xfer_mode, SRS3_CIDX, 6);
  DP_BIT_WRITE_FIELD(cmd_xfer_mode, SRS3_RTS, 3);
  cmd_xfer_mode |= (SRS3_CICE | SRS3_CRCCE);

  temp = 0;
  DP_BIT_WRITE_FIELD(temp, CMD6_ACCESS, CMD6_ACCESS_BYTE_WRITE);
  DP_BIT_WRITE_FIELD(temp, CMD6_INDEX, EXT_CSD_HS_TIMING_OFFSET);
  DP_BIT_WRITE_FIELD(temp, CMD6_VALUE, mode);

  triggered_interrupts &= ~SRS12_TC;
  ASSERT(sd_host_send_cmd(cmd_xfer_mode, temp) == 0);

  // response R1b - busy signal is transmitted on the DAT0 line
  // exit loop when TC (command complete) flag is set to 1
  while ((triggered_interrupts & SRS12_TC) == 0)
    ;
}

void emmc_set_standard_mode(uint32_t bit_width) {
  set_bus_width(bit_width);
  set_hs_timing(EXT_CSD_HS_TIMING_SDR);

  emmc.emmc_slot->host_ctrl_2 &= ~SRS11_SDCE; // disable SDCE  temporarily
  udelay(1);
  emmc.emmc_host->emmc_mode = HRS6_EMMC_MODE_SDR;
  enable_slot_clocks(25);
}

void emmc_enable_interrupts(uint32_t interrupts) {
  emmc.emmc_slot->int_en |= interrupts;
}

void emmc_disable_interrupts(uint32_t interrupts) {
  emmc.emmc_slot->int_en &= ~interrupts;
}

uint32_t emmc_get_int_status(void) {
  uint32_t int_sts = emmc.emmc_slot->int_status;
  triggered_interrupts |= int_sts;
  // Only clear events that may trigger the interrupt
  emmc.emmc_slot->int_status &= (int_sts & emmc.emmc_slot->int_en);
  return int_sts;
}

void __attribute__((weak)) emmc_irq_handler(void) {
  (void)emmc_get_int_status();
}


void emmc_set_clock_stable(bool is_stable) {
  HalSoc_Periph_Ao_CsrReg* soc_periph_csrs = (HalSoc_Periph_Ao_CsrReg*)SYS_CFG_SOC_PERIPH_AO_CSR_BASE;
  uint32_t ics_mask = ((uint32_t)1 << SOC_PERIPH_AO_CSR_ICE_ICECLOCKENABLE_BIT);
  if (is_stable) {
    soc_periph_csrs->ics |= ics_mask;
  } else {
    soc_periph_csrs->ics &= ~ics_mask;
  }
}

void emmc_enable_reset(void) {
  emmc.emmc_host->emmc_rst &= (~HRS11_EMMC_RST); // drives dfi_rstbar which is active low
}

void emmc_disable_reset(void) {
  emmc.emmc_host->emmc_rst |= HRS11_EMMC_RST;
}
