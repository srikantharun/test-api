
/******************************************************************************
 * Embedded SoC C Test generated by TrekSoC-2.1.7
 * Created on Wed Sep 11 15:59:02 2024
 * 
 * File Name: trek_hello.c
 * Generated Seed: 0x5c83a3f1
 *******************************************************************************/
#define TREK_PROCESSOR_COUNT 1
#define TREK_MAX_THREADS_PER_PROCESSOR 1

/*-----------------------------------------------------------------------------
 * User Include Files
 *-----------------------------------------------------------------------------*/
// Axelera specific includes to be added here
// #include <xxx.h>
#define NO_HYPERVISOR_EXTENSION


/*-----------------------------------------------------------------------------
 * Include Files
 *-----------------------------------------------------------------------------*/
#include "/apps/eda/breker/trek5-2.1.7-GCC6_el7/target/include/trek_target_common.h"
#include "/apps/eda/breker/trek5-2.1.7-GCC6_el7/opensrc/riscv-src/util/encoding.h"
#include "/apps/eda/breker/trek5-2.1.7-GCC6_el7/target/include/riscv64/trek_target_riscv64.h"

/*-----------------------------------------------------------------------------
 * Global Variables
 *-----------------------------------------------------------------------------*/
unsigned int runtime_init_var = 0;
// memory resource "C2TMBOXES" with 0x10 bytes
#define trek_mem_C2TMBOXES 0x3000000000ULL
// memory resource "T2CMBOXES" with 0x10 bytes
#define trek_mem_T2CMBOXES 0x3000000080ULL
// memory resource "ddr0" with 0x10000 bytes
#define trek_mem_ddr0 0x200000a400ULL

// macro definitions to improve code readability
#define hart0_active_threads (trek_mem_ddr0+0x00000014)
#define hart0_iterations (trek_mem_ddr0+0x0000000c)
#define runtime_init_done (&runtime_init_var)
#define trek_hart0_T0_state (trek_mem_ddr0+0x00000018)
#define trek_hart0_state (trek_mem_ddr0+0x00000010)

/*-----------------------------------------------------------------------------
 * Function Prototypes
 *-----------------------------------------------------------------------------*/
int trek_hart0_main(void);
void trek_initialize_memory_regions(void);


/*-----------------------------------------------------------------------------
 * User Code
 *-----------------------------------------------------------------------------*/

int trek_main(void)
{
  // must enter in M privilege 
  unsigned long mhartid = trek_get_cpuid();
  trek_test_setup();

  int ret = 0;
  switch (mhartid) {
    case 0: { ret = trek_hart0_main(); break; }

    default: { ret = -1; } // should not happen
  }

  trek_test_teardown();
  return ret;
}
// platform specific exit with error code
void shutdown(void);
#undef trek_exit
#define trek_exit(status) shutdown();

// Axelera specific code to be added here
#undef trek_mem_barrier  
#define trek_mem_barrier(addr) asm volatile("fence")

#undef trek_mem_cache_flush
#define trek_mem_cache_flush(addr) trek_mem_barrier(addr)

#undef trek_mem_cache_invd
#define trek_mem_cache_invd(addr) trek_mem_barrier(addr)

#undef trek_t2c_wait
#define trek_t2c_wait(thread_id) 0

#undef trek_t2c_get
#define trek_t2c_get(thread_id) 0

int main(void)
{
  return trek_main();
}

int trek_microloop_write_check8( void * addrs[], unsigned int count, trek_uint8_t pattern){
  unsigned int errorCount = 0;
  trek_uint8_t pattern2 = pattern;
  unsigned int ii;
  for ( ii = 0; ii < count; ++ii){
    trek_write8(pattern2, addrs[ii]);
    ++pattern2;
  }
  pattern2 = pattern;
  for ( ii = 0; ii < count; ++ii){
    if (trek_read8(addrs[ii]) != (pattern2)) {
      ++errorCount;
      trek_runtime_error("trek_microloop_write_check8", addrs[ii], pattern2, trek_read8(addrs[ii]));
    };
    ++pattern2;
  }
  return errorCount;
}

int trek_microloop_write_check16( void * addrs[], unsigned int count, trek_uint16_t pattern){
  unsigned int errorCount = 0;
  trek_uint16_t pattern2 = pattern;
  unsigned int ii;
  for ( ii = 0; ii < count; ++ii){
    trek_write16(pattern2, addrs[ii]);
    ++pattern2;
  }
  pattern2 = pattern;
  for ( ii = 0; ii < count; ++ii){
    if (trek_read16(addrs[ii]) != (pattern2)) {
      ++errorCount;
      trek_runtime_error("trek_microloop_write_check16", addrs[ii], pattern2, trek_read16(addrs[ii]));
    };
    ++pattern2;
  }
  return errorCount;
}

int trek_microloop_write_check32( void * addrs[], unsigned int count, trek_uint32_t pattern){
  unsigned int errorCount = 0;
  trek_uint32_t pattern2 = pattern;
  unsigned int ii;
  for ( ii = 0; ii < count; ++ii){
    trek_write32(pattern2, addrs[ii]);
    ++pattern2;
  }
  pattern2 = pattern;
  for ( ii = 0; ii < count; ++ii){
    if (trek_read32(addrs[ii]) != (pattern2)) {
      ++errorCount;
      trek_runtime_error("trek_microloop_write_check32", addrs[ii], pattern2, trek_read32(addrs[ii]));
    };
    ++pattern2;
  }
  return errorCount;
}

int trek_microloop_write_check64( void * addrs[], unsigned int count, trek_uint64_t pattern){
  unsigned int errorCount = 0;
  trek_uint64_t pattern2 = pattern;
  unsigned int ii;
  for ( ii = 0; ii < count; ++ii){
    trek_write64(pattern2, addrs[ii]);
    ++pattern2;
  }
  pattern2 = pattern;
  for ( ii = 0; ii < count; ++ii){
    if (trek_read64(addrs[ii]) != (pattern2)) {
      ++errorCount;
      trek_runtime_error("trek_microloop_write_check64", addrs[ii], pattern2, trek_read64(addrs[ii]));
    };
    ++pattern2;
  }
  return errorCount;
}

int trek_fakeWr_write_check8( void * addrs[],
									  unsigned int count, trek_uint8_t pattern,
                                      unsigned int fakeCount, trek_uint8_t fakePattern)
{
  int errorCount = 0;
  trek_uint8_t pattern2 = pattern;
  unsigned int ii, jj;
  for ( ii = 0; ii < count; ++ii){
    for ( jj = 0; jj < fakeCount; ++jj){
      trek_write8(fakePattern, addrs[ii]);
	  ++fakePattern;
	}
    trek_write8(pattern2, addrs[ii]);
    ++pattern2;
  }
  pattern2 = pattern;
  for ( ii = 0; ii < count; ++ii){
    if (trek_read8(addrs[ii]) != (pattern2)) {
      ++errorCount;
      trek_runtime_error("trek_microloop_write_check8", addrs[ii], pattern2, trek_read8(addrs[ii]));
    };
    ++pattern2;
  }
  return errorCount;
}

int trek_fakeWr_write_check16( void * addrs[],
									  unsigned int count, trek_uint16_t pattern,
                                      unsigned int fakeCount, trek_uint16_t fakePattern)
{
  int errorCount = 0;
  trek_uint16_t pattern2 = pattern;
  unsigned int ii, jj;
  for ( ii = 0; ii < count; ++ii){
    for ( jj = 0; jj < fakeCount; ++jj){
      trek_write16(fakePattern, addrs[ii]);
	  ++fakePattern;
	}
    trek_write16(pattern2, addrs[ii]);
    ++pattern2;
  }
  pattern2 = pattern;
  for ( ii = 0; ii < count; ++ii){
    if (trek_read16(addrs[ii]) != (pattern2)) {
      ++errorCount;
      trek_runtime_error("trek_microloop_write_check16", addrs[ii], pattern2, trek_read16(addrs[ii]));
    };
    ++pattern2;
  }
  return errorCount;
}

int trek_fakeWr_write_check32( void * addrs[],
									  unsigned int count, trek_uint32_t pattern,
                                      unsigned int fakeCount, trek_uint32_t fakePattern)
{
  int errorCount = 0;
  trek_uint32_t pattern2 = pattern;
  unsigned int ii, jj;
  for ( ii = 0; ii < count; ++ii){
    for ( jj = 0; jj < fakeCount; ++jj){
      trek_write32(fakePattern, addrs[ii]);
	  ++fakePattern;
	}
    trek_write32(pattern2, addrs[ii]);
    ++pattern2;
  }
  pattern2 = pattern;
  for ( ii = 0; ii < count; ++ii){
    if (trek_read32(addrs[ii]) != (pattern2)) {
      ++errorCount;
      trek_runtime_error("trek_microloop_write_check32", addrs[ii], pattern2, trek_read32(addrs[ii]));
    };
    ++pattern2;
  }
  return errorCount;
}

int trek_fakeWr_write_check64( void * addrs[],
									  unsigned int count, trek_uint64_t pattern,
                                      unsigned int fakeCount, trek_uint64_t fakePattern)
{
  int errorCount = 0;
  trek_uint64_t pattern2 = pattern;
  unsigned int ii, jj;
  for ( ii = 0; ii < count; ++ii){
    for ( jj = 0; jj < fakeCount; ++jj){
      trek_write64(fakePattern, addrs[ii]);
	  ++fakePattern;
	}
    trek_write64(pattern2, addrs[ii]);
    ++pattern2;
  }
  pattern2 = pattern;
  for ( ii = 0; ii < count; ++ii){
    if (trek_read64(addrs[ii]) != (pattern2)) {
      ++errorCount;
      trek_runtime_error("trek_microloop_write_check64", addrs[ii], pattern2, trek_read64(addrs[ii]));
    };
    ++pattern2;
  }
  return errorCount;
}

/*! Breker - Begin of generated test */

/*-----------------------------------------------------------------------------
 * Executable Code for Processor hart0
 *-----------------------------------------------------------------------------*/
#undef TREK_PROCESSOR_IDX
#define TREK_PROCESSOR_IDX 0

/* Processor: hart0, Thread: T0 */
#undef TREK_THREAD_ID
#define TREK_THREAD_ID 0

#undef TREK_THREAD_IDX
#define TREK_THREAD_IDX 0

void
trek_hart0_T0(void) {

  switch (trek_read32_shared(trek_hart0_T0_state)) {
  case (0x1): {
    trek_c2t_event(0, 0x2);           // [event:0x2 MAIN]
        /* tbx: trek_message("Thread trek_hart0_T0 started");  */

/***********************************************************************************/
// doCopy.1
    trek_c2t_event(0, 0x3);           // [event:0x3 agent:hart0 thread:T0 instance:doCopy.1]
        /* tbx: trek_message("Begin doCopy.1");  */
    // MemAllocSet_1
    // memAllocAddrRand size:0x4 addr: trek_mem_ddr0+0x00000000

    // trek_copy_memory_block(trek_mem_ddr0+0x00000000, trek_mem_ddr0+0x00000004, 0x4)
    trek_write32(trek_read32(trek_mem_ddr0+0x00000000), trek_mem_ddr0+0x00000004);

    trek_c2t_event(0, 0x4);           // [event:0x4 agent:hart0 thread:T0 instance:doCopy.1]
        /* tbx: trek_message("End doCopy.1");  */
    trek_write32_shared(0x2, trek_hart0_T0_state);
    break;
  }
  case (0x2): {

/***********************************************************************************/
// doCheck.1
    trek_c2t_event(0, 0x5);           // [event:0x5 agent:hart0 thread:T0 instance:doCheck.1]
        /* tbx: trek_message("Begin doCheck.1");  */
    // memAllocRepeat
    // memAllocAddrRand size:0x4 addr: trek_mem_ddr0+0x00000008

    if (trek_read32(trek_mem_ddr0+0x00000008) != 0x693b6bd5) {  // trek_check32()
      trek_c2t_arg(0, trek_read32(trek_mem_ddr0+0x00000008));
      trek_c2t_event(0, 0x6);           // [event:0x6 agent:hart0 thread:T0 instance:doCheck.1]
        /* tbx: trek_check32(0x693b6bd5, trek_mem_ddr0+0x00000008);  */
    }

    trek_c2t_event(0, 0x7);           // [event:0x7 agent:hart0 thread:T0 instance:doCheck.1]
        /* tbx: trek_message("End doCheck.1");  */
    trek_write32_shared(0x3, trek_hart0_T0_state);
    break;
  }
  case (0x3): {
    trek_c2t_event(0, 0x8);           // [event:0x8 MAIN]
        /* tbx: trek_message("Thread trek_hart0_T0 completed");  */
    (trek_read32(hart0_active_threads))--;
    trek_write32_shared(0x4, trek_hart0_T0_state);
    break;
  }
  default:
    if (trek_read32_shared(trek_hart0_T0_state) != 0x4) {
      trek_c2t_event(0, 0x9);         // [event:0x9 MAIN]
        /* tbx: trek_message("bad value in variable trek_hart0_T0_state");  */
    }
    break;
  }
}

void
trek_hart0_reset(void) {
  // active thread and thread state variables
  trek_write32(0x1, hart0_active_threads);
  trek_write32_shared(0x01, trek_hart0_T0_state);
}

void
trek_hart0_run_states(void) {
  switch (trek_read32_shared(trek_hart0_state)) {
  case (0x1): {
    // initialization
    trek_write32_shared(0x2, trek_hart0_state);
  }
  case (0x2): {
    trek_write32_shared((trek_read32_shared(hart0_iterations) + 0x01), hart0_iterations);
    trek_write32_shared(0x3, trek_hart0_state);
  }
  case (0x3): {
    trek_c2t_event(0, 0xa);           // [event:0xa MAIN]
        /* tbx: **** Start of Processor hart0 Iteration ****  */
    trek_write32_shared(0x4, trek_hart0_state);
  }
  case (0x4): {
    // Run threads
    trek_hart0_T0();
    if (trek_read32(hart0_active_threads)) break;

    trek_c2t_event(0, 0xb);           // [event:0xb MAIN]
        /* tbx: trek_message("Processor hart0 iteration done");  */
    trek_write32_shared(0x5, trek_hart0_state);
  }
  case (0x5): {
    if (trek_read32_shared(hart0_iterations) < 0x1) {
      // reset thread variables
      trek_hart0_reset();
      trek_write32_shared(0x2, trek_hart0_state);
      break;
    }

    trek_write32_shared(0x6, trek_hart0_state);
    break;
  }
  default:
    if (trek_read32_shared(trek_hart0_state) != 0x6) {
      trek_c2t_event(0, 0xc);         // [event:0xc MAIN]
        /* tbx: trek_message("bad value in variable trek_hart0_state");  */
    }
    break;
  }
}

int
trek_hart0_main(void) {
  if (trek_read32_shared(runtime_init_done) != 0x0DEFEC75) {
    trek_initialize_memory_regions();
    trek_write32_shared(0x0DEFEC75, runtime_init_done);
  }

  while (trek_read32_shared(trek_hart0_state) < 0x6) {
    trek_hart0_run_states();
  }

  // reset init_done flag
  trek_write32_shared(0x0, runtime_init_done);

  trek_c2t_event(0, 0xd);             // [event:0xd MAIN]
        /* tbx: Get test status  */
  while (trek_t2c_wait(0))
    ;
  return (trek_t2c_get(0));
}
/*! Breker - End of generated test */


// Init hash function
void
trek_initialize_memory (trek_uint8_t* base, trek_uint64_t from_offset, trek_uint64_t to_offset) {
  trek_uint64_t offset_i = from_offset;
  while (offset_i < to_offset) {
    trek_uint64_t value = (offset_i * 0x2e695e90f34eba3dULL) ^ 0x2e695e90f34eba3dULL;
    trek_write64(value, base + offset_i);
    offset_i += 8;  // next 8 bytes
  }
}


// memory regions initialization
void
trek_initialize_memory_regions(void) {
  trek_write64(0x0ULL, (trek_uint8_t*)trek_mem_C2TMBOXES+0x00000000);  // constant
  trek_write64(0x0ULL, (trek_uint8_t*)trek_mem_C2TMBOXES+0x00000008);  // constant
  trek_write64(0x0ULL, (trek_uint8_t*)trek_mem_T2CMBOXES+0x00000000);  // constant
  trek_write64(0x0ULL, (trek_uint8_t*)trek_mem_T2CMBOXES+0x00000008);  // constant
  // memory region trek_mem_ddr0
  trek_initialize_memory((trek_uint8_t*)trek_mem_ddr0, 0x0, 0x20);
  // initialize variables
  trek_write32(0x0, (trek_uint8_t*)trek_mem_ddr0+0x0000000c );  // hart0_iterations
  trek_write32(0x1, (trek_uint8_t*)trek_mem_ddr0+0x00000010 );  // trek_hart0_state
  trek_write32(0x1, (trek_uint8_t*)trek_mem_ddr0+0x00000014 );  // hart0_active_threads
  trek_write32(0x1, (trek_uint8_t*)trek_mem_ddr0+0x00000018 );  // trek_hart0_T0_state
  trek_mem_barrier(0);
}


#include "/apps/eda/breker/trek5-2.1.7-GCC6_el7/target/src/trek_target_common.c"
#include "/apps/eda/breker/trek5-2.1.7-GCC6_el7/target/src/riscv64/trek_target_riscv64.c"
