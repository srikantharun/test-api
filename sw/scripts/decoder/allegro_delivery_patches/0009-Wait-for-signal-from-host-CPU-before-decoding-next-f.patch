From 1726efea5899ae30ca7418d38b12da442c0c5aab Mon Sep 17 00:00:00 2001
From: Max Wipfli <max.wipfli@axelera.ai>
Date: Thu, 18 Jul 2024 15:48:38 +0000
Subject: [PATCH 9/9] Wait for signal from host CPU before decoding next frame

This can be used to delay the decoder until the host CPU finishes
loading the input buffers to the correct addresses.

This change is required as the host CPU cannot load buffers in zero
time, unlike the SystemVerilog testbench.

This is a functional change.
---
 bin/mcu/src/mcu_hex2c.pl | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/bin/mcu/src/mcu_hex2c.pl b/bin/mcu/src/mcu_hex2c.pl
index cd2ad1f..e5b7337 100755
--- a/bin/mcu/src/mcu_hex2c.pl
+++ b/bin/mcu/src/mcu_hex2c.pl
@@ -26,6 +26,8 @@ print OUT "void instructions() {\n";
 print OUT "uint32_t value;\n";
 my $add=sprintf("0x%X",32+$offset);
 print OUT "volatile uint32_t *reg_00000020=(uint32_t*)$add; // internal access to mcu2cpu register\n";
+$add=sprintf("0x%X",0x40C+$offset);
+print OUT "volatile uint32_t *reg_0000040C=(uint32_t*)$add; // internal access to McuIt register\n";
 
 my @regs;
 open(FILE, '<'.$inst) or die($!);
@@ -51,6 +53,12 @@ while(my $r=<FILE>){
     }
   } elsif ($r=~m/^irq,(.*),0x(.*),0x(.*),/) {
     print OUT "interrupt_routine(".hex($3)."); // wait interrupt\n";
+  } elsif ($r=~m/^start_frame,(.*),(.*),(.*),/) {
+    if (!($2 eq "MCU")) {
+      print OUT "// wait for start signal from host CPU\n";
+      print OUT "while((*reg_0000040C & 0x1) != 0x1) {} // polling\n";
+      print OUT "*reg_0000040C = 0x0; // clear interrupt\n";
+    }
   } elsif ($r=~m/^poll,(.*),0x(.*),0x(.*),/) {
     print OUT "while(*reg_$2!=0x$3) {} // polling\n";
     print OUT "*reg_00000020=0x1; // set mcu2cpu interrupt to synchronize test bench buffer load/store\n";
-- 
2.43.0

