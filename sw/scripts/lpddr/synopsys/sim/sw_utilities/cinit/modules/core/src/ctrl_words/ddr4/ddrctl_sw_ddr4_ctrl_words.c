// ------------------------------------------------------------------------------
// 
// Copyright 2024 Synopsys, INC.
// 
// This Synopsys IP and all associated documentation are proprietary to
// Synopsys, Inc. and may only be used pursuant to the terms and conditions of a
// written license agreement with Synopsys, Inc. All other use, reproduction,
// modification, or distribution of the Synopsys IP or the associated
// documentation is strictly prohibited.
// Inclusivity & Diversity - Visit SolvNetPlus to read the "Synopsys Statement on
//            Inclusivity and Diversity" (Refer to article 000036315 at
//                        https://solvnetplus.synopsys.com)
// 
// Component Name   : DWC_ddrctl_lpddr54
// Component Version: 1.60a-lca00
// Release Type     : LCA
// Build ID         : 0.0.0.0.TreMctl_302.DwsDdrChip_8.26.6.DwsDdrctlTop_5.12.7
// ------------------------------------------------------------------------------


#include "ctrl_words/ddr4/ddrctl_sw_ddr4_ctrl_words.h"
#include "dwc_ddrctl_cinit_util.h"
#include "cinit_status.h"

#ifdef DDRCTL_DDR

uint8_t ddrctl_sw_get_ddr4_rcd_cw(SubsysHdlr_t *cinit_cfg, ddrctl_ddr4_rcd_cw_t ctrl_word, uint8_t pstate)
{
    ddrctl_error_t  rslt;
    uint8_t         mcw_value = 0;
    uint32_t        freq;
    uint32_t        dimm_addr_mirr_en = REGB_DDRC_CH0.dimmctl.dimm_addr_mirr_en;
    uint32_t        dimm_dis_bg_mirroring = REGB_DDRC_CH0.dimmctl.dimm_dis_bg_mirroring;
#ifdef MEMC_NUM_RANKS_GT_4
    uint32_t        active_ranks_msb;
#endif

    switch(ctrl_word) {
        case DDRCTL_DDR4_F0RC00:
            // Output inversion MUST BE enable for training
            //RC00_data[0] = 0;
            //RC00_data[3:1] = 0;
            mcw_value = 0;
            break;
        case DDRCTL_DDR4_F0RC01:
            // RC01
            // Only Y0_t/Y0_c clock is used in rank_mngr when TI RCD model is used
            if ((DDRCTL_GET_DIMM_TYPE(cinit_cfg, 0) == DWC_RDIMM) ||
                (DDRCTL_GET_DIMM_TYPE(cinit_cfg, 0) == DWC_LRDIMM)) {
                //RC01_data[3:0] = 0;
                SNPS_WRITE_EXPLICIT_FIELD(mcw_value, 0, 0xf, 0);
            }  else {
                //RC01_data[3:0] = 14;
                SNPS_WRITE_EXPLICIT_FIELD(mcw_value, 0, 0xf, 14);
            }
            break;
        case DDRCTL_DDR4_F0RC08:
            // RC08
            if (cinit_cfg->spdData_m.num_ranks_per_dimm == 4) { // Direct Quad CS mode
                if (CINIT_IS_3DS(cinit_cfg, 0) == DDRCTL_TRUE) {  // 3DS
                    //RC08_data[1:0] = 0; // QxC[2:0]enabled
                    SNPS_WRITE_EXPLICIT_FIELD(mcw_value, 0, 0x3, 0);
                } else { // non-3DS
                    //RC08_data[1:0] = 1; // QxC[2]disabled, QxC0[1:0] enabled
                    SNPS_WRITE_EXPLICIT_FIELD(mcw_value, 0, 0x3, 1);
                }
            } else { // Direct Dual CS mode
                switch (CINIT_GET_PKG_TYPE(cinit_cfg, 0)) {
                    case CINIT_PKG_TYPE_MONO:
                        //RC08_data[1:0] = 3; // QxC[2:0]disabled
                        SNPS_WRITE_EXPLICIT_FIELD(mcw_value, 0, 0x3, 3);
                        break;
                    case CINIT_PKG_TYPE_3DS_2H:
                        //RC08_data[1:0] = 2; // QxC[2:1]disabled, QxC0 enabled
                        SNPS_WRITE_EXPLICIT_FIELD(mcw_value, 0, 0x3, 2);
                        break;
                    case CINIT_PKG_TYPE_3DS_4H:
                        //RC08_data[1:0] = 1; // QxC[2]disabled, QxC0[1:0] enabled
                        SNPS_WRITE_EXPLICIT_FIELD(mcw_value, 0, 0x3, 1);
                        break;
                    case CINIT_PKG_TYPE_3DS_8H:
                        //RC08_data[1:0] = 0; // QxC[2:0]enabled
                        SNPS_WRITE_EXPLICIT_FIELD(mcw_value, 0, 0x3, 0);
                        break;
                }
            }
            // QxPAR outputs disabled
            //RC08_data[2] = 0;
            SNPS_SET_BIT(mcw_value, 2, 0);

            // DA17 Input Buffer and QxA17 outputs disabled
            SNPS_SET_BIT(mcw_value, 3, REGB_DDRC_CH0.dimmctl.mrs_a17_en ? 0 : 1);
            break;
        case DDRCTL_DDR4_F0RC0A:
            // RC0A
            // Set PLL bypass mode temporarily to prevent SPEC_VIOLATION from happening due to the jitter generated by PLL
            // RDIMM Operating Speed
            rslt = ddrctl_sw_get_ddr4_cw_op_speed_id(cinit_cfg, pstate, &mcw_value);
            if (DDRCTL_SUCCESS != rslt) {
                SNPS_ERROR("Operating Speed id for %d not found", cinit_cfg->spdData_m.tck_ps[pstate]);
                dwc_ddrctl_cinit_exit(1);
            }
            break;
        case DDRCTL_DDR4_F0RC0D:
            // RC0D
            // CS mode
            if (cinit_cfg->spdData_m.num_ranks_per_dimm == 4) { // Direct Quad CS mode
                //RC0D_data[1:0] = 1;
                SNPS_WRITE_EXPLICIT_FIELD(mcw_value, 0, 0x3, 1);
            } else { // Direct Dual CS mode
                //RC0D_data[1:0] = 0;
                SNPS_WRITE_EXPLICIT_FIELD(mcw_value, 0, 0x3, 0);
            }
            // DIMM Type
            if (IS_LRDIMM) {
                //RC0D_data[2] = 0;
                SNPS_SET_BIT(mcw_value, 2, 0);
            } else {
                //RC0D_data[2] = 1;
                SNPS_SET_BIT(mcw_value, 2, 1);
            }
            // Address mirroring for MRS commands
            // TODO this code need to be reviewed!
#ifdef MEMC_NUM_RANKS_1
            //RC0D_data[3] = 0;
            SNPS_SET_BIT(mcw_value, 3, 0);
#else // Not MEMC_NUM_RANKS_1

            if (dimm_addr_mirr_en && !dimm_dis_bg_mirroring) {
#ifdef MEMC_NUM_RANKS_GT_4
                active_ranks_msb = REGB_DDRC_CH0.mstr0.active_ranks >>
                                    (REGB_DDRC_CH0.mstr0.active_ranks_msb - 1);
                if ((active_ranks_msb == 1) || ((active_ranks_msb == 0))) {
#endif // MEMC_NUM_RANKS_GT_4
                    if (REGB_DDRC_CH0.mstr0.active_ranks != 1) {

                        //RC0D_data[3] = 1;
                        SNPS_SET_BIT(mcw_value, 3, 1);
                    } else {
                        //RC0D_data[3] = 0;
                        SNPS_SET_BIT(mcw_value, 3, 0);
                    }
#ifdef MEMC_NUM_RANKS_GT_4
                }
#endif // MEMC_NUM_RANKS_GT_4
#endif // MEMC_NUM_RANKS_1
            }
            break;
        case DDRCTL_DDR4_F0RC0E:
            // RC0E
            // Parity Enable
            // Even if parity checking is enable for RCD, it will not be enable during training, but only at the end of training
            // So just disable parity always for training
            //RC0E_data[0] = 0;
            SNPS_SET_BIT(mcw_value, 0, 0);
            // Reserved
            //RC0E_data[1] = 0;
            SNPS_SET_BIT(mcw_value, 1, 0);
            // ALERT_n Assertion
            //RC0E_data[2] = 1;
            SNPS_SET_BIT(mcw_value, 2, 1);
            // ALERT_n Re-enable
            //RC0E_data[3] = 1;
            SNPS_SET_BIT(mcw_value, 3, 1);
            break;
        case DDRCTL_DDR4_F0RC0F:
            // RC0F
            // Latency adder nLadd to all DRAM commands
            switch (cinit_cfg->ddr4_cw.rc0f.latency_adder_nladd_to_all_dram_cmd) {
                case 0:
                    SNPS_WRITE_EXPLICIT_FIELD(mcw_value, 0, 0xF, 4);
                    break;
                case 1:
                    SNPS_WRITE_EXPLICIT_FIELD(mcw_value, 0, 0xF, 0);
                    break;
                case 2:
                    SNPS_WRITE_EXPLICIT_FIELD(mcw_value, 0, 0xF, 1);
                    break;
                case 3:
                    SNPS_WRITE_EXPLICIT_FIELD(mcw_value, 0, 0xF, 2);
                    break;
                default:
                    SNPS_WRITE_EXPLICIT_FIELD(mcw_value, 0, 0xF, 3);
                    break;
            }
            break;
        case DDRCTL_DDR4_F0RC3X:
            // RC3x
            // Set to a value consistent with DRAMFreq field value described above
            //RC3x_data = (GET_TCK(0) <= 620 ) ? 0 : (GET_TCK(0) - 621)/10;
            freq = CEIL(2000000, cinit_cfg->spdData_m.tck_ps[pstate]);
            mcw_value = (cinit_cfg->spdData_m.tck_ps[pstate] <= 620) ? 0 : CEIL(freq - 1260, 20);
            break;
        case DDRCTL_DDR4_F0RCAX:
            // LRDIMM only
            // BC0A
            // LRDIMM Operating Speed
            rslt = ddrctl_sw_get_ddr4_cw_op_speed_id(cinit_cfg, pstate, &mcw_value);
            if (DDRCTL_SUCCESS != rslt) {
                SNPS_ERROR("Operating Speed id for %d not found", cinit_cfg->spdData_m.tck_ps[pstate]);
                dwc_ddrctl_cinit_exit(1);
            }
            break;
        case DDRCTL_DDR4_F0RC6X:
            // F0BC6x
            // F0BC6x_data = (GET_TCK(0) <= 620 ) ? 0 : (GET_TCK(0) - 621)/10;
            // TODO (nelson): is this correct?
            freq = CEIL(2000000, 625);
            mcw_value = (cinit_cfg->spdData_m.tck_ps[pstate] <= 620) ? 0 : CEIL(freq - 1260, 20);
            break;
        default:
            SNPS_ERROR("Control word 0x%0x not supported", ctrl_word);
            dwc_ddrctl_cinit_exit(1);
            break;
    }

    SNPS_LOG("MR %u = 0x%x", ctrl_word, mcw_value);
    return mcw_value;
}


/**
 * @brief Get RDIMM LRDIMM operation speed for controller words, BC0A, F0RC0A
 *
 * @param cinit_cfg
 * @param pstate
 * @return uint8_t
 */
ddrctl_error_t ddrctl_sw_get_ddr4_cw_op_speed_id(SubsysHdlr_t *cinit_cfg, uint32_t pstate, uint8_t *op_speed)
{
    uint8_t     speed_id;
    uint32_t    tck_ps;

    if ((DDRCTL_GET_DIMM_TYPE(cinit_cfg, 0) != DWC_RDIMM) &&
        (DDRCTL_GET_DIMM_TYPE(cinit_cfg, 0) != DWC_LRDIMM)) {
        SNPS_ERROR("Not supported for DIMM type %u", DDRCTL_GET_DIMM_TYPE(cinit_cfg, 0));
        return DDRCTL_NOT_SUPPORTED;
    }

    tck_ps = cinit_cfg->spdData_m.tck_ps[pstate];

    if (tck_ps >= 625 && tck_ps < 682) {
        speed_id = 6;
    } else if (tck_ps >= 682 && tck_ps < 750) {
        speed_id = 5;
    } else if (tck_ps >= 750 && tck_ps < 833) {
        speed_id = 4;
    } else if (tck_ps >= 833 && tck_ps < 938) {
        speed_id = 3;
    } else if (tck_ps >= 938 && tck_ps < 1071) {
        speed_id = 2;
    } else if (tck_ps >= 1071 && tck_ps < 1250) {
        speed_id = 1;
    } else if (tck_ps >= 1250 && tck_ps < 1600) {
        speed_id = 0;
    } else if (tck_ps >= 1600) {
        speed_id = 7;
    } else {
        SNPS_ERROR("TCK %ups not supported for DDR4 RDIMM/LRDIMM", tck_ps);
        return DDRCTL_NOT_SUPPORTED;
    }

    *op_speed = speed_id;
    return DDRCTL_SUCCESS;
}


/**
 * @brief method to encode RCX3 fine granularity operational speed
 */
uint32_t dwc_ddrctl_cinit_get_rcx3_fg_op_speed(void)
{
    uint32_t fg_op_speed_id = 0;

    switch (SPD.ddr4_sg) {
        case DWC_DDR4_1600J:
        case DWC_DDR4_1600K:
        case DWC_DDR4_1600L:
        case DWC_DDR4_1600J_3DS2B:
        case DWC_DDR4_1600K_3DS2B:
        case DWC_DDR4_1600L_3DS2B:
            fg_op_speed_id = 0x11;
            break;
        case DWC_DDR4_1866L:
        case DWC_DDR4_1866M:
        case DWC_DDR4_1866N:
        case DWC_DDR4_1866L_3DS2B:
        case DWC_DDR4_1866M_3DS2B:
        case DWC_DDR4_1866N_3DS2B:
            fg_op_speed_id = 0x1f;
            break;
        case DWC_DDR4_2133N:
        case DWC_DDR4_2133P:
        case DWC_DDR4_2133R:
        case DWC_DDR4_2133P_3DS2A:
        case DWC_DDR4_2133P_3DS3A:
        case DWC_DDR4_2133R_3DS4A:
            fg_op_speed_id = 0x2c;
            break;
        case DWC_DDR4_2400P:
        case DWC_DDR4_2400R:
        case DWC_DDR4_2400T:
        case DWC_DDR4_2400U:
        case DWC_DDR4_2400P_3DS3B:
        case DWC_DDR4_2400T_3DS2A:
        case DWC_DDR4_2400U_3DS2A:
        case DWC_DDR4_2400U_3DS4A:
            fg_op_speed_id = 0x39;
            break;
        case DWC_DDR4_2666T:
        case DWC_DDR4_2666U:
        case DWC_DDR4_2666V:
        case DWC_DDR4_2666W:
        case DWC_DDR4_2666T_3DS3A:
        case DWC_DDR4_2666V_3DS3A:
        case DWC_DDR4_2666W_3DS4A:
            fg_op_speed_id = 0x47;
            break;
        case DWC_DDR4_2933V:
        case DWC_DDR4_2933W:
        case DWC_DDR4_2933Y:
        case DWC_DDR4_2933AA:
            fg_op_speed_id = 0x54;
            break;
        case DWC_DDR4_3200W:
        case DWC_DDR4_3200AA:
        case DWC_DDR4_3200AC:
        case DWC_DDR4_3200W_3DS4A:
        case DWC_DDR4_3200AA_3DS4A:
        case DWC_DDR4_3200AC_3DS4A:
            fg_op_speed_id = 0x61;
            break;
        default:
            SNPS_ERROR("Unknown speed grade %u", SPD.ddr4_sg);
            break;
    }

    return fg_op_speed_id;
}

uint8_t ddrctl_sw_get_ddr4_bcw_4b(SubsysHdlr_t *cinit_cfg, ddrctl_ddr4_bcw_4b_t bcw_num, uint8_t pstate)
{
    ddrctl_error_t  rslt;
    uint8_t         bcw_value = 0;

    switch(bcw_num) {
        case DDRCTL_DDR4_BC0A:
            rslt = ddrctl_sw_get_ddr4_cw_op_speed_id(cinit_cfg, pstate, &bcw_value);
            if (DDRCTL_SUCCESS != rslt) {
                SNPS_ERROR("Operating Speed id for %d not found", cinit_cfg->spdData_m.tck_ps[pstate]);
                dwc_ddrctl_cinit_exit(1);
            }
            break;
        default:
            SNPS_ERROR("Data Buffer Control word 0x%0x not supported", bcw_num);
            dwc_ddrctl_cinit_exit(1);
            break;
    }

    return bcw_value;
}


uint8_t ddrctl_sw_get_ddr4_bcw_8b(SubsysHdlr_t *cinit_cfg, ddrctl_ddr4_bcw_8b_t bcw_num, uint8_t pstate)
{
    ddrctl_error_t  rslt;
    uint16_t        bcw_value = 0;
    uint32_t        freq = CEIL(2000000, 625);

    switch(bcw_num) {
        case DDRCTL_DDR4_B0BC6x:
            freq = CEIL(2000000, 625);
            bcw_value = (cinit_cfg->spdData_m.tck_ps[pstate] <= 620) ? 0 : CEIL(freq - 1260, 20);
            break;
        default:
            SNPS_ERROR("Data Buffer Control word 0x%0x not supported", bcw_num);
            dwc_ddrctl_cinit_exit(1);
            break;
    }

    return bcw_value;
}

#endif // DDRCTL_DDR
