#!/usr/bin/env python3
r"""
Script to replace synopsys flow specific register write function calls (eg. 'dwc_ddrctl_wr'),
with verifSDK flow equivalent found in the LPDDR driver implementation (eg. 'lpddrCtlWriteReg32'),
in the sequence file for the LPDDR Memory Controller initialization. It also replaces the address value
with the respective CTL register name macro.
"""

import argparse
import os
import sys
import xml.etree.ElementTree as ET

# --------------------------------------------------------------
# Default values
# --------------------------------------------------------------
input_file = "sequence.txt"
output_file = "lpddrCtlInitBase.c"
DEFAULT_XML_FILE = os.environ["DDR_CONTROLLER_RTL_PATH"] + "/export/DWC_ddrctl.xml"

# --------------------------------------------------------------
# Helping Functions
# --------------------------------------------------------------

def parse_arguments():
    parser = argparse.ArgumentParser(description="Process input and output file paths.")

    # Adding arguments for input and output files
    parser.add_argument(
        "-i", "--input-file",
        default=input_file,
        help="Path to the input file. Default is 'sequence.txt'."
    )
    parser.add_argument(
        "-o", "--output-file",
        default=output_file,
        help="Path to the output file. Default is 'lpddrCtlInitBase.c'."
    )
    parser.add_argument(
        "-x", "--xml",
        default=DEFAULT_XML_FILE,
        help="Input XML file."
    )
    parser.add_argument(
        "-v", "--verbose",
        default=False,
        help="Enable prints for the generation of the CTL register name dictionary."
    )

    args = parser.parse_args()
    return args

def replace_in_file(input_file, output_file, args):

    # Create the dictionary with register names and corresponding addresses
    register_dict = parse_xml(args.xml, args.verbose)

    # Open the input file in read mode and the output file in write mode
    with open(input_file, 'r') as infile, open(output_file, 'w') as outfile:

        # Print header into output file
        for line in generate_file_header(args):
          outfile.write(line + '\n')

        # Read the file line by line
        for line in infile:
            # Replace occurrences of 'dwc_ddrctl_wr' with 'ddrWriteReg32'
            modified_line = line.replace('dwc_ddrctl_wr', 'lpddrCtlWriteReg32')
            # Replace hex address value with CTL register name macro
            for register_name, hex_address in register_dict.items():
              aux_hex_address = "(" + hex_address
              if aux_hex_address in modified_line:
                  modified_line = modified_line.replace(aux_hex_address, "(" + register_name)
            # Write the modified line to the output file
            outfile.write(modified_line)

def parse_xml(input_file, debug_print):

    register_dict = {}

    # Parse the XML file
    tree = ET.parse(input_file)
    root = tree.getroot()

    # Define the namespace
    ns = {'ipxact': 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'}

    # Find all 'addressBlock' elements
    for addressBlock in root.iterfind('.//ipxact:addressBlock', ns):
        blockName = addressBlock.find('ipxact:name', ns).text
        if (debug_print): print(f'Address Block: {blockName}')

        baseAddress = int(addressBlock.find('ipxact:baseAddress', ns).text.lstrip("'h"), 16)

        # Find all 'register' elements inside the 'addressBlock' and get their 'name' and 'addressOffset' children
        for register in addressBlock.findall('ipxact:register', ns):
            name = "LPDDR_" + blockName + "_" + register.find('ipxact:name', ns).text
            addressOffset = int(register.find('ipxact:addressOffset', ns).text.lstrip("'h"), 16)
            totalAddress = baseAddress + addressOffset
            register_dict[name] = f"{totalAddress:#0{10}x}"
            if (debug_print): print(f'Added to dictionary: {name}: {f"{totalAddress:#0{10}x}"}')

    if (debug_print):
      print("\nFinal dictionary:")
      # Print the dictionary line by line
      for name, address in register_dict.items():
          print(f'{name}: {address}')

    # Return the register dictionary
    return register_dict

def generate_file_header(args):
  ret = []
  ret.append(f'/**')
  ret.append('')
  ret.append(f'Automatically generated by {sys.argv[0]} using the parameters:')
  ret.append(f'')
  for v in vars(args):
    ret.append(f'  {v}: {vars(args)[v]}')
  ret.append(f'')
  ret.append(f'  full command-line args: {str(sys.argv)}')
  ret.append(f'')
  ret.append(f'**/')
  ret.append('')
  return ret

# --------------------------------------------------------------
# Main
# --------------------------------------------------------------
def main():
    # Parse the arguments
    args = parse_arguments()

    # Update the input_file and output_file with the values from the arguments
    input_file = args.input_file
    output_file = args.output_file

    # For demonstration, just print the file paths
    print(f"Input file: {input_file}")
    print(f"Output file: {output_file}")
    print(f"XML file: {DEFAULT_XML_FILE}")

    # Call the function to replace text
    replace_in_file(input_file, output_file, args)

    print(f"Replacement completed.")

if __name__ == "__main__":
    main()
