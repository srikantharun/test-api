#!/usr/bin/env python3

import sys
import os
import lief
from pathlib import Path
import argparse
import yaml
import logging
from collections import defaultdict
from dataclasses import dataclass
from collections.abc import Callable


repo_root = Path(os.environ.get("REPO_ROOT", ""))

l2_interleaving_legal_values = (
        "CONTIGUOUS",
        "INTER_1X8_1K",
        "INTER_1X8_2K",
        "INTER_1X8_4K",
        "INTER_2X4_1K",
        "INTER_2X4_2K",
        "INTER_2X4_4K")

@dataclass
class WordWithAddr:
    # byte address in memory
    addr: int
    # word as byte array
    data: bytearray


@dataclass
class HexBuffer:
    # name of the buffer (including memory name)
    name: str
    # list of words
    data: list[bytearray]
    # ecc callback
    ecc_cb: Callable[[str],str] | None = None

    def texthex(self) -> str:
        hex_words = []
        for word in self.data:
            hex_str = "".join(f"{x:02x}" for x in reversed(word))
            if self.ecc_cb:
                hex_str = self.ecc_cb(hex_str)
            hex_words.append(hex_str + "\n")
        return "".join(hex_words)


def parse_hex(s):
    """Parse a number which can be either in hex or decimal format."""
    try:
        return int(s, 0)  # Automatically interprets hex if prefixed with '0x' or '0X'
    except ValueError:
        raise argparse.ArgumentTypeError(f"Invalid number: {s}")


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-m",
        "--memory",
        nargs="+",
        default=[],
        help="List of memories to dump. If the specified memory contains sub-regions, all of those will be dumped instead.",
    )
    parser.add_argument("-e", "--elf", nargs="+", help="List of ELF files to process.")
    parser.add_argument("-w", "--width", default=[256], nargs="+", type=int, help="Bitwidth of the memory.")
    parser.add_argument("--start-address", type=parse_hex, help="Start address.")
    parser.add_argument("--size", type=parse_hex, help="Size address.")
    parser.add_argument("-d", "--debug", action="store_true", help="Enable debug messages generated by texthexify")
    parser.add_argument("--l2_interleaving", type=str, default="INTER_1X8_4K", help="Choose L2 interleaving mode")
    return parser.parse_known_args()


def file_created_at(file_path: Path):
    file_path = Path(file_path)
    if not file_path.exists():
        return 0
    stat = os.stat(file_path)
    try:
        creation_time = stat.st_mtime
    except AttributeError:
        creation_time = 0
    return creation_time


def bit_select(bitfield, upper_bit, lower_bit):
    """returns bitfield[upper_bit : lower_bit]"""
    length = upper_bit - lower_bit + 1;
    return (bitfield >> lower_bit) & ((1<<length) - 1)


def read_elf_to_buffer_for_memory(elf_file: Path, mem_start_address: int, mem_size: int):

    # Parse the ELF file
    elf = lief.parse(elf_file)

    # 1. compute max_address to avoid overallocating memory in "buffer". E.g.: 32GB for LPDDR
    # 2. allocate "buffer" to max_address bytes and fill it
    max_address = 0
    buffer = bytearray()
    for fill_buffer in range(2):
        if fill_buffer:
            buffer = bytearray(max_address) # TODO: Jovin or Alexandros, this makes the texthexify script super slow when the elf does not contain a memory section in the range that the mmap target looks for.
        for section in elf.sections:
            if mem_start_address <= section.virtual_address and section.virtual_address <= mem_start_address + mem_size:
                _start = section.virtual_address - mem_start_address
                _stop = min(_start + section.size, mem_start_address + mem_size)
                if fill_buffer:
                    buffer[_start:_stop] = section.content
                elif _start != _stop:
                    max_address = max(_stop, max_address)

    return buffer[:max_address]


def split_into_words(buffer: bytearray, bitwidth: int) -> list[bytearray]:
    word_size = bitwidth // 8

    words = []
    for byte_idx in range(0, len(buffer), word_size):
        upper_bound = min(len(buffer), byte_idx + word_size)
        word = buffer[byte_idx:upper_bound]
        if len(word) < word_size:
            word.extend([0] * (word_size - len(word)))
        words.append(WordWithAddr(addr=byte_idx, data=word))
    return words


def split_into_buffers_flat(memory_name: str, words: list[WordWithAddr]) -> list[HexBuffer]:
    buffer = HexBuffer(
        name=memory_name,
        data=[word.data for word in words],
    )
    return [buffer]


def split_into_buffers_l1(memory_name: str, words: list[WordWithAddr]) -> list[HexBuffer]:
    # L1: index is (sub_bank, mini_bank)
    L1_BITWIDTH = 128
    L1_NB_SUB_BANKS = 4
    L1_NB_MINI_BANKS = 16

    words_per_buffer = defaultdict(lambda: [])
    for word in words:
        word_addr = word.addr // (L1_BITWIDTH // 8)
        sub_bank_idx = word_addr % L1_NB_SUB_BANKS
        mini_bank_idx = (word_addr // L1_NB_SUB_BANKS) % L1_NB_MINI_BANKS
        buffer_idx = (sub_bank_idx, mini_bank_idx)
        words_per_buffer[buffer_idx].append(word.data)

    buffers = []
    for sb in range(L1_NB_SUB_BANKS):
        for mb in range(L1_NB_MINI_BANKS):
            buffers.append(
                HexBuffer(
                    name=f"{memory_name}.sb_{sb}.mb_{mb}",
                    data=words_per_buffer[(sb, mb)],
                )
            )
    return buffers


def l2_get_addr_after_interleaving(addr_before_interleaving: int, l2_interleaving: str) -> int:
    if l2_interleaving == "CONTIGUOUS":
        return addr_before_interleaving
    elif l2_interleaving == "INTER_1X8_1K":
        module = bit_select(addr_before_interleaving, 12, 10)
        addr_in_module = bit_select(addr_before_interleaving, 9, 0) + \
                (bit_select(addr_before_interleaving, 26, 24) << 10 )+ \
                (bit_select(addr_before_interleaving, 23, 13) << 13)
    elif l2_interleaving == "INTER_1X8_2K":
        module = bit_select(addr_before_interleaving, 13, 11)
        addr_in_module = bit_select(addr_before_interleaving, 10, 0) + \
                (bit_select(addr_before_interleaving, 26, 24) << 11 )+ \
                (bit_select(addr_before_interleaving, 23, 14) << 14)
    elif l2_interleaving == "INTER_1X8_4K":
        module = bit_select(addr_before_interleaving, 14, 12)
        addr_in_module = bit_select(addr_before_interleaving, 11, 0) + \
                (bit_select(addr_before_interleaving, 26, 24) << 12 )+ \
                (bit_select(addr_before_interleaving, 23, 15) << 15)
    else:
        logging.error(f"{l2_interleaving=} is not supported yet")
        sys.exit(1)
    return (module << 24) + addr_in_module


def split_into_buffers_l2(memory_name: str, words: list[WordWithAddr], l2_interleaving: str) -> list[HexBuffer]:
    if l2_interleaving not in l2_interleaving_legal_values:
        logging.error(f"{l2_interleaving=} is not in {l2_interleaving_legal_values}")
        sys.exit(1)

    # addr_before_interleaving -> [NOC] -> addr_after_interleaving -> [L2] (module,bank,ram,sram_8B_word_addr,sram)
    L2_NUM_MODULES = 8
    L2_NUM_BANKS = 16
    L2_NUM_RAMS = 4
    L2_NUM_SRAMS = 4
    L2_NUM_SRAM_8B_WORDS = 4096

    words_per_buffer = defaultdict(lambda: L2_NUM_SRAM_8B_WORDS*[bytearray()])
    for word in words:
        addr_after_interleaving = l2_get_addr_after_interleaving(word.addr, l2_interleaving)
        module = bit_select(addr_after_interleaving, 26, 24)
        bank = bit_select(addr_after_interleaving, 23, 20)
        ram = bit_select(addr_after_interleaving, 19, 18)
        sram_8B_word_addr = bit_select(addr_after_interleaving, 17, 6)
        sram = bit_select(addr_after_interleaving, 5, 4)
        words_per_buffer[(module, bank, ram, sram)][sram_8B_word_addr] = word.data

    buffers = []
    for module in range(L2_NUM_MODULES):
        for bank in range(L2_NUM_BANKS):
            for ram in range(L2_NUM_RAMS):
                for sram in range(L2_NUM_SRAMS):
                    buffers.append(
                        HexBuffer(
                            name=f"{memory_name}.module_{module}.bank_{bank}.ram_{ram}.sram_{sram}",
                            data=words_per_buffer[(module, bank, ram, sram)],
                        )
                    )
    return buffers


def odd_parity(number):
    p = False
    d = number
    while d:
        p = not p
        d &= (d-1)
    return p


def ecc_cb_spm(hex_str: str) -> str:
    data = int(hex_str, 16)
    ecc = odd_parity(data & 0xB9000000001FFFFF) + \
            (odd_parity(data & 0x5E00000FFFE0003F) << 1) + \
            (odd_parity(data & 0x67003FF003E007C1) << 2) + \
            (odd_parity(data & 0xCD0FC0F03C207842) << 3) + \
            (odd_parity(data & 0xB671C711C4438884) << 4) + \
            (odd_parity(data & 0xB5B65926488C9108) << 5) + \
            (odd_parity(data & 0xCBDAAA4A91152210) << 6) + \
            (odd_parity(data & 0x7AED348D221A4420) << 7)
    ecc_str = f"{ecc:02x}"
    return f"{ecc_str}{hex_str}"


def split_into_buffers_spm(memory_name: str, words: list[WordWithAddr], nb_bk: int, nb_sb: int, nb_mb: int, nb_inst: int, words_per_inst: int) -> list[HexBuffer]:
    # SPM: index is (bank, sub_bank, mini_bank, instance)
    SPM_BITWIDTH = 64
    SPM_BYTES_PER_INST = words_per_inst * (SPM_BITWIDTH // 8)

    words_per_buffer = defaultdict(lambda: [])
    for word in words:
        idx = word.addr // SPM_BYTES_PER_INST
        inst = idx % nb_inst
        idx //= nb_inst
        mb = idx % nb_mb
        idx //= nb_mb
        sb = idx % nb_sb
        idx //= nb_sb
        bk = idx % nb_bk
        idx //= nb_bk
        assert idx == 0, "No more index parts remaining."
        buffer_idx = (bk, sb, mb, inst)
        words_per_buffer[buffer_idx].append(word.data)

    buffers = []
    for bk in range(nb_bk):
        for sb in range(nb_sb):
            for mb in range(nb_mb):
                for inst in range(nb_inst):
                    buffers.append(
                        HexBuffer(
                            name=f"{memory_name}.bk_{bk}.sb_{sb}.mb_{mb}.inst_{inst}",
                            data=words_per_buffer[(bk, sb, mb, inst)],
                            ecc_cb=ecc_cb_spm
                        )
                    )
    return buffers


def dump_memory_to_file(elf_file: str, buffers: list[HexBuffer], bitwidth: int):
    """Write buffers to output files."""

    elf_path = Path(elf_file)
    os.makedirs(elf_path.parent / "texthexify", exist_ok=True)
    for buffer in buffers:
        texthex_file = Path(f"{elf_path.parent}/texthexify/{elf_path.name}.{buffer.name}.{bitwidth}b.texthex")

        if file_created_at(elf_path) < file_created_at(texthex_file):
            logging.debug(f"no work to do. {texthex_file}")
            continue

        with open(texthex_file, "w") as file:
            file.write(buffer.texthex())

        size = (bitwidth // 8) * len(buffer.data)
        logging.debug(f"generated {texthex_file} (Size: 0x{size:08X})")


def dump_memory(elf_file: str, target_mem: str, mem_start_address: int, mem_size: int, bitwidths: list[int], l2_interleaving: str):

    buffer = read_elf_to_buffer_for_memory(elf_file, mem_start_address, mem_size)

    mem_type = target_mem.split(".")[-1]

    for bitwidth in bitwidths:
        # Must be multiple of 8
        if bitwidth % 8 != 0:
            raise ValueError(f"Bitwith {bitwidth} must be a muliple of 8")

        # split into words
        data = split_into_words(buffer, bitwidth)

        # sort words into buffers (depending on memory type)
        if "l1" in mem_type:
            assert bitwidth == 128, "L1 memory has 128-bit words."
            buffers = split_into_buffers_l1(target_mem, data)
        elif target_mem.startswith("l2"):
            assert bitwidth == 128, "L2 memory has 128-bit words."
            buffers = split_into_buffers_l2(target_mem, data, l2_interleaving)
        elif target_mem.startswith("aicore_") and mem_type == "spm":
            assert bitwidth == 64, "AICORE SPM memory has 64-bit words."
            # TODO: Change this once real SPM is used by AICORE.
            buffers = split_into_buffers_spm(target_mem, data, 2, 1, 2, 2, 8192)
            #buffers = split_into_buffers_flat(target_mem, data)
        elif target_mem.startswith("pve_") and mem_type == "spm":
            assert bitwidth == 64, "PVE SPM memory has 64-bit words."
            buffers = split_into_buffers_spm(target_mem, data, 2, 2, 2, 2, 2048)
        elif target_mem == "sys_spm":
            assert bitwidth == 64, "SYS SPM memory has 64-bit words."
            buffers = split_into_buffers_flat(target_mem, data)
            dump_memory_to_file(elf_file, buffers, bitwidth)
            buffers = split_into_buffers_spm(target_mem, data, 4, 4, 4, 2, 8192)
        else:
            # Default: No sub-blocks or shuffling, treat as a single flat buffer
            buffers = split_into_buffers_flat(target_mem, data)

        # dump to files
        dump_memory_to_file(elf_file, buffers, bitwidth)


def read_memorymap():
    memory_map_yml = repo_root / "hw/impl/europa/data/memory_map/memory_map.yml"

    if not memory_map_yml.is_file():
        logging.error(f"Memory map file {memory_map_yml} does not exist.")
        sys.exit(1)

    with memory_map_yml.open("r") as f:
        mmap = yaml.safe_load(f)

    return mmap["memory_map"]


def get_start_address_and_offset(data, name) -> list:
    """Returns a list of memory regions based on the specified memory name.

    If the specified name points to a region containing sub-regions, the list will contains all subregions.
    """
    parts = name.split(".")
    region = None

    for entry in data:
        if entry["name"] == parts[0]:
            region = entry
            break

    if not region:
        logging.warning(f"Region '{parts[0]}' not found")
        return None

    # merge L2 subregions "module_[01234567]", since the split of those modules
    # depends on the interleaving mode
    is_l2 = False
    if "name" in region and region["name"] == "l2":
        is_l2 = True

    ret = []
    if len(parts) == 1:
        # Print top-level region
        if "regions" in region and not is_l2:
            # Top-level region contains subregions: print all of them
            for subregion in region.get("regions", []):
                sub_name = f"{parts[0]}.{subregion['name']}"
                sub_offset = int(region["offset"]) + int(subregion["offset"])
                sub_size = subregion["size"]

                ret.append((sub_name, sub_offset, sub_size))
        else:
            # Top-level region without subregions
            reg_name = f"{parts[0]}"
            reg_offset = int(region["offset"])
            reg_size = region["size"]
            ret.append((reg_name, reg_offset, reg_size))

    elif len(parts) == 2:
        # Print specific single subregion
        for subregion in region.get("regions", []):
            if subregion["name"] == parts[1]:
                sub_name = f"{parts[0]}.{subregion['name']}"
                sub_offset = int(region["offset"]) + int(subregion["offset"])
                sub_size = subregion["size"]

                ret.append((sub_name, sub_offset, sub_size))
                return ret
    return ret


if __name__ == "__main__":
    args, _ = parse_args()

    if args.l2_interleaving and args.l2_interleaving not in l2_interleaving_legal_values:
        logging.error(f"Memory map file {memory_map_yml} does not exist.")
        sys.exit(1)

    mmap = read_memorymap()

    logging_level = logging.WARNING
    if args.debug:
        logging_level = logging.DEBUG
    logging.basicConfig(level=logging_level, stream=sys.stdout, format="texthexify: %(message)s")

    for elf in args.elf:
        for target_mem in args.memory:
            target_mem = target_mem.lower()

            regions = get_start_address_and_offset(mmap, target_mem)

            for reg_name, reg_offset, reg_size in regions:
                dump_memory(elf, reg_name, reg_offset, reg_size, args.width, args.l2_interleaving)

        if args.start_address and args.size:
            dump_memory(elf, "custom", args.start_address, args.size, args.width, args.l2_interleaving)
