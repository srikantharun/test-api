// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Register Top module auto-generated by `reggen`
<%
  from reggen import gen_rtl
  from reggen.access import HwAccess, SwRdAccess, SwWrAccess
  from reggen.lib import get_basename
  from reggen.register import Register
  from reggen.multi_register import MultiRegister
  from reggen.bits import Bits

  num_wins = len(rb.windows)
  num_reg_dsp = 1 if rb.all_regs else 0
  num_dsp  = num_wins + num_reg_dsp
  regs_flat = rb.flat_regs
  max_regs_char = len("{}".format(len(regs_flat) - 1))
  addr_width = rb.get_addr_width()

  if block.axi_intf:
    # for axi make sure at least 4KB (12 bits) is checked in the address
    addr_width = max(addr_width, 12);

  # Used for the dev_select_i signal on a tlul_socket_1n with N =
  # num_wins + 1. This needs to be able to represent any value up to
  # N-1.
  steer_msb = ((num_wins).bit_length()) - 1

  lblock = block.name.lower()
  ublock = lblock.upper()

  u_mod_base = mod_base.upper()

  reg2hw_t = gen_rtl.get_iface_tx_type(block, if_name, False)
  hw2reg_t = gen_rtl.get_iface_tx_type(block, if_name, True)

  win_array_decl = f'  [{num_wins}]' if num_wins > 1 else ''

  # Calculate whether we're going to need an AW parameter. We use it if there
  # are any registers (obviously). We also use it if there are any windows that
  # don't start at zero and end at 1 << addr_width (see the "addr_checks"
  # calculation below for where that comes from).
  needs_aw = (bool(regs_flat) or
              num_wins > 1 or
              rb.windows and (
                rb.windows[0].offset != 0 or
                rb.windows[0].size_in_bytes != (1 << addr_width)))


  common_data_intg_gen = 0 if rb.has_data_intg_passthru else 1
  adapt_data_intg_gen = 1 if rb.has_data_intg_passthru else 0
  assert common_data_intg_gen != adapt_data_intg_gen

  # declare a fully asynchronous interface
  reg_clk_expr = "clk_i"
  reg_rst_expr = "rst_ni"
  apb_h2d_expr = "apb_i"
  apb_d2h_expr = "apb_o"
  if rb.async_if:
    apb_h2d_expr = "apb_async_h2d"
    apb_d2h_expr = "apb_async_d2h"
    for clock in rb.clocks.values():
      reg_clk_expr = clock.clock
      reg_rst_expr = clock.reset
%>

`ifndef LOWRISC_${mod_name.upper()}
`define LOWRISC_${mod_name.upper()}

//synopsys translate_off
`ifdef ASSERTIONS_ON
  `include "prim_assert.sv"
`endif
//synopsys translate_on

module ${mod_name} #(
% if rb.async_if:
  parameter int unsigned LogDepth = 2,
% endif
  parameter int unsigned StageNum = 3
) (
  input  logic clk_i,
  input  logic rst_ni,
% if rb.has_internal_shadowed_reg():
  input  logic rst_shadowed_ni,
% endif
% for clock in rb.clocks.values():
  input  logic ${clock.clock},
  input  logic ${clock.reset},
% endfor
% if block.axi_intf:
  input  ${lblock}_reg_pkg::axi_a_ch_h2d_t axi_aw_i,
  output logic axi_awready,
  input  ${lblock}_reg_pkg::axi_a_ch_h2d_t axi_ar_i,
  output logic axi_arready,
  input  ${lblock}_reg_pkg::axi_w_ch_h2d_t axi_w_i,
  output logic axi_wready,
  output ${lblock}_reg_pkg::axi_b_ch_d2h_t axi_b_o,
  input  logic axi_bready,
  output ${lblock}_reg_pkg::axi_r_ch_d2h_t axi_r_o,
  input  logic axi_rready,
% else:
  input  ${lblock}_reg_pkg::apb_h2d_t apb_i,
  output ${lblock}_reg_pkg::apb_d2h_t apb_o,
% endif
% if num_wins != 0:

  // Output port for window
  output ${lblock}_reg_pkg::apb_h2d_t apb_win_o${win_array_decl},
  input  ${lblock}_reg_pkg::apb_d2h_t apb_win_i${win_array_decl},
% endif
  // To HW
% if rb.get_n_bits(["q","qe","re"]):
  output ${lblock}_reg_pkg::${reg2hw_t} reg2hw, // Write
% endif
% if rb.get_n_bits(["d","de"]):
  input  ${lblock}_reg_pkg::${hw2reg_t} hw2reg, // Read
% endif
% if rb.async_if:
  input logic test_mode_i,
% endif
  // Config
  input devmode_i // If 1, explicit error return for unmapped register access
);

  import ${lblock}_reg_pkg::* ;

% if needs_aw:
  localparam int AW = ${addr_width};
% endif
% if rb.all_regs:
  localparam int DW = ${block.regwidth};
  localparam int DBW = DW/8;                    // Byte Width

  // register signals
  logic           reg_we;
  logic           reg_re;
  logic [AW-1:0]  reg_rd_addr;
  logic [AW-1:0]  reg_wr_addr;
  logic [DW-1:0]  reg_wdata;
  logic [DBW-1:0] reg_be;
  logic [DW-1:0]  reg_rdata;
  logic           reg_rd_error;
  logic           reg_wr_error;
  % if not block.axi_intf:
  logic           reg_error;
  % endif

  logic          wr_addrmiss, wr_err;
  logic          rd_addrmiss, rd_err;

  logic [DW-1:0] reg_rdata_next;
  logic reg_busy;

% if block.axi_intf:
  logic axi2reg_wvld;
  logic axi2reg_wrdy;
  logic [AXI_AW-1:0] axi2reg_waddr;
  logic [${block.regwidth}-1:0] axi2reg_wdata;
  logic [(${block.regwidth}+7)/8-1:0] axi2reg_wstrb;
  logic axi2reg_wresp_vld;
  logic axi2reg_wresp_rdy;
  logic axi2reg_wresp_error;

  logic axi2reg_rvld;
  logic axi2reg_rrdy;
  logic [AXI_AW-1:0] axi2reg_raddr;
  logic [${block.regwidth}-1:0] axi2reg_rresp_data;
  logic axi2reg_rresp_vld;
  logic axi2reg_rresp_rdy;
  logic axi2reg_rresp_error;
% else:
  ${lblock}_reg_pkg::apb_h2d_t apb_reg_h2d;
  ${lblock}_reg_pkg::apb_d2h_t apb_reg_d2h;
% endif
% endif

% if rb.async_if:
  apb_h2d_t apb_async_h2d;
  apb_d2h_t apb_async_d2h;

  cdc_apb  #(
    .STAGE_NUM      ( STAGE_NUM  ),
    .DATA_WIDTH     ( 32 ),
    .ADDR_WIDTH     ( 32 ),
    .STRB_WIDTH     ( 4 )
  ) i_cdc_apb (
    // i.f to APB master
    .clk_mstr_i      (clk_i)),
    .rst_mstr_ni     (rst_ni),
    .mstr_psel_i     (apb_i.psel),
    .mstr_penable_i  (apb_i.penable),
    .mstr_pwrite_i   (apb_i.pwrite),
    .mstr_pstrb_i    (apb_i.pstrb),
    .mstr_paddr_i    (apb_i.paddr),
    .mstr_pwdata_i   (apb_i.pwdata),
    .mstr_pready_o   (apb_o.pready),
    .mstr_prdata_o   (apb_o.prdata),
    .mstr_pslverr_o  (apb_o.pslverr),
    // i.f to APB slave
    .clk_slv_i      (${reg_clk_expr})),
    .rst_slv_ni     (${reg_rst_expr}),
    .slv_psel_o     (${apb_h2d_expr}.psel),
    .slv_penable_o  (${apb_h2d_expr}.penable),
    .slv_pwrite_o   (${apb_h2d_expr}.pwrite),
    .slv_pstrb_o    (${apb_h2d_expr}.pstrb),
    .slv_paddr_o    (${apb_h2d_expr}.paddr),
    .slv_pwdata_o   (${apb_h2d_expr}.pwdata),
    .slv_pready_i   (${apb_d2h_expr}.pready),
    .slv_prdata_i   (${apb_d2h_expr}.prdata),
    .slv_pslverr_i  (${apb_d2h_expr}.pslverr),
    // Test mode
    .test_mode_i   (test_mode_i)
 );

% endif

% if block.axi_intf:
    axi2reg #(
    .IDW(AXI_IDW),
    .AW(AXI_AW),
    .DW(${block.regwidth}),
    .BW(AXI_LENW),
    .NR_WR_REQS(2),
    .NR_RD_REQS(2),
    .WBUF(2),
    .OSR(2),
    .RD_RESP_DEPTH(2),
    .WR_RESP_DEPTH(2)
  ) i_axi_reg (
    .i_clk  (clk_i),
    .i_rst_n(rst_ni),

    ///// AXI slave
    // Write Address Channel
    .awid(axi_aw_i.id),
    .awaddr(axi_aw_i.addr),
    .awlen(axi_aw_i.len),
    .awsize(axi_aw_i.size),
    .awburst(axi_aw_i.burst),
    .awvalid(axi_aw_i.valid),
    .awready(axi_awready),
    // Read Address Channel
    .arid(axi_ar_i.id),
    .araddr(axi_ar_i.addr),
    .arlen(axi_ar_i.len),
    .arsize(axi_ar_i.size),
    .arburst(axi_ar_i.burst),
    .arvalid(axi_ar_i.valid),
    .arready(axi_arready),
    // Write  Data Channel
    .wdata(axi_w_i.data),
    .wstrb(axi_w_i.strb),
    .wlast(axi_w_i.last),
    .wvalid(axi_w_i.valid),
    .wready(axi_wready),
    // Read Data Channel
    .rid(axi_r_o.id),
    .rdata(axi_r_o.data),
    .rresp(axi_r_o.resp),
    .rlast(axi_r_o.last),
    .rvalid(axi_r_o.valid),
    .rready(axi_rready),
    // Write Response Channel
    .bid(axi_b_o.id),
    .bresp(axi_b_o.resp),
    .bvalid(axi_b_o.valid),
    .bready(axi_bready),

    ////// reg master:
    // Write path:
    .reg_wvld(axi2reg_wvld),
    .reg_wrdy(axi2reg_wrdy),
    .reg_waddr(axi2reg_waddr),
    .reg_wdata(axi2reg_wdata),
    .reg_wstrb(axi2reg_wstrb),
    .reg_wresp_vld(axi2reg_wresp_vld),
    .reg_wresp_rdy(axi2reg_wresp_rdy),
    .reg_wresp_error(axi2reg_wresp_error),

    // Read path:
    .reg_rvld(axi2reg_rvld),
    .reg_rrdy(axi2reg_rrdy),
    .reg_raddr(axi2reg_raddr),
    .reg_rresp_vld(axi2reg_rresp_vld),
    .reg_rresp_rdy(axi2reg_rresp_rdy),
    .reg_rresp_error(axi2reg_rresp_error),
    .reg_rresp_data(axi2reg_rresp_data)
  );

% else:
  logic [AW-1:0]  paddr_q;
  logic [DBW-1:0] pstrb_q;
  logic           pwrite_q;
% if num_dsp <= 1:
  ## Either no windows (and just registers) or no registers and only
  ## one window.
  % if num_wins == 0:
  assign apb_reg_h2d = ${apb_h2d_expr};
  assign ${apb_d2h_expr}   = apb_reg_d2h;
  % else:
  assign apb_win_o = ${apb_h2d_expr};
  assign ${apb_d2h_expr} = apb_win_i;
  % endif
% else:
  apb_h2d_t apb_socket_h2d [${num_dsp}];
  apb_d2h_t apb_socket_d2h [${num_dsp}];

  logic [${steer_msb}:0] reg_steer;
  logic [${steer_msb}:0] reg_steer_q;

  // socket_1n connection
  % if rb.all_regs:
  assign apb_reg_h2d = apb_socket_h2d[${num_wins}];
  assign apb_socket_d2h[${num_wins}] = apb_reg_d2h;

% endif
  % for i,t in enumerate(rb.windows):
<%
      win_suff = f'[{i}]' if num_wins > 1 else ''
%>\
  assign apb_win_o${win_suff} = apb_socket_h2d[${i}];
  assign apb_socket_d2h[${i}] = apb_win_i${win_suff};
  % endfor

  always_comb begin
  % for k in range(num_dsp):
    apb_socket_h2d[${k}] = ${apb_h2d_expr};
  % endfor
    for (int unsigned i=0; i<${k}; i++) begin
      apb_socket_h2d[i].psel = (reg_steer == i) ? ${apb_h2d_expr}.psel : 1'b0;
      apb_socket_h2d[i].penable = (reg_steer == i) ? ${apb_h2d_expr}.penable : 1'b0;
    end
    // back path
    ${apb_d2h_expr} = apb_socket_d2h[reg_steer_q];
  end

  // Create steering logic for windows.
  always_comb begin
    unique case (${f'{apb_h2d_expr}.paddr[AW-1:0]'}) inside
  % for i,w in enumerate(rb.windows):
<%
      base_addr = w.offset
      limit_addr = w.offset + w.size_in_bytes
      assert (limit_addr-1 >= base_addr)
      addr_test = f"[{base_addr}:{limit_addr-1}]"
%>\
      ${addr_test}: begin
        reg_steer = ${i};
      end
  % endfor
      default: begin
        // Default set to register
        reg_steer = ${num_dsp-1};
      end
    endcase

  end
  // Create steering logic for windows rdata and slverr, where the flopped address should be used.
  always_comb begin
    unique case (paddr_q[AW-1:0]) inside
  % for i,w in enumerate(rb.windows):
<%
      base_addr = w.offset
      limit_addr = w.offset + w.size_in_bytes
      assert (limit_addr-1 >= base_addr)
      addr_test = f"[{base_addr}:{limit_addr-1}]"
%>\
      ${addr_test}: begin
        reg_steer_q = ${i};
      end
  % endfor
      default: begin
        // Default set to register
        reg_steer_q = ${num_dsp-1};
      end
    endcase

  end
% endif
% endif // end on else of axi_intf

% if rb.all_regs:

% if block.axi_intf:
  assign reg_rd_addr = axi2reg_raddr;
  // always accept, if response can accept.
  // AXI2REG will pipeline read data, so no need to add latency here:
  assign axi2reg_rrdy = axi2reg_rresp_rdy & !reg_busy;
  assign axi2reg_rresp_vld = axi2reg_rvld & !reg_busy;
  assign axi2reg_rresp_data = reg_rdata;
  assign axi2reg_rresp_error = reg_rd_error;
  assign reg_re = axi2reg_rvld & axi2reg_rresp_rdy;

  assign reg_wr_addr = axi2reg_waddr;
  // always accept, if response can accept.
  assign axi2reg_wrdy = axi2reg_wresp_rdy & !reg_busy;
  assign axi2reg_wresp_vld = axi2reg_wvld & !reg_busy;
  assign axi2reg_wresp_error = reg_wr_error;
  assign reg_we = axi2reg_wvld & axi2reg_wresp_rdy;
  assign reg_wdata = axi2reg_wdata;
  assign reg_be = axi2reg_wstrb;
% else:
  // Translate from APB to register interface.
  typedef enum {
    SETUP, ACCESS
  } state_e;
  state_e state_d, state_q;

  assign reg_rd_addr = paddr_q;
  assign reg_wr_addr = paddr_q;
  assign reg_wdata = apb_reg_h2d.pwdata;
  assign reg_be = pstrb_q;
  logic nc_pprot;
  always_comb nc_pprot = |apb_reg_h2d.pprot; // ASO-UNUSED_VARIABLE: pprot is not used in the csr

  assign apb_reg_d2h.prdata = reg_rdata;
  assign apb_reg_d2h.pslverr = reg_error;

  always_comb begin
      state_d = state_q;
      apb_reg_d2h.pready = 1'b0;
      reg_re = 1'b0;
      reg_we = 1'b0;

      unique case (state_q)
        SETUP: begin
          if (apb_reg_h2d.psel & ~apb_reg_h2d.penable) state_d = ACCESS;
        end
        ACCESS: begin
          reg_re = !pwrite_q;
          reg_we = pwrite_q;
          apb_reg_d2h.pready = !reg_busy;
          if (apb_reg_d2h.pready) state_d = SETUP;
        end
        default:;
      endcase
  end

  always_ff @(posedge ${reg_clk_expr} or negedge ${reg_rst_expr}) begin
    if (!${reg_rst_expr}) begin
      state_q <= SETUP;
      paddr_q <= AW'(0);
      pstrb_q <= DBW'(0);
      pwrite_q <= 1'b0;
    end else begin
      if (apb_reg_h2d.psel) begin
        state_q <= state_d;
        if (~apb_reg_h2d.penable) begin
          pstrb_q <= apb_reg_h2d.pstrb;
          pwrite_q <= apb_reg_h2d.pwrite;
        end
      end
      if (apb_i.psel & ~apb_i.penable)
        paddr_q <= apb_reg_h2d.paddr;
    end
  end

  % if not rb.async_if:
  // cdc oversampling signals
    % for clock in rb.clocks.values():
  <%
    clk_name = clock.clock_base_name
    tgl_expr = clk_name + "_tgl"
    cname = clock.clock
    rname = clock.reset
  %>\
  logic sync_${clk_name}_update;
  prim_sync_reqack u_${tgl_expr} (
    .clk_src_i(${cname}),
    .rst_src_ni(${rname}),
    .clk_dst_i(${reg_clk_expr}),
    .rst_dst_ni(${reg_rst_expr}),
    .req_chk_i(1'b1),
    .src_req_i(1'b1),
    .src_ack_o(),
    .dst_req_o(sync_${clk_name}_update),
    .dst_ack_i(sync_${clk_name}_update)
  );
    % endfor
  % endif
  % endif // not axi_intf

  % if block.expose_reg_if:
  assign reg2hw.reg_if.reg_we    = reg_we;
  assign reg2hw.reg_if.reg_re    = reg_re;
  assign reg2hw.reg_if.reg_addr  = reg_addr;
  assign reg2hw.reg_if.reg_wdata = reg_wdata;
  assign reg2hw.reg_if.reg_be    = reg_be;

  % endif
  assign reg_rdata = reg_rdata_next ;
  assign reg_rd_error = (devmode_i & rd_addrmiss) | rd_err;
  assign reg_wr_error = (devmode_i & wr_addrmiss) | wr_err;
  % if not block.axi_intf:
  assign reg_error = reg_wr_error | reg_rd_error;
  % endif
  // Define SW related signals
  // Format: <reg>_<field>_{wd|we|qs}
  //        or <reg>_{wd|we|qs} if field == 1 or 0
  % for r in regs_flat:
${reg_sig_decl(r)}\
    % for f in r.fields:
<%
        fld_suff = '_' + f.name.lower() if len(r.fields) > 1 else ''
        sig_name = r.name.lower() + fld_suff
%>\
${field_sig_decl(f, sig_name, r.hwext, r.shadowed, r.async_clk)}\
    % endfor
  % endfor
  % if len(rb.clocks.values()) > 0:
  // Define register CDC handling.
  // CDC handling is done on a per-reg instead of per-field boundary.
  % endif
  % for r in regs_flat:
    % if r.async_clk:
<%
  base_name = r.async_clk.clock_base_name
  r_name = r.name.lower()
  src_we_expr = f"{r_name}_we" if r.needs_we() else "'0"
  src_wd_expr = f"reg_wdata[{r.get_width()-1}:0]" if r.needs_we() else "'0"
  src_re_expr = f"{r_name}_re" if r.needs_re() else "'0"
  src_regwen_expr = f"{r.regwen.lower()}_qs" if r.regwen else "'0"
  dst_we_expr = f"{base_name}_{r_name}_we" if r.needs_we() else ""
  dst_wd_expr = f"{base_name}_{r_name}_wdata" if r.needs_we() else ""
  dst_re_expr = f"{base_name}_{r_name}_re" if r.needs_re() else ""
  dst_regwen_expr = f"{base_name}_{r_name}_regwen" if r.regwen else ""
%>
      % if len(r.fields) > 1:
        % for f in r.fields:
  logic ${str_arr_sv(f.bits)} ${base_name}_${r_name}_${f.name.lower()}_qs_int;
        % endfor
      % else:
  logic ${str_arr_sv(r.fields[0].bits)} ${base_name}_${r_name}_qs_int;
      % endif
  logic [${r.get_width()-1}:0] ${base_name}_${r_name}_d;
      % if r.needs_we():
  logic [${r.get_width()-1}:0] ${base_name}_${r_name}_wdata;
  logic ${base_name}_${r_name}_we;
  logic unused_${base_name}_${r_name}_wdata;
      % endif
      % if r.needs_re():
  logic ${base_name}_${r_name}_re;
      % endif
      % if r.regwen:
  logic ${base_name}_${r_name}_regwen;
      % endif

  always_comb begin
    ${base_name}_${r_name}_d = '0;
      % if len(r.fields) > 1:
        % for f in r.fields:
    ${base_name}_${r_name}_d[${str_bits_sv(f.bits)}] = ${base_name}_${r_name}_${f.name.lower()}_qs_int;
        % endfor
      % else:
    ${base_name}_${r_name}_d = ${base_name}_${r_name}_qs_int;
      % endif
  end

  prim_reg_cdc #(
    .StageNum(StageNum),
    .DataWidth(${r.get_width()}),
    .ResetVal(${r.get_width()}'h${format(r.resval, "x")}),
    .BitMask(${r.get_width()}'h${r.bitmask()})
  ) u_${r_name}_cdc (
    .clk_src_i    (${reg_clk_expr}),
    .rst_src_ni   (${reg_rst_expr}),
    .clk_dst_i    (${r.async_clk.clock}),
    .rst_dst_ni   (${r.async_clk.reset}),
    .src_update_i (sync_${r.async_clk.clock_base_name}_update),
    .src_regwen_i (${src_regwen_expr}),
    .src_we_i     (${src_we_expr}),
    .src_re_i     (${src_re_expr}),
    .src_wd_i     (${src_wd_expr}),
    .src_busy_o   (${r_name}_busy),
    .src_qs_o     (${r_name}_qs), // for software read back
    .dst_d_i      (${base_name}_${r_name}_d),
    .dst_we_o     (${dst_we_expr}),
    .dst_re_o     (${dst_re_expr}),
    .dst_regwen_o (${dst_regwen_expr}),
    .dst_wd_o     (${dst_wd_expr})
  );
      % if r.needs_we():
  // spyglass disable_block W528
  assign unused_${base_name}_${r_name}_wdata = ^${base_name}_${r_name}_wdata;
  // spyglass enable_block W528
      % endif
    % endif
  % endfor

  // Register instances
  % for r in rb.all_regs:
<%
      if isinstance(r, MultiRegister):
        r0 = r.reg
        srs = r.regs
      else:
        r0 = r
        srs = [r]

      reg_name = r0.name.lower()
      fld_count = 0
%>\
    % for sr_idx, sr in enumerate(srs):
<%
        sr_name = sr.name.lower()

        if isinstance(r, MultiRegister):
          reg_hdr = (f'  // Subregister {sr_idx} of Multireg {reg_name}\n' +
                     f'  // R[{sr_name}]: V({sr.hwext})')
        else:
          reg_hdr = (f'  // R[{sr_name}]: V({sr.hwext})')
%>\
${reg_hdr}
      % for field in sr.fields:
<%
          if isinstance(r, MultiRegister):
            sig_idx = fld_count if r.is_homogeneous() else sr_idx
            fsig_pfx = '{}[{}]'.format(reg_name, sig_idx)
          else:
            fsig_pfx = reg_name

          fld_count += 1

          fld_name = field.name.lower()
          if len(sr.fields) == 1:
            finst_name = sr_name
            fsig_name = fsig_pfx
          else:
            finst_name = sr_name + '_' + fld_name
            if isinstance(r, MultiRegister):
              if r.is_homogeneous():
                fsig_name = fsig_pfx
              else:
                fsig_name = '{}.{}'.format(fsig_pfx, get_basename(fld_name))
            else:
              fsig_name = '{}.{}'.format(fsig_pfx, fld_name)
%>\
        % if len(sr.fields) > 1:
  //   F[${fld_name}]: ${field.bits.msb}:${field.bits.lsb}
        % endif
${finst_gen(sr, field, finst_name, fsig_name)}
      % endfor

    % endfor
  % endfor

  logic [${len(regs_flat)-1}:0] rd_addr_hit;
  always_comb begin
    rd_addr_hit = '0;
    // spyglass disable_block W415a
    % for i,r in enumerate(regs_flat):
    rd_addr_hit[${"{}".format(i).rjust(max_regs_char)}] = (reg_rd_addr == ${ublock}_${r.name.upper()}_OFFSET);
    % endfor
    // spyglass enable_block W415a
  end

  logic [${len(regs_flat)-1}:0] wr_addr_hit;
  always_comb begin
    wr_addr_hit = '0;
    // spyglass disable_block W415a
    % for i,r in enumerate(regs_flat):
    wr_addr_hit[${"{}".format(i).rjust(max_regs_char)}] = (reg_wr_addr == ${ublock}_${r.name.upper()}_OFFSET);
    % endfor
    // spyglass enable_block W415a
  end

  assign rd_addrmiss = (reg_re) ? ~|rd_addr_hit : 1'b0 ;
  assign wr_addrmiss = (reg_we) ? ~|wr_addr_hit : 1'b0 ;

  % if regs_flat:
<%
    # We want to signal wr_err if we are writing and not enabling (reg_be)
    # any field that is permitted to be written. That's true if
    # addr_hit[i] and no bit is set in reg_be and corresponding *_WR_BYTES[i].

    wr_err_terms = ['(wr_addr_hit[{idx}] & (~|({mod}_WR_BYTES[{idx}] & reg_be)))'
                    .format(idx=str(i).rjust(max_regs_char),
                            mod=u_mod_base)
                    for i in range(len(regs_flat))]
    wr_err_expr = (' |\n' + (' ' * 15)).join(wr_err_terms)

    # We want to signal rd_err if we are reading from a register that is write only.
    # That's true if addr_hit[i] and *_REG_NO_RD[i].

    rd_err_terms = ['(rd_addr_hit[{idx}] & (~{mod}_REG_READABLE[{idx}]))'
                    .format(idx=str(i).rjust(max_regs_char),
                            mod=u_mod_base)
                    for i in range(len(regs_flat))]
    rd_err_expr = (' |\n' + (' ' * 15)).join(rd_err_terms)
%>\
  // Check sub-word write is permitted
  always_comb begin
    wr_err = (reg_we &
              (${wr_err_expr}));
    rd_err = (reg_re &
              (${rd_err_expr}));
  end
  % else:
  assign wr_err = 1'b0;
  assign rd_err = 1'b0;
  % endif\

  % for i, r in enumerate(regs_flat):
${reg_enable_gen(r, i)}\
    % if len(r.fields) == 1:
${field_wd_gen(r.fields[0], r.name.lower(), r.hwext, r.shadowed, r.async_clk, r.name, i)}\
    % else:
      % for f in r.fields:
${field_wd_gen(f, r.name.lower() + "_" + f.name.lower(), r.hwext, r.shadowed, r.async_clk, r.name, i)}\
      % endfor
    % endif
  % endfor

  // Read data return
  always_comb begin
    reg_rdata_next = '0;
    unique case (1'b1)
  % for i, r in enumerate(regs_flat):
    % if r.async_clk:
      rd_addr_hit[${i}]: begin
        reg_rdata_next = DW'(${r.name.lower()}_qs);
      end
    % elif len(r.fields) == 1:
      rd_addr_hit[${i}]: begin
${rdata_gen(r.fields[0], r.name.lower())}\
      end

    % else:
      rd_addr_hit[${i}]: begin
      % for f in r.fields:
${rdata_gen(f, r.name.lower() + "_" + f.name.lower())}\
      % endfor
      end

    % endif
  % endfor
      default: begin
        reg_rdata_next = '1;
      end
    endcase
  end

  // shadow busy
  logic shadow_busy;
  % if rb.has_internal_shadowed_reg():
  logic rst_done;
  logic shadow_rst_done;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      rst_done <= '0;
    end else begin
      rst_done <= 1'b1;
    end
  end

  always_ff @(posedge clk_i or negedge rst_shadowed_ni) begin
    if (!rst_shadowed_ni) begin
      shadow_rst_done <= '0;
    end else begin
      shadow_rst_done <= 1'b1;
    end
  end

  // both shadow and normal resets have been released
  assign shadow_busy = ~(rst_done & shadow_rst_done);
  % else:
  assign shadow_busy = 1'b0;
  % endif

  // register busy
  % if rb.async_if:
  assign reg_busy = shadow_busy;
  % else:
  logic reg_busy_sel;
  assign reg_busy = reg_busy_sel | shadow_busy;
  always_comb begin
    reg_busy_sel = '0;
    % if len([r for r in regs_flat if r.async_clk]) > 0:
    unique case (1'b1)
    % for i, r in enumerate(regs_flat):
      % if r.async_clk:
      wr_addr_hit[${i}]: begin
        reg_busy_sel = ${r.name.lower() + "_busy"};
      end
      % endif
    % endfor
      default: begin
        reg_busy_sel  = '0;
      end
    endcase
    % endif
  end

  % endif
% endif

  // Unused signal tieoff
% if rb.all_regs:

  // wdata / byte enable are not always fully used
  // add a blanket unused statement to handle lint
  logic unused_wdata;
  logic unused_be;
  assign unused_wdata = ^reg_wdata; // ASO-UNUSED_VARIABLE: unused_* not being used
  assign unused_be = ^reg_be; // ASO-UNUSED_VARIABLE: unused_* not being used
% else:
  // devmode_i is not used if there are no registers
  logic unused_devmode;
  assign unused_devmode = ^devmode_i; // ASO-UNUSED_VARIABLE: unused_* not being used
% endif
% if rb.all_regs:

//synopsys translate_off
`ifdef ASSERTIONS_ON

  // Assertions for Register Interface
% if not block.axi_intf:
  `ASSERT_PULSE(wePulse, reg_we, ${reg_clk_expr}, !${reg_rst_expr})
  `ASSERT_PULSE(rePulse, reg_re, ${reg_clk_expr}, !${reg_rst_expr})
% endif


  `ASSERT(ren2addrHit, (reg_re) |-> $onehot0(rd_addr_hit), ${reg_clk_expr}, !${reg_rst_expr})
  `ASSERT(wen2addrHit, (reg_we) |-> $onehot0(wr_addr_hit), ${reg_clk_expr}, !${reg_rst_expr})

  // this is formulated as an assumption such that the FPV testbenches do disprove this
  // property by mistake
  //`ASSUME(reqParity, apb_reg_h2d.a_valid |-> apb_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)

`endif
//synopsys translate_on

% endif
endmodule
<%def name="str_bits_sv(bits)">\
% if bits.msb != bits.lsb:
${bits.msb}:${bits.lsb}\
% else:
${bits.msb}\
% endif
</%def>\
<%def name="str_arr_sv(bits)">\
% if bits.msb != bits.lsb:
[${bits.msb-bits.lsb}:0] \
% endif
</%def>\
<%def name="reg_sig_decl(reg)">\
  % if reg.needs_re():
  logic ${reg.name.lower()}_re;
  % endif
  % if reg.needs_we():
  logic ${reg.name.lower()}_we;
  % endif
  % if reg.async_clk:
  logic [${reg.get_width()-1}:0] ${reg.name.lower()}_qs;
  logic ${reg.name.lower()}_busy;
  % endif
</%def>\
<%def name="field_sig_decl(field, sig_name, hwext, shadowed, async_clk)">\
  % if not async_clk and field.swaccess.allows_read():
  logic ${str_arr_sv(field.bits)}${sig_name}_qs;
  % endif
  % if not async_clk and field.swaccess.allows_write():
  logic ${str_arr_sv(field.bits)}${sig_name}_wd;
  % endif
</%def>\
<%def name="finst_gen(reg, field, finst_name, fsig_name)">\
<%

    clk_base_name = f"{reg.async_clk.clock_base_name}_" if reg.async_clk else ""
    reg_name = reg.name.lower()
    clk_expr = reg.async_clk.clock if reg.async_clk else reg_clk_expr
    rst_expr = reg.async_clk.reset if reg.async_clk else reg_rst_expr
    re_expr = f'{reg_name}_re' if field.swaccess.allows_read() or reg.shadowed else "1'b0"

    # software inputs to field instance, write enable, read enable, write data
    if field.swaccess.allows_write():
      # We usually use the REG_we signal, but use REG_re for RC fields
      # (which get updated on a read, not a write)
      we_suffix = 're' if field.swaccess.swrd() == SwRdAccess.RC else 'we'
      we_signal = f'{clk_base_name}{reg_name}_{we_suffix}'

      if reg.async_clk and reg.regwen:
        we_expr = f'{we_signal} & {clk_base_name}{reg_name}_regwen'
      elif reg.regwen:
        we_expr = f'{we_signal} & {reg.regwen.lower()}_qs'
      else:
        we_expr = we_signal

      # when async, pick from the cdc handled data
      wd_expr = f'{finst_name}_wd'
      if reg.async_clk:
        if field.bits.msb == field.bits.lsb:
          bit_sel = f'{field.bits.msb}'
        else:
          bit_sel = f'{field.bits.msb}:{field.bits.lsb}'
        wd_expr = f'{clk_base_name}{reg_name}_wdata[{bit_sel}]'

    else:
      we_expr = "1'b0"
      wd_expr = "'0"

    # hardware inputs to field instance
    if field.hwaccess.allows_write():
      de_expr = f'hw2reg.{fsig_name}.de'
      d_expr = f'hw2reg.{fsig_name}.d'
    else:
      de_expr = "1'b0"
      d_expr = "'0"

    # field instance outputs
    qre_expr = f'reg2hw.{fsig_name}.re' if reg.hwre or reg.shadowed else ""

    if field.hwaccess.allows_read():
      qe_expr = f'reg2hw.{fsig_name}.qe' if reg.hwqe else ''
      q_expr = f'reg2hw.{fsig_name}.q'
    else:
      qe_expr = ''
      q_expr = ''

    # when async, the outputs are aggregated first by the cdc module
    async_suffix = '_int' if reg.async_clk else ''
    qs_expr = f'{clk_base_name}{finst_name}_qs{async_suffix}' if field.swaccess.allows_read() else ''

    qre_aso = " // ASO-UNUSED_OUTPUT: port not used" if qre_expr == '' else ""
    qe_aso  = " // ASO-UNUSED_OUTPUT: port not used" if qe_expr == '' else ""
    q_aso   = " // ASO-UNUSED_OUTPUT: port not used" if q_expr == '' else ""
    qs_aso   = " // ASO-UNUSED_OUTPUT: port not used" if qs_expr == '' else ""
%>\
<%

    if reg.async_clk:
      update_expr = "sync_" + reg.async_clk.clock.strip("_iclk_")+ "_update"
%>\
  % if reg.hwext:       ## if hwext, instantiate prim_subreg_ext
<%
    subreg_block = "prim_subreg_ext"
%>\
  ${subreg_block} #(
    .DW    (${field.bits.width()})
  ) u_${finst_name} (
    .re     (${re_expr}),
    .we     (${we_expr}),
    .wd     (${wd_expr}),
    .d      (${d_expr}),
    .qre    (${qre_expr}),${qre_aso}
    .qe     (${qe_expr}),${qe_aso}
    .q      (${q_expr}),${q_aso}
    .qs     (${qs_expr})${qs_aso}
  );
  % else:
<%
      # This isn't a field in a hwext register. Instantiate prim_subreg,
      # prim_subreg_shadow or constant assign.

      resval_expr = f"{field.bits.width()}'h{field.resval or 0:x}"
      is_const_reg = not (field.hwaccess.allows_read() or
                          field.hwaccess.allows_write() or
                          field.swaccess.allows_write() or
                          field.swaccess.swrd() != SwRdAccess.RD)

      subreg_block = 'prim_subreg' + ('_shadow' if reg.shadowed else '')
%>\
    % if is_const_reg:
  // constant-only read
  assign ${finst_name}_qs = ${resval_expr};
    % else:
  ${subreg_block} #(
    .DW      (${field.bits.width()}),
    .SwAccess(prim_subreg_pkg::SwAccess${field.swaccess.value[1].name.upper()}),
    .RESVAL  (${resval_expr})
  ) u_${finst_name} (
    .clk_i   (${clk_expr}),
    .rst_ni  (${rst_expr}),
      % if reg.shadowed and not reg.hwext:
    .rst_shadowed_ni (rst_shadowed_ni),
      % endif

    // from register interface
      % if reg.shadowed:
    .re     (${re_expr}),
      % endif
    .we     (${we_expr}),
    .wd     (${wd_expr}),

    // from internal hardware
    .de     (${de_expr}),
    .d      (${d_expr}),

    // to internal hardware
    .qe     (${qe_expr}),${qe_aso}
    .q      (${q_expr}),${q_aso}

    // to register interface (read)
      % if not reg.shadowed:
    .qs     (${qs_expr})${qs_aso}
      % else:
    .qs     (${qs_expr}),${qs_aso}

    // Shadow register error conditions
    .err_update  (reg2hw.${fsig_name}.err_update),
    .err_storage (reg2hw.${fsig_name}.err_storage)
      % endif
  );
    % endif  ## end non-constant prim_subreg
  % endif
</%def>\
<%def name="reg_enable_gen(reg, idx)">\
  % if reg.needs_re():
  assign ${reg.name.lower()}_re = rd_addr_hit[${idx}] & reg_re & !reg_rd_error;
  % endif
  % if reg.needs_we():
  assign ${reg.name.lower()}_we = wr_addr_hit[${idx}] & reg_we & !reg_wr_error;
  % endif
</%def>\
<%def name="field_wd_gen(field, sig_name, hwext, shadowed, async_clk, reg_name, idx)">\
<%
    needs_wd = field.swaccess.allows_write()
    space = '\n' if needs_wd or needs_re else ''
%>\
${space}\
% if needs_wd and not async_clk:
  % if field.swaccess.swrd() == SwRdAccess.RC:
  assign ${sig_name}_wd = '1;
  % else:
  assign ${sig_name}_wd = reg_wdata[${str_bits_sv(field.bits)}];
  % endif
% endif
</%def>\
<%def name="rdata_gen(field, sig_name, rd_name='reg_rdata_next')">\
% if field.swaccess.allows_read():
        ${rd_name}[${str_bits_sv(field.bits)}] = ${sig_name}_qs;
% else:
        ${rd_name}[${str_bits_sv(field.bits)}] = '0;
% endif
</%def>\
<%def name="reg_enable_gen(reg, idx)">\
  % if reg.needs_re():
  assign ${reg.name.lower()}_re = rd_addr_hit[${idx}] & reg_re & !reg_rd_error;
  % endif
  % if reg.needs_we():
  assign ${reg.name.lower()}_we = wr_addr_hit[${idx}] & reg_we & !reg_wr_error;
  % endif
</%def>\
<%def name="reg_cdc_gen(field, sig_name, hwext, shadowed, idx)">\
<%
    needs_wd = field.swaccess.allows_write()
    space = '\n' if needs_wd or needs_re else ''
%>\
${space}\
% if needs_wd:
  % if field.swaccess.swrd() == SwRdAccess.RC:
  assign ${sig_name}_wd = '1;
  % else:
  assign ${sig_name}_wd = reg_wdata[${str_bits_sv(field.bits)}];
  % endif
% endif
</%def>\

`endif
