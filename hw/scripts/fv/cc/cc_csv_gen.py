#!/usr/bin/env python3

# (C) Copyright 2024 Axelera AI B.V.
# All Rights Reserved
# *** Axelera AI Confidential ***

import csv
import argparse
import logging
from typing import List, Dict
from datetime import datetime
from pathlib import Path
import getpass
import yaml

# Constants for Implementation CSV Columns
IMPLEMENTED_COLUMN      = 'Implemented'
SOURCE_INSTANCE_COLUMN  = 'Source Instance'
SOURCE_PORT_COLUMN      = 'Source Port'
DEST_INSTANCE_COLUMN    = 'Destination Instance'
DEST_PORT_COLUMN        = 'Destination Port'
INTERFACE_TYPE_COLUMN   = 'Interface Type'
SIGNAL_NAME_COLUMN      = 'Name'
ENABLE_CONNECTION       = 'Enable Connection'

# Constants for generated CC CSV
CSV_HEADERS             = ['name', 'source_expr', 'destination_expr', 'enable_expr']
DEFAULT_BUS_CONN_CSV    = "bus_conn.csv"
DEFAULT_FV_CC_CSV       = "connectivity_checks.csv"
DEFAULT_PROTOCOL       = "europa_top.yml"

# Setup logging configuration
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Define the standard signal names for various communication protocols(based on direction)
signals_dict = {}

def get_signal_direction(bus: str, direction: str, type: str) -> str:
    """
    Determine the direction prefix ('i_' or 'o_') for a signal based on its protocol, type, and bus role.
    In current protocol defination, only manager ports are defined, subordinate ports take the opposite direction of the corresponding manager ports.
    In the connection csv file, the source will always be the manager ports. Therefore, we use "s" and "d" to identify manager or subordinate.
    """
    if direction == "output":
        return "o_" if type=="s" else "i_"
    elif direction == "input":
        return "i_" if type=="s" else "o_"
    else:
        return ""  # Return empty string if direction is not specified or recognized


def construct_signal_name(instance: str, bus: str, port: str, direction: str, type: str) -> str:
    """
    Construct a full signal name based on instance name, role (source or destination),
    protocol, and individual signal name.

    Args:
    instance (str): The name of the hardware instance.
    bus (str): The bus identifier.
    port (str): The port identifier.
    direction (str): The connectivity direction ('input' or 'output').
    type (str): the type of signal ('s' or 'd').

    Returns:
    str: The full path for the signal expression based on the specified parameters.
    """

    direction_str = get_signal_direction(bus, direction, type)
    name = ""
    if instance:
      name += f"{instance}."
    if port:
        name += f"{direction_str}{bus}_{port}"
    else:
        name += f"{bus}"
    return name

def write_csv_header(file, header_comment: str, bus_conn_csv: str) -> None:
    """
    Writes a header with metadata to a CSV file.

    Args:
    file: A file object with write capabilities.
    header_comment (str): A custom comment or description to include in the header.
    """
    username = getpass.getuser()  # Get the current user's login name
    script_name = Path(__file__).name  # Get the name of the current script

    file.write("#" * 50 + "\n")  # create a separator before the header
    file.write("## {}\n".format(header_comment))
    file.write("## Generated on     : {}\n".format(datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
    file.write("## Generated by     : {}\n".format(username))
    file.write("## Generated from   : {}\n".format(bus_conn_csv))
    file.write("## Generated using  : {}\n".format(script_name))
    file.write("#" * 50 + "\n")  # create a separator after the header
    logging.debug("Header written to the CSV file.")

def generate_connectivity_rows(row: Dict[str, str]) -> List[Dict[str, str]]:
    """
    Generate connectivity check rows based on the interface type and source-destination pair.

    Args:
    row (dict): A dictionary containing the details from one row of the input CSV file.

    Returns:
    list: A list of dictionaries, each representing a row to be written to the output CSV.
    """
    rows        = []
    implemented = row.get(IMPLEMENTED_COLUMN)
    source_inst = row.get(SOURCE_INSTANCE_COLUMN)
    source_port = row.get(SOURCE_PORT_COLUMN, '')
    dest_inst   = row.get(DEST_INSTANCE_COLUMN)
    dest_port   = row.get(DEST_PORT_COLUMN, '')
    protocol    = row.get(INTERFACE_TYPE_COLUMN)
    enable_con  = row.get(ENABLE_CONNECTION)

    if implemented not in ['yes', 'x']:
        return rows

    if row['Type'] == 'Protocol' and protocol in signals_dict:
        for direction in ['input', 'output']:
            for protocol_sig in signals_dict[protocol][direction]:
                # "s" for source, "d" for dest
                source_expr = construct_signal_name(source_inst, source_port, protocol_sig, direction, "s")
                destination_expr = construct_signal_name(dest_inst, dest_port, protocol_sig, direction, "d")

                # Check if source prefix is "i_" and invert source and destination
                if source_expr.startswith(f"{source_inst}.i_") or source_expr.startswith(f"o_"):
                    source_expr, destination_expr = destination_expr, source_expr

                ## Check if both expressions have the same prefix and handle error
                #if source_expr.split('.')[-1][:2] == destination_expr.split('.')[-1][:2]:
                #    print(f"Error: source and destination expressions cannot have the same direction prefix")

                enable_expr = "1" if enable_con == "N/A" or enable_con == "" else enable_con
                if source_expr and destination_expr:
                    rows.append({
                        "name": destination_expr,
                        "source_expr": source_expr,
                        "destination_expr": destination_expr,
                        "enable_expr": enable_expr
                    })
                else:
                    print(f"Error generating expression for source: {source_inst} and destination: {dest_inst} for protocol: {protocol}")

    else:
        source_expr = construct_signal_name(source_inst, source_port, "", 'output', "s")
        destination_expr = construct_signal_name(dest_inst, dest_port, "", 'input', "d")
        enable_expr = "1"
        if source_expr and destination_expr:
            rows.append({
                "name": destination_expr,
                "source_expr": source_expr,
                "destination_expr": destination_expr,
                "enable_expr": enable_expr
            })
        else:
            print(f"Error generating expression for source: {source_inst} and destination: {dest_inst}")

    return rows

def read_bus_conn_csv(bus_conn_csv: Path) -> List[Dict[str, str]]:
    """
    Read the input CSV file and process each row to generate connectivity check data.

    Args:
    bus_conn_csv (Path): Filename of the input CSV file.

    Returns:
    list: A list of dictionaries, each representing a row to be written to the output CSV.
    """
    output_rows = []
    with bus_conn_csv.open(mode='r', newline='') as file:
        csv_reader = csv.DictReader(file)
        logging.debug(f"Opened bus connectivity CSV at {bus_conn_csv}")
        row_count = 1
        for row in csv_reader:
            row_count += 1
            logging.debug(f"Processing row {row_count}: {row}")
            connectivity = generate_connectivity_rows(row)
            output_rows.extend(connectivity)
            logging.info(f"Generated {len(connectivity)} connections for entry on Line: {row_count}")
    return output_rows

def write_fv_cc_csv(output_rows: List[Dict[str, str]], bus_conn_csv: str, fv_cc_csv: Path) -> None:
    """
    Write the generated rows to an output CSV file.

    Args:
    output_rows (list): A list of dictionaries representing the rows to be written.
    fv_cc_csv (str): Filename of the output CSV file.
    """
    try:
        with fv_cc_csv.open(mode='w', newline='') as file:
            # Write metadata header with a custom comment
            write_csv_header(file, "Generated for FV connectivity checks", bus_conn_csv)
            csv_writer = csv.DictWriter(file, fieldnames=CSV_HEADERS)
            csv_writer.writeheader()
            csv_writer.writerows(output_rows)
    except Exception as e:
        logging.error(f"Failed to write to CSV: {e}")
    logging.info(f"Output CSV written with {len(output_rows)} entries to '{fv_cc_csv}'")

def main(bus_conn_csv: str, fv_cc_csv: str) -> None:
    """
    Main function to handle the flow of reading input CSV, generating connectivity checks, and writing them to output CSV.

    Args:
    bus_conn_csv (str): Input CSV filename.
    fv_cc_csv (str): Output CSV filename.
    """
    logging.info(f"Starting the connectivity checks generation process, input: '{bus_conn_csv}'")
    input_path  = Path(bus_conn_csv)
    output_path = Path(fv_cc_csv)
    output_rows = read_bus_conn_csv(input_path)
    write_fv_cc_csv(output_rows, bus_conn_csv, output_path)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate connectivity checks based on CSV input.")

    parser.add_argument('--bus_conn_csv',
                        type=str,
                        default=DEFAULT_BUS_CONN_CSV,
                        help=f"Input CSV file name. Default is '{DEFAULT_BUS_CONN_CSV}'.")

    parser.add_argument('--fv_cc_csv',
                        type=str,
                        default=DEFAULT_FV_CC_CSV,
                        help=f"Output CSV file name. Default is '{DEFAULT_FV_CC_CSV}'.")

    parser.add_argument('--protocol_file',
                        type=str,
                        default=DEFAULT_PROTOCOL,
                        help=f"YAML file with the protocols definition. Default is '{DEFAULT_PROTOCOL}'.")

    args = parser.parse_args()

    print(args.protocol_file)
    with open(args.protocol_file, 'r') as file:
      protocols_yaml = yaml.safe_load(file)
    signals_dict = protocols_yaml['protocols']
    main(args.bus_conn_csv, args.fv_cc_csv)
