module {{ top_level_name }} #(
  parameter int unsigned NumPowerPadsPerRow = 2
)(
{%- for port_group in port_groups -%}
  {{ port_group.render }}
{% endfor%}
  input logic i_dft_enable
);
  //////////////////////////////
  // Power Pad Instantiations //
  //////////////////////////////
  localparam int unsigned NUM_PAD_ROWS = {{ number_of_pad_rows }};

  // Note one can not declare a wire in s struct, however declare it when decalred.
  wire axe_tcl_pad_pkg::impl_pwr_t impl_power[NUM_PAD_ROWS];

  for (genvar pad_row_idx = 0; unsigned'(pad_row_idx) < NUM_PAD_ROWS; pad_row_idx++) begin : gen_rows
    for (genvar power_pad_idx = 0; unsigned'(power_pad_idx) < NumPowerPadsPerRow; power_pad_idx++) begin : gen_power
      axe_tcl_pad_power #(
        .ImplementationKey("vertical"),
        .impl_inp_t       (logic), // Not used
        .impl_oup_t       (axe_tcl_pad_pkg::impl_pwr_t)
      ) u_pad_power (
        .i_impl(1'b0), // Not used
        .o_impl(impl_power[pad_row_idx])
      );
    end
  end

  ///////////////////////////////////
  // Oscillator Pad Instantiations //
  ///////////////////////////////////
{%- for oscillator in oscillator_list %}
  //////////////////////////////////////////////////////////////////////////////////////////////////
  // {{ oscillator.direction.name.capitalize() }} Pad instantiation for {{ oscillator.name }}
  //////////////////////////////////////////////////////////////////////////////////////////////////
  axe_tcl_pad_pkg::impl_{{ oscillator.padtype.value }}_inp_t {{ oscillator.name_sanitized }}_impl_inp;
  axe_tcl_pad_pkg::impl_{{ oscillator.padtype.value }}_oup_t {{ oscillator.name_sanitized }}_impl_oup; // Stubbed

  always_comb {{ oscillator.name_sanitized }}_impl_inp = '{
    {% if oscillator.padtype.value in ["oscillator_fast"] -%}
    sf:  {{ oscillator.core_signal_drive }},
    {% endif -%}
    poe: {{ "1'b0" }}  // Stubbed
  };

  // Bypass signal, must be mutually exclusive with oscillator enable, bypass is overwrite
  logic {{ oscillator.name_sanitized }}_oscillation_enable;
  logic {{ oscillator.name_sanitized }}_bypass;

  always_comb {{ oscillator.name_sanitized }}_oscillation_enable = {{ oscillator.name_sanitized }}_bypass ? 1'b0 : {{ oscillator.core_signal_output_enable }};

  axe_tcl_pad_oscillator #(
    .ImplementationKey("{{ oscillator.implementation_key }}"),
    .impl_inp_t       (axe_tcl_pad_pkg::impl_{{ oscillator.padtype.value }}_inp_t),
    .impl_oup_t       (axe_tcl_pad_pkg::impl_{{ oscillator.padtype.value }}_oup_t),
    .impl_pwr_t       (axe_tcl_pad_pkg::impl_pwr_t)
  ) {{ oscillator.instance_name }} (
    .o_clk     ({{ oscillator.core_signal_input }}),
    .i_enable  ({{ oscillator.name_sanitized }}_oscillation_enable),
    .i_test_en ({{ oscillator.name_sanitized }}_bypass),
    .i_impl    ({{ oscillator.name_sanitized }}_impl_inp),
    .o_impl    ({{ oscillator.name_sanitized }}_impl_oup),
    .i_impl_pwr(impl_power[{{ oscillator.row_index }}]),
    .o_pad     ({{ oscillator.pad_signal_oup }}),
    .i_pad     ({{ oscillator.pad_signal_inp }})
  );

  // External pad to control clock bypass
  axe_tcl_pad_pkg::impl_pad_slow_inp_t {{ oscillator.name_sanitized }}_bypass_impl_inp;
  axe_tcl_pad_pkg::impl_pad_slow_oup_t {{ oscillator.name_sanitized }}_bypass_impl_oup; // Stubbed

  always_comb {{ oscillator.name_sanitized }}_bypass_impl_inp = '{
    is:  {{ "1'b1" }},
    ds:  {{ "2'b00" }},
    poe: {{ "1'b0" }}
  };

  logic {{ oscillator.name_sanitized }}_pull_type;
  logic {{ oscillator.name_sanitized }}_pull_en;

  // By default have the pad pull itself down such that the oscillator is in oscillating mode.
  always_comb {{ oscillator.name_sanitized }}_pull_type = 1'b0;
  always_comb {{ oscillator.name_sanitized }}_pull_en   = 1'b1;

  axe_tcl_pad_input #(
    .ImplementationKey("{{ oscillator.implementation_key.replace("fast", "slow") }}"),
    .impl_inp_t       (axe_tcl_pad_pkg::impl_pad_slow_inp_t),
    .impl_oup_t       (axe_tcl_pad_pkg::impl_pad_slow_oup_t),
    .impl_pwr_t       (axe_tcl_pad_pkg::impl_pwr_t)
  ) {{ oscillator.instance_name }}_bypass (
    .o_inp      ({{ oscillator.name_sanitized }}_bypass),
    .i_inp_en   (1'b1),
    .i_pull_type({{ oscillator.name_sanitized }}_pull_type),
    .i_pull_en  ({{ oscillator.name_sanitized }}_pull_en),
    .i_impl     ({{ oscillator.name_sanitized }}_bypass_impl_inp),
    .o_impl     ({{ oscillator.name_sanitized }}_bypass_impl_oup),
    .i_impl_pwr (impl_power[{{ oscillator.row_index }}]),
    .i_pad      ({{ oscillator.pad_signal_inp }}_bypass)
  );
{% endfor %}
  ///////////////////////////////////
  // Functional Pad Instantiations //
  ///////////////////////////////////
{%- for pad in pad_list %}
  //////////////////////////////////////////////////////////////////////////////////////////////////
  // {{ pad.direction.name.capitalize() }} Pad instantiation for {{ pad.name }}
  //////////////////////////////////////////////////////////////////////////////////////////////////
  {% if pad.direction.value in ["output", "inout"] -%}
  logic {{ pad.name_sanitized }}_oup;
  logic {{ pad.name_sanitized }}_oup_en;
  {% endif -%}
  {% if pad.direction.value in ["input", "inout"] -%}
  logic {{ pad.name_sanitized }}_inp;
  logic {{ pad.name_sanitized }}_inp_en;
  {% endif -%}
  logic {{ pad.name_sanitized }}_pull_type;
  logic {{ pad.name_sanitized }}_pull_en;

  axe_tcl_pad_pkg::impl_pad_{{ pad.padtype.value }}_inp_t       {{ pad.name_sanitized }}_impl_inp;
  axe_tcl_pad_pkg::impl_pad_{{ pad.padtype.value }}_oup_t       {{ pad.name_sanitized }}_impl_oup; // Stubbed

{%- if pad.dft %}
  axe_tcl_pad_pkg::impl_pad_{{ pad.padtype.value }}_inp_t [1:0] {{ pad.name_sanitized }}_impl_inp_mux;
  axe_tcl_pad_pkg::impl_pad_{{ pad.padtype.value }}_oup_t [1:0] {{ pad.name_sanitized }}_impl_oup_mux; // Stubbed

  always_comb begin
    {{ pad.name_sanitized }}_impl_inp_mux[0] = '{
      is:  {{ pad.core_signal_schmitt }},
      ds:  {{ pad.core_signal_drive }},
      poe: {{ "1'b0" }}  // Stubbed
    };
    {{ pad.name_sanitized }}_impl_inp_mux[1] = '{
      is:  {{ pad.dft_signal_schmitt }},
      ds:  {{ pad.dft_signal_drive }},
      poe: {{ "1'b0" }}  // Stubbed
    };
  end

  axe_ccl_dft_pad_mux_{{ pad.direction.value }} #(
    .impl_inp_t(axe_tcl_pad_pkg::impl_pad_{{ pad.padtype.value }}_inp_t),
    .impl_oup_t(axe_tcl_pad_pkg::impl_pad_{{ pad.padtype.value }}_oup_t)
  ) {{ pad.instance_name }}_dft_mux (
    .i_dft_enable,
    {% if pad.direction.value in ["output", "inout"] -%}
    .i_func_oup          ({{ pad.core_signal_output }}),
    .i_func_oup_en       ({{ pad.output_enable_expr }}),
    {% endif -%}
    {% if pad.direction.value in ["input", "inout"] -%}
    .o_func_inp          ({{ pad.core_signal_input }}),
    .i_func_inp_en       ({{ pad.input_enable_expr }}),
    {% endif -%}
    .i_func_pull_type    ({{ pad.core_signal_pull_type }}),
    .i_func_pull_en      ({{ pad.core_signal_pull_enable }}),
    .i_func_impl_inp     ({{ pad.name_sanitized }}_impl_inp_mux[0]),
    .o_func_impl_oup     ({{ pad.name_sanitized }}_impl_oup_mux[0]),
    {% if pad.direction.value in ["output", "inout"] -%}
    .i_dft_oup           ({{ pad.dft_signal_output }}),
    .i_dft_oup_en        ({{ pad.dft_signal_output_enable }}),
    {% endif -%}
    {% if pad.direction.value in ["input", "inout"] -%}
    .o_dft_inp           ({{ pad.dft_signal_input }}),
    .i_dft_inp_en        ({{ pad.dft_signal_input_enable }}),
    {% endif -%}
    .i_dft_pull_type     ({{ pad.dft_signal_pull_type }}),
    .i_dft_pull_en       ({{ pad.dft_signal_pull_enable }}),
    .i_dft_impl_inp      ({{ pad.name_sanitized }}_impl_inp_mux[1]),
    .o_dft_impl_oup      ({{ pad.name_sanitized }}_impl_oup_mux[1]),
    {% if pad.direction.value in ["output", "inout"] -%}
    .o_padside_oup       ({{ pad.name_sanitized }}_oup),
    .o_padside_oup_en    ({{ pad.name_sanitized }}_oup_en),
    {% endif -%}
    {% if pad.direction.value in ["input", "inout"] -%}
    .i_padside_inp       ({{ pad.name_sanitized }}_inp),
    .o_padside_inp_en    ({{ pad.name_sanitized }}_inp_en),
    {% endif -%}
    .o_padside_pull_type ({{ pad.name_sanitized }}_pull_type),
    .o_padside_pull_en   ({{ pad.name_sanitized }}_pull_en),
    .o_padside_impl_inp  ({{ pad.name_sanitized }}_impl_inp),
    .i_padside_impl_oup  ({{ pad.name_sanitized }}_impl_oup)
  );
{%- else %}
  {% if pad.direction.value in ["output", "inout"] -%}
  always_comb {{ pad.name_sanitized }}_oup       = {{ pad.core_signal_output }};
  always_comb {{ pad.name_sanitized }}_oup_en    = {{ pad.output_enable_expr }};
  {% endif -%}
  {% if pad.direction.value in ["input", "inout"] -%}
  {% if "/*" not in pad.core_signal_input -%}
  always_comb {{ pad.core_signal_input }} = {{ pad.name_sanitized }}_inp;
  {% endif -%}
  always_comb {{ pad.name_sanitized }}_inp_en    = {{ pad.input_enable_expr }};
  {% endif -%}
  always_comb {{ pad.name_sanitized }}_pull_type = {{ pad.core_signal_pull_type }};
  always_comb {{ pad.name_sanitized }}_pull_en   = {{ pad.core_signal_pull_enable }};

  always_comb {{ pad.name_sanitized }}_impl_inp = '{
    is:  {{ pad.core_signal_schmitt }},
    ds:  {{ pad.core_signal_drive }},
    poe: {{ "1'b0" }}
  };
{%- endif %}

  axe_tcl_pad_{{ pad.direction.value }} #(
    .ImplementationKey("{{ pad.implementation_key }}"),
    .impl_inp_t       (axe_tcl_pad_pkg::impl_pad_{{ pad.padtype.value }}_inp_t),
    .impl_oup_t       (axe_tcl_pad_pkg::impl_pad_{{ pad.padtype.value }}_oup_t),
    .impl_pwr_t       (axe_tcl_pad_pkg::impl_pwr_t)
  ) {{ pad.instance_name }} (
    {% if pad.direction.value in ["output", "inout"] -%}
    .i_oup      ({{ pad.name_sanitized }}_oup),
    .i_oup_en   ({{ pad.name_sanitized }}_oup_en),
    {% endif -%}
    {% if pad.direction.value in ["input", "inout"] -%}
    .o_inp      ({{ pad.name_sanitized }}_inp),
    .i_inp_en   ({{ pad.name_sanitized }}_inp_en),
    {% endif -%}
    .i_pull_type({{ pad.name_sanitized }}_pull_type),
    .i_pull_en  ({{ pad.name_sanitized }}_pull_en),
    .i_impl     ({{ pad.name_sanitized }}_impl_inp),
    .o_impl     ({{ pad.name_sanitized }}_impl_oup),
    .i_impl_pwr (impl_power[{{ pad.row_index }}]),
    {%- if pad.direction.value in ["input"] %}
    .i_pad      ({{ pad.pad_signal }})
    {%- elif pad.direction.value in ["output"] %}
    .o_pad      ({{ pad.pad_signal }})
    {%- else %}
    .io_pad     ({{ pad.pad_signal }})
    {%- endif %}
  );
{% endfor %}
endmodule
