// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
{ name: "mvmexe_csr",
  clocking: [{clock: "clk_i", reset: "rst_ni"}],
  bus_interfaces: [
    { protocol: "tlul", direction: "device" }
  ],
  regwidth: "64",
  addrcap: "0x10000",
  axi_intf: True
  param_list : [
    {name:"AXI_AW", type:"int", default:"28"},
    {name:"AXI_IDW", type:"int", default:"9"},
    {name:"AXI_LENW", type:"int", default:"8"}
  ]
  registers: [
    { name: "CMDBLK_CTRL",
      desc: "Control register of the CMD Block.",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
            bits: "0",
            name: "EXEC_EN",
            desc: '''
                  While `EXEC_EN` is high, the block processes commands, that are pushed into the command FIFO.
                  ''',
            resval: 0x0
        }
        {
            bits: "1",
            name: "PTR_RST",
            desc: '''
                  Synchronous active-high reset of the command FIFO's input word pointer.
                  Set and unset `PTR_RST` to reset `CMDBLK_STATUS.IN_WORD_PTR` to 0. Only use this for error recovery.
                  ''',
            resval: 0x0
        }
      ]
    },
    { name: "CMDBLK_STATUS",
      desc: "Status register of the CMD Block.",
      swaccess: "ro",
      hwaccess: "hwo",
      hwext : True
      fields: [
        {
            bits: "1:0",
            name: "STATE",
            desc: '''
                  0: `IDLE` Command FIFO and fill buffer are both empty.
                  1: `FILL` Command FIFO is empty, but there is at least a header in the fill buffer
                  2: `READY` Command FIFO contains at least one item
                  3: `EXECUTE` Outstanding commands is at least 1
                  '''
        }
        {
            bits: "2",
            name: "WAIT_TOKEN",
            desc: '''
                  `WAIT_TOKEN` is high iff a command is waiting at the output buffer of the command FIFO for a token to arrive.
                  '''
        }
        {
            bits: "15:8",
            name: "IN_WORD_PTR",
            desc: '''
                  The input word pointer is used to construct the input data for the command FIFO and
                  points to the next 64bit word of the input data to be received by the next AXI transaction.
                  '''
        }
        {
            bits: "23:16",
            name: "FIFO_CNT",
            desc: '''Fill counter of the command FIFO.'''
        }
        {
            bits: "31:24",
            name: "OUTST_CMDS",
            desc: '''
                  Number of outstanding commands.
                  A command is outstanding iff it has been popped from the command FIFO and sent for execution,
                  but the datapath has not yet signaled that its execution has been done.
                  '''
        }
        {
            bits: "47:32",
            name: "PENDING_TOKENS",
            desc: '''
                  Signals which consume tokens are pending.
                  '''
        }
      ]
    },
    {
      name: "IRQ_EN",
      desc: "Interrupt enable register",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        { bits: "0",
          name: "ERR_IFD0_DPCMD_UNALIGNED_TLAST",
          desc: '''
                Enable IRQ flagging of unaligned tlast between IFD0 and EXE DPCMD.
                '''
        }
        { bits: "1",
          name: "ERR_IFDW_DPCMD_UNALIGNED_TLAST",
          desc: '''
                Enable IRQ flagging of unaligned tlast between IFDW and PRG DPCMD.
                '''
        }
        { bits: "2",
          name: "ERR_BYPASS_WHEN_DP_NOT_IDLE",
          desc: '''
                Enable IRQ flagging of DP Bypass when DP not idle.
                '''
        }
        { bits: "3",
          name: "ERR_CONCURRENT_EXE_PRG_ON_WS",
          desc: '''
                Enable IRQ flagging of concurrent exe and prg on the same weight set.
                '''
        }
        { bits: "4",
          name: "ERR_EXE_INP_OFFSET_SIZE_OVERFLOW"
          desc: '''
                Enable IRQ flagging of overflowing offset and size combinations for EXE input
                '''
          resval: 0x1
        }
        { bits: "5",
          name: "ERR_EXE_OUP_OFFSET_SIZE_OVERFLOW"
          desc: '''
                Enable IRQ flagging of overflowing offset and size combinations for EXE output
                '''
          resval: 0x1
        }
        { bits: "6",
          name: "ERR_PRG_ROW_OFFSET_SIZE_OVERFLOW"
          desc: '''
                Enable IRQ flagging of overflowing offset and size combinations for PRG row
                '''
          resval: 0x1
        }
        { bits: "7",
          name: "ERR_PRG_COL_OFFSET_SIZE_OVERFLOW"
          desc: '''
                Enable IRQ flagging of overflowing offset and size combinations for PRG col
                '''
          resval: 0x1
        }
        { bits: "8",
          name: "EXE_CMDBLK_CMD_DROPPED",
          desc: '''
                Enable IRQ flagging of exe command block FIFO command dropping.
                '''
          resval: 0x1
        }
        { bits: "10",
          name: "PRG_CMDBLK_CMD_DROPPED",
          desc: '''
                Enable IRQ flagging of prg command block FIFO command dropping.
                '''
          resval: 0x1
        }
        { bits: "12",
          name: "ERR_EXE_ILLEGAL_LOOP_ITER",
          desc: '''
                Enable IRQ flagging of illegal values for the loop iter field in the exe cmdblock cmd.
                '''
          resval: 0x1
        }
        { bits: "13",
          name: "ERR_EXE_ILLEGAL_LOOP_LEN",
          desc: '''
                Enable IRQ flagging of illegal values for the loop len field in the exe cmdblock cmd.
                '''
          resval: 0x1
        }
        { bits: "14",
          name: "ERR_EXE_QCMD_MEM_ADDR_OVERFLOW",
          desc: '''
                Enable IRQ flagging of qcmd mem address overflow.
                '''
        }
        { bits: "15",
          name: "ERR_EXE_ILLEGAL_CMD_OPCODE",
          desc: '''
                Enable IRQ flagging of illegal values for the opcode field in the exe cmdblock cmd.
                '''
        }
        { bits: "16",
          name: "ERR_EXE_ILLEGAL_LOOP_START",
          desc: '''
                Enable IRQ flagging of illegal values for the loop start field in the exe cmdblock cmd.
                '''
        }
        { bits: "17",
          name: "ERR_PRG_ILLEGAL_CMD_OPCODE",
          desc: '''
                Enable IRQ flagging of illegal values for the opcode field in the prg cmdblock cmd.
                '''
        }
        { bits: "18",
          name: "ERR_PRG_ILLEGAL_WEIGHT_SET",
          desc: '''
                Enable IRQ flagging of illegal values for the weight_set field in the prg cmdblock cmd.
                '''
        }
        { bits: "32",
          name: "DBG_SW_INTERRUPT",
          desc: '''
                Enable IRQ flagging of the debug SW interrupt.
                '''
        }
        { bits: "33",
          name: "ERR_NOT_ENOUGH_BUDGET",
          desc: '''
                Enable IRQ flagging the clip budget of ramp up is not enough to process the input vector.
                '''
        }
        { bits: "34",
          name: "WARNING_UTIL_LIMIT_TRIGGER_NOP",
          desc: '''
                Enable IRQ flagging the Util Limiter triiger a NOP.
                '''
        }
      ]
    },
    {
      name: "IRQ_STATUS",
      desc: "Interrupt status register",
      swaccess: "rw1c",
      hwaccess: "hrw"
      fields: [
        { bits: "0",
          name: "ERR_IFD0_DPCMD_UNALIGNED_TLAST",
          desc: '''
                IFD0 and EXE DPCMD AXI stream have an unaligned TLAST flag.
                '''
        }
        { bits: "1",
          name: "ERR_IFDW_DPCMD_UNALIGNED_TLAST",
          desc: '''
                IFD0 and PRG DPCMD AXI stream have an unaligned TLAST flag.
                '''
        }
        { bits: "2",
          name: "ERR_BYPASS_WHEN_DP_NOT_IDLE",
          desc: '''
                MVM Datapath bypass feature was enabled while the DP contained one or more active transactions.
                '''
        }
        { bits: "3",
          name: "ERR_CONCURRENT_EXE_PRG_ON_WS",
          desc: '''
                EXE and PRG concurrently access the same weight set. This leads to corrupted outputs and stored weights.
                '''
        }
        { bits: "4",
          name: "ERR_EXE_INP_OFFSET_SIZE_OVERFLOW"
          desc: '''
                EXE input offset and input size add up to a value larger than NR_INPUT_PWs which causes an unsupported overflow
                '''
        }
        { bits: "5",
          name: "ERR_EXE_OUP_OFFSET_SIZE_OVERFLOW"
          desc: '''
                EXE output offset and output size add up to a value larger than NR_OUTPUT_PWs which causes an unsupported overflow
                '''
        }
        { bits: "6",
          name: "ERR_PRG_ROW_OFFSET_SIZE_OVERFLOW"
          desc: '''
                PRG row offset and row size add up to a value larger than NR_INPUT_PWs which causes an unsupported overflow
                '''
        }
        { bits: "7",
          name: "ERR_PRG_COL_OFFSET_SIZE_OVERFLOW"
          desc: '''
                PRG col offset and col size add up to a value larger than NR_OUTPUT_PWs which causes an unsupported overflow
                '''
        }
        { bits: "8",
          name: "EXE_CMDBLK_CMD_DROPPED",
          desc: '''
                The exe command block FIFO had to drop at least one command because the FIFO was already full.
                '''
        }
        { bits: "10",
          name: "PRG_CMDBLK_CMD_DROPPED",
          desc: '''
                The prg command block FIFO had to drop at least one command because the FIFO was already full.
                '''
        }
        { bits: "12",
          name: "ERR_EXE_ILLEGAL_LOOP_ITER",
          desc: '''
                The loop iter value received from the cmdblock cmd is illegal (equal to 0)
                '''
        }
        { bits: "13",
          name: "ERR_EXE_ILLEGAL_LOOP_LEN",
          desc: '''
                The loop len value received from the cmdblock cmd is illegal (equal to 0)
                '''
        }
        { bits: "14",
          name: "ERR_EXE_QCMD_MEM_ADDR_OVERFLOW",
          desc: '''
                The computed qcmd_mem_addr exceeds the qcmd_depth (it max value = qcmd_len + qcmd_ptr). Access to qcmd_mem will wrap.
                '''
        }
        { bits: "15",
          name: "ERR_EXE_ILLEGAL_CMD_OPCODE",
          desc: '''
                The received cmd opcode from the exe cmdblock cmd is illegal, only 0 or 1 are supported for triton alpha. This is not fatal. As the internal opcode is only 1b, the lsb of given opcode is used.
                '''
        }
        { bits: "16",
          name: "ERR_EXE_ILLEGAL_LOOP_START",
          desc: '''
                The received loop start from the exe cmdblock cmd exceeds the qcmd_depth. Access to qcmd_mem will wrap.
                '''
        }
        { bits: "17",
          name: "ERR_PRG_ILLEGAL_CMD_OPCODE",
          desc: '''
                The received cmd opcode from the prg cmdblock cmd is illegal, only 0 is supported for triton alpha. As the internal opcode is only 1b, the lsb of given opcode is used. If this bit is 0, this is not fatal, else the operation becomes a nop.
                '''
        }
        { bits: "18",
          name: "ERR_PRG_ILLEGAL_WEIGHT_SET",
          desc: '''
                The received weight_set from the prg cmdblock cmd exceeds the number of weight sets in the imc banks. This is not fatal, only the lower 2 bits of the field are used.
                '''
        }
        { bits: "32",
          name: "DBG_SW_INTERRUPT",
          desc: '''
                SW triggered the debug interrupt by setting the `DP_CTRL.DBG_SW_IRQ` to high.
                '''
        }
        { bits: "33",
          name: "ERR_NOT_ENOUGH_BUDGET",
          desc: '''
                The clip budget of ramp up is not enough to process the input vector.
                '''
        }
        { bits: "34",
          name: "WARNING_UTIL_LIMIT_TRIGGER_NOP",
          desc: '''
                The Util Limiter triiger a NOP.
                '''
        }
      ]
    },
    { name: "DP_CTRL",
      desc: "Control register of the datapath.",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
            bits: "0",
            name: "SIGNED_INPUTS",
            desc: '''
              When set to 0, configure MVM DP to treat input data values (source: IFD0) as unsigned.
              When set to 1 (Default), configure MVM DP to treat input data values (source: IFD0) as signed.
            '''
            resval: 0x1
        }
        {
            bits: "3:1",
            name: "IMC_TEST_MODE",
            desc: '''Set the test mode to help software DFT runs on imc_banks. Options are 0 (TM_OFF), 1 (TM0), 2 (TM1), 3 (TM2), 4 (TM3).'''
            resval: 0x0
        }
        {
            bits: "4",
            name: "POWER_SMOOTH_DUMMY_OPS"
            desc: '''
              When set to 0 (default), imc_banks in the middle of the pipeline get their compute_gate_clock bit set when they are not used. Depending on the pipelines input pattern, this can lead to 2 imc_banks going on/off in the same cycle instead of only 1.
              When set to 1, imc_banks in the middle of the pipeline that are not used will still do a dummy computation to keep the overall power consumption as smooth as possible. This guarantees that only 1 imc_bank in the pipeline can turn on/off per cycle at the cost of some power waste.
            '''
            resval: 0x0
        }
        {
            bits: "5",
            name: "DISABLE_IMC_ACC_CLOCK_GATING"
            desc: '''
              When set to 0 (default), clock gating the imc and acc when they are idle is enabled.
              When set to 1, clock gating the imc and acc when they are idle is disabled. Note a small delay buffer remains clock gated as this is functionally required to implement backpressure.
            '''
            resval: 0x0
        }
        {
            bits: "32",
            name: "DBG_SW_IRQ",
            desc: '''
                  `DBG_SW_IRQ` is a level-triggered interrupt request.
                  Set `DBG_SW_IRQ` to high to trigger the debug SW interrupt.
                  Interrupt handler must set `DBG_SW_IRQ` to low again.
                  '''
            resval: 0x0
        }
      ]
    },
    { name: "DP_STATUS",
      desc: "Datapath status observarion register.",
      swaccess: "ro",
      hwaccess: "hwo",
      hwext : True
      fields: [
        {
            bits: "0",
            name: "IN0_VLD",
            desc: '''Valid signal of the IFD0 input AXIS stream after input FIFO / buffer (if present).'''
        }
        {
            bits: "1",
            name: "IN0_RDY",
            desc: '''Ready signal of the IFD0 input AXIS stream after input FIFO / buffer (if present).'''
        }
        {
            bits: "2",
            name: "IN0_LST",
            desc: '''Last signal of the IFD0 input AXIS stream after input FIFO / buffer (if present).'''
        }
        {
            bits: "3",
            name: "IN0_STL",
            desc: '''Indicates a stall on the IFD0 input AXIS stream after input FIFO / buffer (if present).'''
        }
        // {
        //     bits: "4",
        //     name: "IN1_VLD",
        //     desc: '''Valid signal of the IFDW input AXIS stream after input FIFO / buffer (if present).'''
        // }
        // {
        //     bits: "5",
        //     name: "IN1_RDY",
        //     desc: '''Ready signal of the IFDW input AXIS stream after input FIFO / buffer (if present).'''
        // }
        // {
        //     bits: "6",
        //     name: "IN1_LST",
        //     desc: '''Last signal of the IFDW input AXIS stream after input FIFO / buffer (if present).'''
        // }
        // {
        //     bits: "7",
        //     name: "IN1_STL",
        //     desc: '''Indicates a stall on the IFDW input AXIS stream after input FIFO / buffer (if present).'''
        // }
        {
            bits: "8",
            name: "OUT_VLD",
            desc: '''Valid signal of the IAU output AXIS stream before output FIFO / buffer (if present).'''
        }
        {
            bits: "9",
            name: "OUT_RDY",
            desc: '''Ready signal of the IAU output AXIS stream before output FIFO / buffer (if present).'''
        }
        {
            bits: "10",
            name: "OUT_LST",
            desc: '''Last signal of the IAU output AXIS stream before output FIFO / buffer (if present).'''
        }
        {
            bits: "11",
            name: "OUT_STL",
            desc: '''Indicates a stall on the IAU output AXIS stream before output FIFO / buffer (if present).'''
        }
        {
            bits: "16",
            name: "DPCMD0_VLD",
            desc: '''Valid signal of the execution `DPcmd` AXIS stream after command FIFO / buffer (if present).'''
        }
        {
            bits: "17",
            name: "DPCMD0_RDY",
            desc: '''Ready signal of the execution `DPcmd` AXIS stream after command FIFO / buffer (if present).'''
        }
        {
            bits: "18",
            name: "DPCMD0_LST",
            desc: '''Last signal of the execution `DPcmd` AXIS stream after command FIFO / buffer (if present).'''
        }
        {
            bits: "19",
            name: "DPCMD0_STL",
            desc: '''Indicates a stall on the execution `DPcmd` AXIS stream after command FIFO / buffer (if present).'''
        }
        // {
        //     bits: "20",
        //     name: "DPCMD1_VLD",
        //     desc: '''Valid signal of the programming `DPcmd` AXIS stream after command FIFO / buffer (if present).'''
        // }
        // {
        //     bits: "21",
        //     name: "DPCMD1_RDY",
        //     desc: '''Ready signal of the programming `DPcmd` AXIS stream after command FIFO / buffer (if present).'''
        // }
        // {
        //     bits: "22",
        //     name: "DPCMD1_LST",
        //     desc: '''Last signal of the programming `DPcmd` AXIS stream after command FIFO / buffer (if present).'''
        // }
        // {
        //     bits: "23",
        //     name: "DPCMD1_STL",
        //     desc: '''Indicates a stall on the programming `DPcmd` AXIS stream after command FIFO / buffer (if present).'''
        // }
        {
            bits: "36:32",
            name: "IMC_ACC_COMPUTE_CMD",
            desc: '''Ready signal of the incoming IMC ACC block output control stream.'''
        }
        {
            bits: "41:37",
            name: "IMC_ACC_OUT_CMD",
            desc: '''IMC ACC block output command.'''
        }
        {
            bits: "42",
            name: "IMC_ACC_COMP_RDY",
            desc: '''Ready signal of the incoming IMC ACC block output control stream.'''
        }
        {
            bits: "43",
            name: "IMC_ACC_COMP_VLD",
            desc: '''Valid signal of the incoming IMC ACC block output control stream.'''
        }
        {
            bits: "44",
            name: "IMC_ACC_OUT_RDY",
            desc: '''Ready signal of the output buffer control stream.'''
        }
        {
            bits: "45",
            name: "IMC_ACC_OUT_VLD",
            desc: '''Valid signal of the output buffer control stream.'''
        }
        {
            bits: "46",
            name: "INPUT_TRANS_BUSY",
            desc: '''A value of 1 indicates that the transaction is busy.'''
        }
        {
            bits: "47",
            name: "BYPASS_EN",
            desc: '''A value of 1 indicates that bypass mode is enabled.'''
        }
      ]
    },
    { name: "DBG_OBSERVE",
      desc: "Observation register.",
      swaccess: "ro",
      hwaccess: "hwo",
      hwext : True
      fields: [
        {
            bits: "0",
            name: "IN0_VLD",
            desc: '''Valid signal of the IFD0 input AXIS stream.'''
        }
        {
            bits: "1",
            name: "IN0_RDY",
            desc: '''Ready signal of the IFD0 input AXIS stream.'''
        }
        {
            bits: "2",
            name: "IN0_LST",
            desc: '''Last signal of the IFD0 input AXIS stream.'''
        }
        //{
        //    bits: "4",
        //    name: "IN2_VLD",
        //    desc: '''Valid signal of the IFD2 input AXIS stream.'''
        //}
        //{
        //    bits: "5",
        //    name: "IN2_RDY",
        //    desc: '''Ready signal of the IFD2 input AXIS stream.'''
        //}
        //{
        //    bits: "6",
        //    name: "IN2_LST",
        //    desc: '''Last signal of the IFD2 input AXIS stream.'''
        //}
        {
            bits: "8",
            name: "OUT_VLD",
            desc: '''Valid signal of the IAU output AXIS stream.'''
        }
        {
            bits: "9",
            name: "OUT_RDY",
            desc: '''Ready signal of the IAU output AXIS stream.'''
        }
        {
            bits: "10",
            name: "OUT_LST",
            desc: '''Last signal of the IAU output AXIS stream.'''
        }
        {
            bits: "16",
            name: "DPCMD0_VLD",
            desc: '''Valid signal of the execution `DPcmd` AXIS stream after multiplexer.'''
        }
        {
            bits: "17",
            name: "DPCMD0_RDY",
            desc: '''Ready signal of the execution `DPcmd` AXIS stream after multiplexer.'''
        }
        {
            bits: "18",
            name: "DPCMD0_LST",
            desc: '''Last signal of the execution `DPcmd` AXIS stream after multiplexer.'''
        }
        // {
        //     bits: "20",
        //     name: "DPCMD1_VLD",
        //     desc: '''Valid signal of the programming `DPcmd` AXIS stream after multiplexer.'''
        // }
        // {
        //     bits: "21",
        //     name: "DPCMD1_RDY",
        //     desc: '''Ready signal of the programming `DPcmd` AXIS stream after multiplexer.'''
        // }
        // {
        //     bits: "22",
        //     name: "DPCMD1_LST",
        //     desc: '''Last signal of the programming `DPcmd` AXIS stream after multiplexer.'''
        // }
      ]
    },
    { name: "CMDGEN_STATUS",
      desc: "DP command generator observation register.",
      swaccess: "ro",
      hwaccess: "hwo",
      hwext : True
      fields: [
        {
            bits: "31:0",
            name: "ITERATION_CNT",
            desc: '''Iteration counter of the currently executed loop.'''
        }
        {
            bits: "47:32",
            name: "MEM_ADDR",
            desc: '''Current memory address value.'''
        }
        {
            bits: "50:48",
            name: "FSM_STATE",
            desc: '''Command generator FSM state.'''
        }
        {
            bits: "51",
            name: "QCMD_MEM_RDY",
            desc: '''Program memory ready signal.'''
        }
        {
            bits: "59:52",
            name: "LOOP_LEN_CNT",
            desc: '''Loop length counter.'''
        }
        {
            bits: "63:60",
            name: "DP_CMDS_CNT",
            desc: '''DP command counter.'''
        }
      ]
    },
    { name: "DBG_SCRATCH",
      desc: "Scratch register only accessible through SW for debugging purposes.",
      swaccess: "rw",
      hwaccess: "none"
      fields: [
        {
            bits: "63:0",
            name: "SCRATCH",
            desc: '''Scratch register field.''',
            resval: 0x0
        }
      ]
    },
    { name: "DBG_ID",
      desc: "Block identification register.",
      swaccess: "ro",
      hwaccess: "hwo",
      hwext : True
      fields: [
        {
            bits: "7:0",
            name: "BLOCK_ID",
            desc: '''Unique identifier of an `AI Core` block. Note, that the same blocks in each `AI Core` instance share the same `BLOCK_ID`.'''
        }
        {
            bits: "15:8",
            name: "AI_CORE_ID",
            desc: '''`AI_CORE_ID` aka `CID` is a unique identifier of the `AI Core` instance.'''
        }
        {
            bits: "23:16",
            name: "HW_REVISION",
            desc: '''Major hardware revision number.'''
        }
      ]
    },
    { name: "HW_CAPABILITY",
      desc: "Hardware capability register for the instance.",
      swaccess: "ro",
      hwaccess: "hwo",
      hwext : True
      fields: [
        {
            bits: "7:0",
            name: "CMD_FIFO_DEPTH",
            desc: '''Depth of the command FIFO in the CMD block.'''
        }
        {
             bits: "31:16",
             name: "INSTR_MEM_DEPTH",
             desc: '''Depth of the instruction memory in the `DPcmdgen` block, measured in number of instructions.'''
        }
        // {
        //      bits: "32",
        //      name: "STATIC_CMD_PRESENT",
        //      desc: '''If set to high, the static part of the command block is present.'''
        // }
        // {
        //     bits: "33",
        //     name: "VTRSP_PRESENT",
        //     desc: '''If set to high, the VTRSP block is present in the instance'''
        // }
      ]
    }
  ]
}
