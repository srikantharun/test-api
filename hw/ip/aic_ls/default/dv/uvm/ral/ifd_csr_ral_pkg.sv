// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package ifd_csr_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class ifd_csr_reg_cmdblk_ctrl;
  typedef class ifd_csr_reg_cmdblk_status;
  typedef class ifd_csr_reg_irq_en;
  typedef class ifd_csr_reg_irq_status;
  typedef class ifd_csr_reg_swdp_ctrl;
  typedef class ifd_csr_reg_swdp_status;
  typedef class ifd_csr_reg_dp_ctrl;
  typedef class ifd_csr_reg_dp_status;
  typedef class ifd_csr_reg_dbg_observe;
  typedef class ifd_csr_reg_cmdgen_status;
  typedef class ifd_csr_reg_dbg_scratch;
  typedef class ifd_csr_reg_dbg_id;
  typedef class ifd_csr_reg_hw_capability;
  typedef class ifd_csr_reg_block;

  class ifd_csr_reg_cmdblk_ctrl extends dv_base_reg;
    // fields
    rand dv_base_reg_field exec_en;
    rand dv_base_reg_field ptr_rst;

    `uvm_object_utils(ifd_csr_reg_cmdblk_ctrl)

    function new(string       name = "ifd_csr_reg_cmdblk_ctrl",
                 int unsigned n_bits = 64,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      // create fields
      exec_en = (dv_base_reg_field::
                 type_id::create("exec_en"));
      exec_en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      exec_en.set_original_access("RW");

      ptr_rst = (dv_base_reg_field::
                 type_id::create("ptr_rst"));
      ptr_rst.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ptr_rst.set_original_access("RW");

    endfunction : build
  endclass : ifd_csr_reg_cmdblk_ctrl

  class ifd_csr_reg_cmdblk_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field idle;
    rand dv_base_reg_field busy;
    rand dv_base_reg_field wait_token;
    rand dv_base_reg_field in_word_ptr;
    rand dv_base_reg_field fifo_cnt;
    rand dv_base_reg_field outst_cmds;

    `uvm_object_utils(ifd_csr_reg_cmdblk_status)

    function new(string       name = "ifd_csr_reg_cmdblk_status",
                 int unsigned n_bits = 64,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      // create fields
      idle = (dv_base_reg_field::
              type_id::create("idle"));
      idle.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      idle.set_original_access("RO");

      busy = (dv_base_reg_field::
              type_id::create("busy"));
      busy.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      busy.set_original_access("RO");

      wait_token = (dv_base_reg_field::
                    type_id::create("wait_token"));
      wait_token.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      wait_token.set_original_access("RO");

      in_word_ptr = (dv_base_reg_field::
                     type_id::create("in_word_ptr"));
      in_word_ptr.configure(
        .parent(this),
        .size(8),
        .lsb_pos(8),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      in_word_ptr.set_original_access("RO");

      fifo_cnt = (dv_base_reg_field::
                  type_id::create("fifo_cnt"));
      fifo_cnt.configure(
        .parent(this),
        .size(8),
        .lsb_pos(16),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fifo_cnt.set_original_access("RO");

      outst_cmds = (dv_base_reg_field::
                    type_id::create("outst_cmds"));
      outst_cmds.configure(
        .parent(this),
        .size(8),
        .lsb_pos(24),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      outst_cmds.set_original_access("RO");

      set_is_ext_reg(1);
    endfunction : build
  endclass : ifd_csr_reg_cmdblk_status

  class ifd_csr_reg_irq_en extends dv_base_reg;
    // fields
    rand dv_base_reg_field err_addr_out_of_range;
    rand dv_base_reg_field err_mmio_error;
    rand dv_base_reg_field cmdblk_cmd_dropped;
    rand dv_base_reg_field swdp_cmd_dropped;
    rand dv_base_reg_field dp_decomp_access_error;
    rand dv_base_reg_field decomp_invalid_stream_header;
    rand dv_base_reg_field decomp_invalid_scheme_header;
    rand dv_base_reg_field decomp_invalid_compressed_size;
    rand dv_base_reg_field decomp_invalid_uncompressed_size;
    rand dv_base_reg_field dbg_sw_interrupt;

    `uvm_object_utils(ifd_csr_reg_irq_en)

    function new(string       name = "ifd_csr_reg_irq_en",
                 int unsigned n_bits = 64,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      // create fields
      err_addr_out_of_range = (dv_base_reg_field::
                               type_id::create("err_addr_out_of_range"));
      err_addr_out_of_range.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      err_addr_out_of_range.set_original_access("RW");

      err_mmio_error = (dv_base_reg_field::
                        type_id::create("err_mmio_error"));
      err_mmio_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      err_mmio_error.set_original_access("RW");

      cmdblk_cmd_dropped = (dv_base_reg_field::
                            type_id::create("cmdblk_cmd_dropped"));
      cmdblk_cmd_dropped.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RW"),
        .volatile(0),
        .reset(64'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmdblk_cmd_dropped.set_original_access("RW");

      swdp_cmd_dropped = (dv_base_reg_field::
                          type_id::create("swdp_cmd_dropped"));
      swdp_cmd_dropped.configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("RW"),
        .volatile(0),
        .reset(64'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      swdp_cmd_dropped.set_original_access("RW");

      dp_decomp_access_error = (dv_base_reg_field::
                                type_id::create("dp_decomp_access_error"));
      dp_decomp_access_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(16),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dp_decomp_access_error.set_original_access("RW");

      decomp_invalid_stream_header = (dv_base_reg_field::
                                      type_id::create("decomp_invalid_stream_header"));
      decomp_invalid_stream_header.configure(
        .parent(this),
        .size(1),
        .lsb_pos(17),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      decomp_invalid_stream_header.set_original_access("RW");

      decomp_invalid_scheme_header = (dv_base_reg_field::
                                      type_id::create("decomp_invalid_scheme_header"));
      decomp_invalid_scheme_header.configure(
        .parent(this),
        .size(1),
        .lsb_pos(18),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      decomp_invalid_scheme_header.set_original_access("RW");

      decomp_invalid_compressed_size = (dv_base_reg_field::
                                        type_id::create("decomp_invalid_compressed_size"));
      decomp_invalid_compressed_size.configure(
        .parent(this),
        .size(1),
        .lsb_pos(19),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      decomp_invalid_compressed_size.set_original_access("RW");

      decomp_invalid_uncompressed_size = (dv_base_reg_field::
                                          type_id::create("decomp_invalid_uncompressed_size"));
      decomp_invalid_uncompressed_size.configure(
        .parent(this),
        .size(1),
        .lsb_pos(20),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      decomp_invalid_uncompressed_size.set_original_access("RW");

      dbg_sw_interrupt = (dv_base_reg_field::
                          type_id::create("dbg_sw_interrupt"));
      dbg_sw_interrupt.configure(
        .parent(this),
        .size(1),
        .lsb_pos(32),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dbg_sw_interrupt.set_original_access("RW");

    endfunction : build
  endclass : ifd_csr_reg_irq_en

  class ifd_csr_reg_irq_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field err_addr_out_of_range;
    rand dv_base_reg_field err_mmio_error;
    rand dv_base_reg_field cmdblk_cmd_dropped;
    rand dv_base_reg_field swdp_cmd_dropped;
    rand dv_base_reg_field dp_decomp_access_error;
    rand dv_base_reg_field decomp_invalid_stream_header;
    rand dv_base_reg_field decomp_invalid_scheme_header;
    rand dv_base_reg_field decomp_invalid_compressed_size;
    rand dv_base_reg_field decomp_invalid_uncompressed_size;
    rand dv_base_reg_field dbg_sw_interrupt;

    `uvm_object_utils(ifd_csr_reg_irq_status)

    function new(string       name = "ifd_csr_reg_irq_status",
                 int unsigned n_bits = 64,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      // create fields
      err_addr_out_of_range = (dv_base_reg_field::
                               type_id::create("err_addr_out_of_range"));
      err_addr_out_of_range.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W1C"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      err_addr_out_of_range.set_original_access("W1C");

      err_mmio_error = (dv_base_reg_field::
                        type_id::create("err_mmio_error"));
      err_mmio_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("W1C"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      err_mmio_error.set_original_access("W1C");

      cmdblk_cmd_dropped = (dv_base_reg_field::
                            type_id::create("cmdblk_cmd_dropped"));
      cmdblk_cmd_dropped.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("W1C"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmdblk_cmd_dropped.set_original_access("W1C");

      swdp_cmd_dropped = (dv_base_reg_field::
                          type_id::create("swdp_cmd_dropped"));
      swdp_cmd_dropped.configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("W1C"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      swdp_cmd_dropped.set_original_access("W1C");

      dp_decomp_access_error = (dv_base_reg_field::
                                type_id::create("dp_decomp_access_error"));
      dp_decomp_access_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(16),
        .access("W1C"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dp_decomp_access_error.set_original_access("W1C");

      decomp_invalid_stream_header = (dv_base_reg_field::
                                      type_id::create("decomp_invalid_stream_header"));
      decomp_invalid_stream_header.configure(
        .parent(this),
        .size(1),
        .lsb_pos(17),
        .access("W1C"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      decomp_invalid_stream_header.set_original_access("W1C");

      decomp_invalid_scheme_header = (dv_base_reg_field::
                                      type_id::create("decomp_invalid_scheme_header"));
      decomp_invalid_scheme_header.configure(
        .parent(this),
        .size(1),
        .lsb_pos(18),
        .access("W1C"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      decomp_invalid_scheme_header.set_original_access("W1C");

      decomp_invalid_compressed_size = (dv_base_reg_field::
                                        type_id::create("decomp_invalid_compressed_size"));
      decomp_invalid_compressed_size.configure(
        .parent(this),
        .size(1),
        .lsb_pos(19),
        .access("W1C"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      decomp_invalid_compressed_size.set_original_access("W1C");

      decomp_invalid_uncompressed_size = (dv_base_reg_field::
                                          type_id::create("decomp_invalid_uncompressed_size"));
      decomp_invalid_uncompressed_size.configure(
        .parent(this),
        .size(1),
        .lsb_pos(20),
        .access("W1C"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      decomp_invalid_uncompressed_size.set_original_access("W1C");

      dbg_sw_interrupt = (dv_base_reg_field::
                          type_id::create("dbg_sw_interrupt"));
      dbg_sw_interrupt.configure(
        .parent(this),
        .size(1),
        .lsb_pos(32),
        .access("W1C"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dbg_sw_interrupt.set_original_access("W1C");

    endfunction : build
  endclass : ifd_csr_reg_irq_status

  class ifd_csr_reg_swdp_ctrl extends dv_base_reg;
    // fields
    rand dv_base_reg_field exec_en;
    rand dv_base_reg_field ptr_rst;
    rand dv_base_reg_field sw_byp_en;

    `uvm_object_utils(ifd_csr_reg_swdp_ctrl)

    function new(string       name = "ifd_csr_reg_swdp_ctrl",
                 int unsigned n_bits = 64,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      // create fields
      exec_en = (dv_base_reg_field::
                 type_id::create("exec_en"));
      exec_en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      exec_en.set_original_access("RW");

      ptr_rst = (dv_base_reg_field::
                 type_id::create("ptr_rst"));
      ptr_rst.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ptr_rst.set_original_access("RW");

      sw_byp_en = (dv_base_reg_field::
                   type_id::create("sw_byp_en"));
      sw_byp_en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sw_byp_en.set_original_access("RW");

    endfunction : build
  endclass : ifd_csr_reg_swdp_ctrl

  class ifd_csr_reg_swdp_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field in_word_ptr;
    rand dv_base_reg_field fifo_cnt;

    `uvm_object_utils(ifd_csr_reg_swdp_status)

    function new(string       name = "ifd_csr_reg_swdp_status",
                 int unsigned n_bits = 64,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      // create fields
      in_word_ptr = (dv_base_reg_field::
                     type_id::create("in_word_ptr"));
      in_word_ptr.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      in_word_ptr.set_original_access("RO");

      fifo_cnt = (dv_base_reg_field::
                  type_id::create("fifo_cnt"));
      fifo_cnt.configure(
        .parent(this),
        .size(8),
        .lsb_pos(8),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fifo_cnt.set_original_access("RO");

      set_is_ext_reg(1);
    endfunction : build
  endclass : ifd_csr_reg_swdp_status

  class ifd_csr_reg_dp_ctrl extends dv_base_reg;
    // fields
    rand dv_base_reg_field dbg_sw_irq;

    `uvm_object_utils(ifd_csr_reg_dp_ctrl)

    function new(string       name = "ifd_csr_reg_dp_ctrl",
                 int unsigned n_bits = 64,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      // create fields
      dbg_sw_irq = (dv_base_reg_field::
                    type_id::create("dbg_sw_irq"));
      dbg_sw_irq.configure(
        .parent(this),
        .size(1),
        .lsb_pos(32),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dbg_sw_irq.set_original_access("RW");

    endfunction : build
  endclass : ifd_csr_reg_dp_ctrl

  class ifd_csr_reg_dp_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field out_vld;
    rand dv_base_reg_field out_rdy;
    rand dv_base_reg_field out_lst;
    rand dv_base_reg_field out_stl;
    rand dv_base_reg_field dpcmd0_vld;
    rand dv_base_reg_field dpcmd0_rdy;
    rand dv_base_reg_field dpcmd0_lst;
    rand dv_base_reg_field dpcmd0_stl;
    rand dv_base_reg_field mm_req_vld;
    rand dv_base_reg_field mm_req_rdy;
    rand dv_base_reg_field mm_resp_ack;
    rand dv_base_reg_field decomp_stream_done;
    rand dv_base_reg_field decomp_scheme_done;
    rand dv_base_reg_field decomp_scheme;
    rand dv_base_reg_field decomp_fsm_state;

    `uvm_object_utils(ifd_csr_reg_dp_status)

    function new(string       name = "ifd_csr_reg_dp_status",
                 int unsigned n_bits = 64,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      // create fields
      out_vld = (dv_base_reg_field::
                 type_id::create("out_vld"));
      out_vld.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      out_vld.set_original_access("RO");

      out_rdy = (dv_base_reg_field::
                 type_id::create("out_rdy"));
      out_rdy.configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      out_rdy.set_original_access("RO");

      out_lst = (dv_base_reg_field::
                 type_id::create("out_lst"));
      out_lst.configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      out_lst.set_original_access("RO");

      out_stl = (dv_base_reg_field::
                 type_id::create("out_stl"));
      out_stl.configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      out_stl.set_original_access("RO");

      dpcmd0_vld = (dv_base_reg_field::
                    type_id::create("dpcmd0_vld"));
      dpcmd0_vld.configure(
        .parent(this),
        .size(1),
        .lsb_pos(16),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dpcmd0_vld.set_original_access("RO");

      dpcmd0_rdy = (dv_base_reg_field::
                    type_id::create("dpcmd0_rdy"));
      dpcmd0_rdy.configure(
        .parent(this),
        .size(1),
        .lsb_pos(17),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dpcmd0_rdy.set_original_access("RO");

      dpcmd0_lst = (dv_base_reg_field::
                    type_id::create("dpcmd0_lst"));
      dpcmd0_lst.configure(
        .parent(this),
        .size(1),
        .lsb_pos(18),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dpcmd0_lst.set_original_access("RO");

      dpcmd0_stl = (dv_base_reg_field::
                    type_id::create("dpcmd0_stl"));
      dpcmd0_stl.configure(
        .parent(this),
        .size(1),
        .lsb_pos(19),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dpcmd0_stl.set_original_access("RO");

      mm_req_vld = (dv_base_reg_field::
                    type_id::create("mm_req_vld"));
      mm_req_vld.configure(
        .parent(this),
        .size(1),
        .lsb_pos(32),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mm_req_vld.set_original_access("RO");

      mm_req_rdy = (dv_base_reg_field::
                    type_id::create("mm_req_rdy"));
      mm_req_rdy.configure(
        .parent(this),
        .size(1),
        .lsb_pos(33),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mm_req_rdy.set_original_access("RO");

      mm_resp_ack = (dv_base_reg_field::
                     type_id::create("mm_resp_ack"));
      mm_resp_ack.configure(
        .parent(this),
        .size(1),
        .lsb_pos(34),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mm_resp_ack.set_original_access("RO");

      decomp_stream_done = (dv_base_reg_field::
                            type_id::create("decomp_stream_done"));
      decomp_stream_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(48),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      decomp_stream_done.set_original_access("RO");

      decomp_scheme_done = (dv_base_reg_field::
                            type_id::create("decomp_scheme_done"));
      decomp_scheme_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(49),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      decomp_scheme_done.set_original_access("RO");

      decomp_scheme = (dv_base_reg_field::
                       type_id::create("decomp_scheme"));
      decomp_scheme.configure(
        .parent(this),
        .size(2),
        .lsb_pos(50),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      decomp_scheme.set_original_access("RO");

      decomp_fsm_state = (dv_base_reg_field::
                          type_id::create("decomp_fsm_state"));
      decomp_fsm_state.configure(
        .parent(this),
        .size(4),
        .lsb_pos(52),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      decomp_fsm_state.set_original_access("RO");

      set_is_ext_reg(1);
    endfunction : build
  endclass : ifd_csr_reg_dp_status

  class ifd_csr_reg_dbg_observe extends dv_base_reg;
    // fields
    rand dv_base_reg_field out_vld;
    rand dv_base_reg_field out_rdy;
    rand dv_base_reg_field out_lst;
    rand dv_base_reg_field dpcmd0_vld;
    rand dv_base_reg_field dpcmd0_rdy;
    rand dv_base_reg_field dpcmd0_lst;

    `uvm_object_utils(ifd_csr_reg_dbg_observe)

    function new(string       name = "ifd_csr_reg_dbg_observe",
                 int unsigned n_bits = 64,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      // create fields
      out_vld = (dv_base_reg_field::
                 type_id::create("out_vld"));
      out_vld.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      out_vld.set_original_access("RO");

      out_rdy = (dv_base_reg_field::
                 type_id::create("out_rdy"));
      out_rdy.configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      out_rdy.set_original_access("RO");

      out_lst = (dv_base_reg_field::
                 type_id::create("out_lst"));
      out_lst.configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      out_lst.set_original_access("RO");

      dpcmd0_vld = (dv_base_reg_field::
                    type_id::create("dpcmd0_vld"));
      dpcmd0_vld.configure(
        .parent(this),
        .size(1),
        .lsb_pos(16),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dpcmd0_vld.set_original_access("RO");

      dpcmd0_rdy = (dv_base_reg_field::
                    type_id::create("dpcmd0_rdy"));
      dpcmd0_rdy.configure(
        .parent(this),
        .size(1),
        .lsb_pos(17),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dpcmd0_rdy.set_original_access("RO");

      dpcmd0_lst = (dv_base_reg_field::
                    type_id::create("dpcmd0_lst"));
      dpcmd0_lst.configure(
        .parent(this),
        .size(1),
        .lsb_pos(18),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dpcmd0_lst.set_original_access("RO");

      set_is_ext_reg(1);
    endfunction : build
  endclass : ifd_csr_reg_dbg_observe

  class ifd_csr_reg_cmdgen_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field fsm_state;
    rand dv_base_reg_field instr_stalled;
    rand dv_base_reg_field out_a_zero;
    rand dv_base_reg_field out_b_zero;
    rand dv_base_reg_field out_c_zero;
    rand dv_base_reg_field out_d_zero;
    rand dv_base_reg_field inner_a_zero;
    rand dv_base_reg_field inner_b_zero;
    rand dv_base_reg_field inner_c_zero;
    rand dv_base_reg_field inner_d_zero;

    `uvm_object_utils(ifd_csr_reg_cmdgen_status)

    function new(string       name = "ifd_csr_reg_cmdgen_status",
                 int unsigned n_bits = 64,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      // create fields
      fsm_state = (dv_base_reg_field::
                   type_id::create("fsm_state"));
      fsm_state.configure(
        .parent(this),
        .size(2),
        .lsb_pos(48),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fsm_state.set_original_access("RO");

      instr_stalled = (dv_base_reg_field::
                       type_id::create("instr_stalled"));
      instr_stalled.configure(
        .parent(this),
        .size(1),
        .lsb_pos(50),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      instr_stalled.set_original_access("RO");

      out_a_zero = (dv_base_reg_field::
                    type_id::create("out_a_zero"));
      out_a_zero.configure(
        .parent(this),
        .size(1),
        .lsb_pos(51),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      out_a_zero.set_original_access("RO");

      out_b_zero = (dv_base_reg_field::
                    type_id::create("out_b_zero"));
      out_b_zero.configure(
        .parent(this),
        .size(1),
        .lsb_pos(52),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      out_b_zero.set_original_access("RO");

      out_c_zero = (dv_base_reg_field::
                    type_id::create("out_c_zero"));
      out_c_zero.configure(
        .parent(this),
        .size(1),
        .lsb_pos(53),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      out_c_zero.set_original_access("RO");

      out_d_zero = (dv_base_reg_field::
                    type_id::create("out_d_zero"));
      out_d_zero.configure(
        .parent(this),
        .size(1),
        .lsb_pos(54),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      out_d_zero.set_original_access("RO");

      inner_a_zero = (dv_base_reg_field::
                      type_id::create("inner_a_zero"));
      inner_a_zero.configure(
        .parent(this),
        .size(1),
        .lsb_pos(55),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      inner_a_zero.set_original_access("RO");

      inner_b_zero = (dv_base_reg_field::
                      type_id::create("inner_b_zero"));
      inner_b_zero.configure(
        .parent(this),
        .size(1),
        .lsb_pos(56),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      inner_b_zero.set_original_access("RO");

      inner_c_zero = (dv_base_reg_field::
                      type_id::create("inner_c_zero"));
      inner_c_zero.configure(
        .parent(this),
        .size(1),
        .lsb_pos(57),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      inner_c_zero.set_original_access("RO");

      inner_d_zero = (dv_base_reg_field::
                      type_id::create("inner_d_zero"));
      inner_d_zero.configure(
        .parent(this),
        .size(1),
        .lsb_pos(58),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      inner_d_zero.set_original_access("RO");

      set_is_ext_reg(1);
    endfunction : build
  endclass : ifd_csr_reg_cmdgen_status

  class ifd_csr_reg_dbg_scratch extends dv_base_reg;
    // fields
    rand dv_base_reg_field scratch;

    `uvm_object_utils(ifd_csr_reg_dbg_scratch)

    function new(string       name = "ifd_csr_reg_dbg_scratch",
                 int unsigned n_bits = 64,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      // create fields
      scratch = (dv_base_reg_field::
                 type_id::create("scratch"));
      scratch.configure(
        .parent(this),
        .size(64),
        .lsb_pos(0),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      scratch.set_original_access("RW");

    endfunction : build
  endclass : ifd_csr_reg_dbg_scratch

  class ifd_csr_reg_dbg_id extends dv_base_reg;
    // fields
    rand dv_base_reg_field block_id;
    rand dv_base_reg_field ai_core_id;
    rand dv_base_reg_field hw_revision;

    `uvm_object_utils(ifd_csr_reg_dbg_id)

    function new(string       name = "ifd_csr_reg_dbg_id",
                 int unsigned n_bits = 64,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      // create fields
      block_id = (dv_base_reg_field::
                  type_id::create("block_id"));
      block_id.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      block_id.set_original_access("RO");

      ai_core_id = (dv_base_reg_field::
                    type_id::create("ai_core_id"));
      ai_core_id.configure(
        .parent(this),
        .size(8),
        .lsb_pos(8),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ai_core_id.set_original_access("RO");

      hw_revision = (dv_base_reg_field::
                     type_id::create("hw_revision"));
      hw_revision.configure(
        .parent(this),
        .size(8),
        .lsb_pos(16),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      hw_revision.set_original_access("RO");

      set_is_ext_reg(1);
    endfunction : build
  endclass : ifd_csr_reg_dbg_id

  class ifd_csr_reg_hw_capability extends dv_base_reg;
    // fields
    rand dv_base_reg_field cmd_fifo_depth;
    rand dv_base_reg_field swdp_cmd_fifo_depth;
    rand dv_base_reg_field static_cmd_present;
    rand dv_base_reg_field decomp_present;

    `uvm_object_utils(ifd_csr_reg_hw_capability)

    function new(string       name = "ifd_csr_reg_hw_capability",
                 int unsigned n_bits = 64,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      // create fields
      cmd_fifo_depth = (dv_base_reg_field::
                        type_id::create("cmd_fifo_depth"));
      cmd_fifo_depth.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmd_fifo_depth.set_original_access("RO");

      swdp_cmd_fifo_depth = (dv_base_reg_field::
                             type_id::create("swdp_cmd_fifo_depth"));
      swdp_cmd_fifo_depth.configure(
        .parent(this),
        .size(8),
        .lsb_pos(8),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      swdp_cmd_fifo_depth.set_original_access("RO");

      static_cmd_present = (dv_base_reg_field::
                            type_id::create("static_cmd_present"));
      static_cmd_present.configure(
        .parent(this),
        .size(1),
        .lsb_pos(32),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      static_cmd_present.set_original_access("RO");

      decomp_present = (dv_base_reg_field::
                        type_id::create("decomp_present"));
      decomp_present.configure(
        .parent(this),
        .size(1),
        .lsb_pos(33),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      decomp_present.set_original_access("RO");

      set_is_ext_reg(1);
    endfunction : build
  endclass : ifd_csr_reg_hw_capability

  class ifd_csr_reg_block extends dv_base_reg_block;
    // registers
    rand ifd_csr_reg_cmdblk_ctrl cmdblk_ctrl;
    rand ifd_csr_reg_cmdblk_status cmdblk_status;
    rand ifd_csr_reg_irq_en irq_en;
    rand ifd_csr_reg_irq_status irq_status;
    rand ifd_csr_reg_swdp_ctrl swdp_ctrl;
    rand ifd_csr_reg_swdp_status swdp_status;
    rand ifd_csr_reg_dp_ctrl dp_ctrl;
    rand ifd_csr_reg_dp_status dp_status;
    rand ifd_csr_reg_dbg_observe dbg_observe;
    rand ifd_csr_reg_cmdgen_status cmdgen_status;
    rand ifd_csr_reg_dbg_scratch dbg_scratch;
    rand ifd_csr_reg_dbg_id dbg_id;
    rand ifd_csr_reg_hw_capability hw_capability;

    `uvm_object_utils(ifd_csr_reg_block)

    function new(string name = "ifd_csr_reg_block",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(8),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      cmdblk_ctrl = (ifd_csr_reg_cmdblk_ctrl::
                     type_id::create("cmdblk_ctrl"));
      cmdblk_ctrl.configure(.blk_parent(this));
      cmdblk_ctrl.build(csr_excl);
      default_map.add_reg(.rg(cmdblk_ctrl),
                          .offset(64'h0),
                          .rights("RW"));
      cmdblk_ctrl.add_hdl_path_slice("u_cmdblk_ctrl_exec_en.q", 0, 1, 0);
      cmdblk_ctrl.add_hdl_path_slice("u_cmdblk_ctrl_ptr_rst.q", 1, 1, 0);

      cmdblk_status = (ifd_csr_reg_cmdblk_status::
                       type_id::create("cmdblk_status"));
      cmdblk_status.configure(.blk_parent(this));
      cmdblk_status.build(csr_excl);
      default_map.add_reg(.rg(cmdblk_status),
                          .offset(64'h8),
                          .rights("RO"));
      cmdblk_status.add_hdl_path_slice("u_cmdblk_status_idle.qs", 0, 1, 0);
      cmdblk_status.add_hdl_path_slice("u_cmdblk_status_busy.qs", 1, 1, 0);
      cmdblk_status.add_hdl_path_slice("u_cmdblk_status_wait_token.qs", 2, 1, 0);
      cmdblk_status.add_hdl_path_slice("u_cmdblk_status_in_word_ptr.qs", 8, 8, 0);
      cmdblk_status.add_hdl_path_slice("u_cmdblk_status_fifo_cnt.qs", 16, 8, 0);
      cmdblk_status.add_hdl_path_slice("u_cmdblk_status_outst_cmds.qs", 24, 8, 0);

      irq_en = (ifd_csr_reg_irq_en::
                type_id::create("irq_en"));
      irq_en.configure(.blk_parent(this));
      irq_en.build(csr_excl);
      default_map.add_reg(.rg(irq_en),
                          .offset(64'h10),
                          .rights("RW"));
      irq_en.add_hdl_path_slice("u_irq_en_err_addr_out_of_range.q", 0, 1, 0);
      irq_en.add_hdl_path_slice("u_irq_en_err_mmio_error.q", 1, 1, 0);
      irq_en.add_hdl_path_slice("u_irq_en_cmdblk_cmd_dropped.q", 8, 1, 0);
      irq_en.add_hdl_path_slice("u_irq_en_swdp_cmd_dropped.q", 9, 1, 0);
      irq_en.add_hdl_path_slice("u_irq_en_dp_decomp_access_error.q", 16, 1, 0);
      irq_en.add_hdl_path_slice("u_irq_en_decomp_invalid_stream_header.q", 17, 1, 0);
      irq_en.add_hdl_path_slice("u_irq_en_decomp_invalid_scheme_header.q", 18, 1, 0);
      irq_en.add_hdl_path_slice("u_irq_en_decomp_invalid_compressed_size.q", 19, 1, 0);
      irq_en.add_hdl_path_slice("u_irq_en_decomp_invalid_uncompressed_size.q", 20, 1, 0);
      irq_en.add_hdl_path_slice("u_irq_en_dbg_sw_interrupt.q", 32, 1, 0);

      irq_status = (ifd_csr_reg_irq_status::
                    type_id::create("irq_status"));
      irq_status.configure(.blk_parent(this));
      irq_status.build(csr_excl);
      default_map.add_reg(.rg(irq_status),
                          .offset(64'h18),
                          .rights("RW"));
      irq_status.add_hdl_path_slice("u_irq_status_err_addr_out_of_range.q", 0, 1, 0);
      irq_status.add_hdl_path_slice("u_irq_status_err_mmio_error.q", 1, 1, 0);
      irq_status.add_hdl_path_slice("u_irq_status_cmdblk_cmd_dropped.q", 8, 1, 0);
      irq_status.add_hdl_path_slice("u_irq_status_swdp_cmd_dropped.q", 9, 1, 0);
      irq_status.add_hdl_path_slice("u_irq_status_dp_decomp_access_error.q", 16, 1, 0);
      irq_status.add_hdl_path_slice("u_irq_status_decomp_invalid_stream_header.q", 17, 1, 0);
      irq_status.add_hdl_path_slice("u_irq_status_decomp_invalid_scheme_header.q", 18, 1, 0);
      irq_status.add_hdl_path_slice("u_irq_status_decomp_invalid_compressed_size.q", 19, 1, 0);
      irq_status.add_hdl_path_slice("u_irq_status_decomp_invalid_uncompressed_size.q", 20, 1, 0);
      irq_status.add_hdl_path_slice("u_irq_status_dbg_sw_interrupt.q", 32, 1, 0);

      swdp_ctrl = (ifd_csr_reg_swdp_ctrl::
                   type_id::create("swdp_ctrl"));
      swdp_ctrl.configure(.blk_parent(this));
      swdp_ctrl.build(csr_excl);
      default_map.add_reg(.rg(swdp_ctrl),
                          .offset(64'h20),
                          .rights("RW"));
      swdp_ctrl.add_hdl_path_slice("u_swdp_ctrl_exec_en.q", 0, 1, 0);
      swdp_ctrl.add_hdl_path_slice("u_swdp_ctrl_ptr_rst.q", 1, 1, 0);
      swdp_ctrl.add_hdl_path_slice("u_swdp_ctrl_sw_byp_en.q", 2, 1, 0);

      swdp_status = (ifd_csr_reg_swdp_status::
                     type_id::create("swdp_status"));
      swdp_status.configure(.blk_parent(this));
      swdp_status.build(csr_excl);
      default_map.add_reg(.rg(swdp_status),
                          .offset(64'h28),
                          .rights("RO"));
      swdp_status.add_hdl_path_slice("u_swdp_status_in_word_ptr.qs", 0, 8, 0);
      swdp_status.add_hdl_path_slice("u_swdp_status_fifo_cnt.qs", 8, 8, 0);

      dp_ctrl = (ifd_csr_reg_dp_ctrl::
                 type_id::create("dp_ctrl"));
      dp_ctrl.configure(.blk_parent(this));
      dp_ctrl.build(csr_excl);
      default_map.add_reg(.rg(dp_ctrl),
                          .offset(64'h30),
                          .rights("RW"));
      dp_ctrl.add_hdl_path_slice("u_dp_ctrl.q", 32, 1, 0);

      dp_status = (ifd_csr_reg_dp_status::
                   type_id::create("dp_status"));
      dp_status.configure(.blk_parent(this));
      dp_status.build(csr_excl);
      default_map.add_reg(.rg(dp_status),
                          .offset(64'h38),
                          .rights("RO"));
      dp_status.add_hdl_path_slice("u_dp_status_out_vld.qs", 8, 1, 0);
      dp_status.add_hdl_path_slice("u_dp_status_out_rdy.qs", 9, 1, 0);
      dp_status.add_hdl_path_slice("u_dp_status_out_lst.qs", 10, 1, 0);
      dp_status.add_hdl_path_slice("u_dp_status_out_stl.qs", 11, 1, 0);
      dp_status.add_hdl_path_slice("u_dp_status_dpcmd0_vld.qs", 16, 1, 0);
      dp_status.add_hdl_path_slice("u_dp_status_dpcmd0_rdy.qs", 17, 1, 0);
      dp_status.add_hdl_path_slice("u_dp_status_dpcmd0_lst.qs", 18, 1, 0);
      dp_status.add_hdl_path_slice("u_dp_status_dpcmd0_stl.qs", 19, 1, 0);
      dp_status.add_hdl_path_slice("u_dp_status_mm_req_vld.qs", 32, 1, 0);
      dp_status.add_hdl_path_slice("u_dp_status_mm_req_rdy.qs", 33, 1, 0);
      dp_status.add_hdl_path_slice("u_dp_status_mm_resp_ack.qs", 34, 1, 0);
      dp_status.add_hdl_path_slice("u_dp_status_decomp_stream_done.qs", 48, 1, 0);
      dp_status.add_hdl_path_slice("u_dp_status_decomp_scheme_done.qs", 49, 1, 0);
      dp_status.add_hdl_path_slice("u_dp_status_decomp_scheme.qs", 50, 2, 0);
      dp_status.add_hdl_path_slice("u_dp_status_decomp_fsm_state.qs", 52, 4, 0);

      dbg_observe = (ifd_csr_reg_dbg_observe::
                     type_id::create("dbg_observe"));
      dbg_observe.configure(.blk_parent(this));
      dbg_observe.build(csr_excl);
      default_map.add_reg(.rg(dbg_observe),
                          .offset(64'h40),
                          .rights("RO"));
      dbg_observe.add_hdl_path_slice("u_dbg_observe_out_vld.qs", 8, 1, 0);
      dbg_observe.add_hdl_path_slice("u_dbg_observe_out_rdy.qs", 9, 1, 0);
      dbg_observe.add_hdl_path_slice("u_dbg_observe_out_lst.qs", 10, 1, 0);
      dbg_observe.add_hdl_path_slice("u_dbg_observe_dpcmd0_vld.qs", 16, 1, 0);
      dbg_observe.add_hdl_path_slice("u_dbg_observe_dpcmd0_rdy.qs", 17, 1, 0);
      dbg_observe.add_hdl_path_slice("u_dbg_observe_dpcmd0_lst.qs", 18, 1, 0);

      cmdgen_status = (ifd_csr_reg_cmdgen_status::
                       type_id::create("cmdgen_status"));
      cmdgen_status.configure(.blk_parent(this));
      cmdgen_status.build(csr_excl);
      default_map.add_reg(.rg(cmdgen_status),
                          .offset(64'h48),
                          .rights("RO"));
      cmdgen_status.add_hdl_path_slice("u_cmdgen_status_fsm_state.qs", 48, 2, 0);
      cmdgen_status.add_hdl_path_slice("u_cmdgen_status_instr_stalled.qs", 50, 1, 0);
      cmdgen_status.add_hdl_path_slice("u_cmdgen_status_out_a_zero.qs", 51, 1, 0);
      cmdgen_status.add_hdl_path_slice("u_cmdgen_status_out_b_zero.qs", 52, 1, 0);
      cmdgen_status.add_hdl_path_slice("u_cmdgen_status_out_c_zero.qs", 53, 1, 0);
      cmdgen_status.add_hdl_path_slice("u_cmdgen_status_out_d_zero.qs", 54, 1, 0);
      cmdgen_status.add_hdl_path_slice("u_cmdgen_status_inner_a_zero.qs", 55, 1, 0);
      cmdgen_status.add_hdl_path_slice("u_cmdgen_status_inner_b_zero.qs", 56, 1, 0);
      cmdgen_status.add_hdl_path_slice("u_cmdgen_status_inner_c_zero.qs", 57, 1, 0);
      cmdgen_status.add_hdl_path_slice("u_cmdgen_status_inner_d_zero.qs", 58, 1, 0);

      dbg_scratch = (ifd_csr_reg_dbg_scratch::
                     type_id::create("dbg_scratch"));
      dbg_scratch.configure(.blk_parent(this));
      dbg_scratch.build(csr_excl);
      default_map.add_reg(.rg(dbg_scratch),
                          .offset(64'h50),
                          .rights("RW"));
      dbg_scratch.add_hdl_path_slice("u_dbg_scratch.q", 0, 64, 0);

      dbg_id = (ifd_csr_reg_dbg_id::
                type_id::create("dbg_id"));
      dbg_id.configure(.blk_parent(this));
      dbg_id.build(csr_excl);
      default_map.add_reg(.rg(dbg_id),
                          .offset(64'h58),
                          .rights("RO"));
      dbg_id.add_hdl_path_slice("u_dbg_id_block_id.qs", 0, 8, 0);
      dbg_id.add_hdl_path_slice("u_dbg_id_ai_core_id.qs", 8, 8, 0);
      dbg_id.add_hdl_path_slice("u_dbg_id_hw_revision.qs", 16, 8, 0);

      hw_capability = (ifd_csr_reg_hw_capability::
                       type_id::create("hw_capability"));
      hw_capability.configure(.blk_parent(this));
      hw_capability.build(csr_excl);
      default_map.add_reg(.rg(hw_capability),
                          .offset(64'h60),
                          .rights("RO"));
      hw_capability.add_hdl_path_slice("u_hw_capability_cmd_fifo_depth.qs", 0, 8, 0);
      hw_capability.add_hdl_path_slice("u_hw_capability_swdp_cmd_fifo_depth.qs", 8, 8, 0);
      hw_capability.add_hdl_path_slice("u_hw_capability_static_cmd_present.qs", 32, 1, 0);
      hw_capability.add_hdl_path_slice("u_hw_capability_decomp_present.qs", 33, 1, 0);


    endfunction : build
  endclass : ifd_csr_reg_block

endpackage

