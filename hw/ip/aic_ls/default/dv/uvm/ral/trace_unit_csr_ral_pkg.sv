// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package trace_unit_csr_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class trace_unit_csr_reg_ctrl;
  typedef class trace_unit_csr_reg_trigger_en;
  typedef class trace_unit_csr_reg_message_mode;
  typedef class trace_unit_csr_reg_entry_count;
  typedef class trace_unit_csr_reg_sw_ep_trigger;
  typedef class trace_unit_csr_reg_block;

  class trace_unit_csr_reg_ctrl extends dv_base_reg;
    // fields
    rand dv_base_reg_field enable;
    rand dv_base_reg_field mode;
    rand dv_base_reg_field cntr_prescale;
    rand dv_base_reg_field start_addr;
    rand dv_base_reg_field end_addr;

    `uvm_object_utils(trace_unit_csr_reg_ctrl)

    function new(string       name = "trace_unit_csr_reg_ctrl",
                 int unsigned n_bits = 64,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      // create fields
      enable = (dv_base_reg_field::
                type_id::create("enable"));
      enable.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable.set_original_access("RW");

      mode = (dv_base_reg_field::
              type_id::create("mode"));
      mode.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mode.set_original_access("RW");

      cntr_prescale = (dv_base_reg_field::
                       type_id::create("cntr_prescale"));
      cntr_prescale.configure(
        .parent(this),
        .size(4),
        .lsb_pos(2),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cntr_prescale.set_original_access("RW");

      start_addr = (dv_base_reg_field::
                    type_id::create("start_addr"));
      start_addr.configure(
        .parent(this),
        .size(10),
        .lsb_pos(16),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      start_addr.set_original_access("RW");

      end_addr = (dv_base_reg_field::
                  type_id::create("end_addr"));
      end_addr.configure(
        .parent(this),
        .size(10),
        .lsb_pos(32),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      end_addr.set_original_access("RW");

    endfunction : build
  endclass : trace_unit_csr_reg_ctrl

  class trace_unit_csr_reg_trigger_en extends dv_base_reg;
    // fields
    rand dv_base_reg_field sw_ep;
    rand dv_base_reg_field m_ifd0;
    rand dv_base_reg_field m_ifd1;
    rand dv_base_reg_field m_ifdw;
    rand dv_base_reg_field m_odr;
    rand dv_base_reg_field d_ifd0;
    rand dv_base_reg_field d_ifd1;
    rand dv_base_reg_field d_odr;
    rand dv_base_reg_field mvm_exe;
    rand dv_base_reg_field mvm_prg;
    rand dv_base_reg_field dwpu;
    rand dv_base_reg_field d_dpu;
    rand dv_base_reg_field d_iau;
    rand dv_base_reg_field m_dpu;
    rand dv_base_reg_field m_iau;

    `uvm_object_utils(trace_unit_csr_reg_trigger_en)

    function new(string       name = "trace_unit_csr_reg_trigger_en",
                 int unsigned n_bits = 64,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      // create fields
      sw_ep = (dv_base_reg_field::
               type_id::create("sw_ep"));
      sw_ep.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sw_ep.set_original_access("RW");

      m_ifd0 = (dv_base_reg_field::
                type_id::create("m_ifd0"));
      m_ifd0.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      m_ifd0.set_original_access("RW");

      m_ifd1 = (dv_base_reg_field::
                type_id::create("m_ifd1"));
      m_ifd1.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      m_ifd1.set_original_access("RW");

      m_ifdw = (dv_base_reg_field::
                type_id::create("m_ifdw"));
      m_ifdw.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      m_ifdw.set_original_access("RW");

      m_odr = (dv_base_reg_field::
               type_id::create("m_odr"));
      m_odr.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      m_odr.set_original_access("RW");

      d_ifd0 = (dv_base_reg_field::
                type_id::create("d_ifd0"));
      d_ifd0.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      d_ifd0.set_original_access("RW");

      d_ifd1 = (dv_base_reg_field::
                type_id::create("d_ifd1"));
      d_ifd1.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      d_ifd1.set_original_access("RW");

      d_odr = (dv_base_reg_field::
               type_id::create("d_odr"));
      d_odr.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      d_odr.set_original_access("RW");

      mvm_exe = (dv_base_reg_field::
                 type_id::create("mvm_exe"));
      mvm_exe.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mvm_exe.set_original_access("RW");

      mvm_prg = (dv_base_reg_field::
                 type_id::create("mvm_prg"));
      mvm_prg.configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mvm_prg.set_original_access("RW");

      dwpu = (dv_base_reg_field::
              type_id::create("dwpu"));
      dwpu.configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dwpu.set_original_access("RW");

      d_dpu = (dv_base_reg_field::
               type_id::create("d_dpu"));
      d_dpu.configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      d_dpu.set_original_access("RW");

      d_iau = (dv_base_reg_field::
               type_id::create("d_iau"));
      d_iau.configure(
        .parent(this),
        .size(1),
        .lsb_pos(12),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      d_iau.set_original_access("RW");

      m_dpu = (dv_base_reg_field::
               type_id::create("m_dpu"));
      m_dpu.configure(
        .parent(this),
        .size(1),
        .lsb_pos(13),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      m_dpu.set_original_access("RW");

      m_iau = (dv_base_reg_field::
               type_id::create("m_iau"));
      m_iau.configure(
        .parent(this),
        .size(1),
        .lsb_pos(14),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      m_iau.set_original_access("RW");

    endfunction : build
  endclass : trace_unit_csr_reg_trigger_en

  class trace_unit_csr_reg_message_mode extends dv_base_reg;
    // fields
    rand dv_base_reg_field sw_ep;
    rand dv_base_reg_field m_ifd0;
    rand dv_base_reg_field m_ifd1;
    rand dv_base_reg_field m_ifdw;
    rand dv_base_reg_field m_odr;
    rand dv_base_reg_field d_ifd0;
    rand dv_base_reg_field d_ifd1;
    rand dv_base_reg_field d_odr;
    rand dv_base_reg_field mvm_exe;
    rand dv_base_reg_field mvm_prg;
    rand dv_base_reg_field dwpu;
    rand dv_base_reg_field d_dpu;
    rand dv_base_reg_field d_iau;
    rand dv_base_reg_field m_dpu;
    rand dv_base_reg_field m_iau;

    `uvm_object_utils(trace_unit_csr_reg_message_mode)

    function new(string       name = "trace_unit_csr_reg_message_mode",
                 int unsigned n_bits = 64,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      // create fields
      sw_ep = (dv_base_reg_field::
               type_id::create("sw_ep"));
      sw_ep.configure(
        .parent(this),
        .size(2),
        .lsb_pos(0),
        .access("RW"),
        .volatile(0),
        .reset(64'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sw_ep.set_original_access("RW");

      m_ifd0 = (dv_base_reg_field::
                type_id::create("m_ifd0"));
      m_ifd0.configure(
        .parent(this),
        .size(2),
        .lsb_pos(2),
        .access("RW"),
        .volatile(0),
        .reset(64'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      m_ifd0.set_original_access("RW");

      m_ifd1 = (dv_base_reg_field::
                type_id::create("m_ifd1"));
      m_ifd1.configure(
        .parent(this),
        .size(2),
        .lsb_pos(4),
        .access("RW"),
        .volatile(0),
        .reset(64'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      m_ifd1.set_original_access("RW");

      m_ifdw = (dv_base_reg_field::
                type_id::create("m_ifdw"));
      m_ifdw.configure(
        .parent(this),
        .size(2),
        .lsb_pos(6),
        .access("RW"),
        .volatile(0),
        .reset(64'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      m_ifdw.set_original_access("RW");

      m_odr = (dv_base_reg_field::
               type_id::create("m_odr"));
      m_odr.configure(
        .parent(this),
        .size(2),
        .lsb_pos(8),
        .access("RW"),
        .volatile(0),
        .reset(64'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      m_odr.set_original_access("RW");

      d_ifd0 = (dv_base_reg_field::
                type_id::create("d_ifd0"));
      d_ifd0.configure(
        .parent(this),
        .size(2),
        .lsb_pos(10),
        .access("RW"),
        .volatile(0),
        .reset(64'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      d_ifd0.set_original_access("RW");

      d_ifd1 = (dv_base_reg_field::
                type_id::create("d_ifd1"));
      d_ifd1.configure(
        .parent(this),
        .size(2),
        .lsb_pos(12),
        .access("RW"),
        .volatile(0),
        .reset(64'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      d_ifd1.set_original_access("RW");

      d_odr = (dv_base_reg_field::
               type_id::create("d_odr"));
      d_odr.configure(
        .parent(this),
        .size(2),
        .lsb_pos(14),
        .access("RW"),
        .volatile(0),
        .reset(64'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      d_odr.set_original_access("RW");

      mvm_exe = (dv_base_reg_field::
                 type_id::create("mvm_exe"));
      mvm_exe.configure(
        .parent(this),
        .size(2),
        .lsb_pos(16),
        .access("RW"),
        .volatile(0),
        .reset(64'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mvm_exe.set_original_access("RW");

      mvm_prg = (dv_base_reg_field::
                 type_id::create("mvm_prg"));
      mvm_prg.configure(
        .parent(this),
        .size(2),
        .lsb_pos(18),
        .access("RW"),
        .volatile(0),
        .reset(64'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mvm_prg.set_original_access("RW");

      dwpu = (dv_base_reg_field::
              type_id::create("dwpu"));
      dwpu.configure(
        .parent(this),
        .size(2),
        .lsb_pos(20),
        .access("RW"),
        .volatile(0),
        .reset(64'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dwpu.set_original_access("RW");

      d_dpu = (dv_base_reg_field::
               type_id::create("d_dpu"));
      d_dpu.configure(
        .parent(this),
        .size(2),
        .lsb_pos(22),
        .access("RW"),
        .volatile(0),
        .reset(64'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      d_dpu.set_original_access("RW");

      d_iau = (dv_base_reg_field::
               type_id::create("d_iau"));
      d_iau.configure(
        .parent(this),
        .size(2),
        .lsb_pos(24),
        .access("RW"),
        .volatile(0),
        .reset(64'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      d_iau.set_original_access("RW");

      m_dpu = (dv_base_reg_field::
               type_id::create("m_dpu"));
      m_dpu.configure(
        .parent(this),
        .size(2),
        .lsb_pos(26),
        .access("RW"),
        .volatile(0),
        .reset(64'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      m_dpu.set_original_access("RW");

      m_iau = (dv_base_reg_field::
               type_id::create("m_iau"));
      m_iau.configure(
        .parent(this),
        .size(2),
        .lsb_pos(28),
        .access("RW"),
        .volatile(0),
        .reset(64'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      m_iau.set_original_access("RW");

    endfunction : build
  endclass : trace_unit_csr_reg_message_mode

  class trace_unit_csr_reg_entry_count extends dv_base_reg;
    // fields
    rand dv_base_reg_field entry_count;

    `uvm_object_utils(trace_unit_csr_reg_entry_count)

    function new(string       name = "trace_unit_csr_reg_entry_count",
                 int unsigned n_bits = 64,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      // create fields
      entry_count = (dv_base_reg_field::
                     type_id::create("entry_count"));
      entry_count.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RO"),
        .volatile(1),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      entry_count.set_original_access("RO");

      set_is_ext_reg(1);
    endfunction : build
  endclass : trace_unit_csr_reg_entry_count

  class trace_unit_csr_reg_sw_ep_trigger extends dv_base_reg;
    // fields
    rand dv_base_reg_field sw_id;

    `uvm_object_utils(trace_unit_csr_reg_sw_ep_trigger)

    function new(string       name = "trace_unit_csr_reg_sw_ep_trigger",
                 int unsigned n_bits = 64,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      // create fields
      sw_id = (dv_base_reg_field::
               type_id::create("sw_id"));
      sw_id.configure(
        .parent(this),
        .size(2),
        .lsb_pos(0),
        .access("RW"),
        .volatile(0),
        .reset(64'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sw_id.set_original_access("RW");

    endfunction : build
  endclass : trace_unit_csr_reg_sw_ep_trigger

  class trace_unit_csr_reg_block extends dv_base_reg_block;
    // registers
    rand trace_unit_csr_reg_ctrl ctrl;
    rand trace_unit_csr_reg_trigger_en trigger_en;
    rand trace_unit_csr_reg_message_mode message_mode;
    rand trace_unit_csr_reg_entry_count entry_count;
    rand trace_unit_csr_reg_sw_ep_trigger sw_ep_trigger;

    `uvm_object_utils(trace_unit_csr_reg_block)

    function new(string name = "trace_unit_csr_reg_block",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(8),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      ctrl = (trace_unit_csr_reg_ctrl::
              type_id::create("ctrl"));
      ctrl.configure(.blk_parent(this));
      ctrl.build(csr_excl);
      default_map.add_reg(.rg(ctrl),
                          .offset(64'h0),
                          .rights("RW"));
      ctrl.add_hdl_path_slice("u_ctrl_enable.q", 0, 1, 0);
      ctrl.add_hdl_path_slice("u_ctrl_mode.q", 1, 1, 0);
      ctrl.add_hdl_path_slice("u_ctrl_cntr_prescale.q", 2, 4, 0);
      ctrl.add_hdl_path_slice("u_ctrl_start_addr.q", 16, 10, 0);
      ctrl.add_hdl_path_slice("u_ctrl_end_addr.q", 32, 10, 0);

      trigger_en = (trace_unit_csr_reg_trigger_en::
                    type_id::create("trigger_en"));
      trigger_en.configure(.blk_parent(this));
      trigger_en.build(csr_excl);
      default_map.add_reg(.rg(trigger_en),
                          .offset(64'h8),
                          .rights("RW"));
      trigger_en.add_hdl_path_slice("u_trigger_en_sw_ep.q", 0, 1, 0);
      trigger_en.add_hdl_path_slice("u_trigger_en_m_ifd0.q", 1, 1, 0);
      trigger_en.add_hdl_path_slice("u_trigger_en_m_ifd1.q", 2, 1, 0);
      trigger_en.add_hdl_path_slice("u_trigger_en_m_ifdw.q", 3, 1, 0);
      trigger_en.add_hdl_path_slice("u_trigger_en_m_odr.q", 4, 1, 0);
      trigger_en.add_hdl_path_slice("u_trigger_en_d_ifd0.q", 5, 1, 0);
      trigger_en.add_hdl_path_slice("u_trigger_en_d_ifd1.q", 6, 1, 0);
      trigger_en.add_hdl_path_slice("u_trigger_en_d_odr.q", 7, 1, 0);
      trigger_en.add_hdl_path_slice("u_trigger_en_mvm_exe.q", 8, 1, 0);
      trigger_en.add_hdl_path_slice("u_trigger_en_mvm_prg.q", 9, 1, 0);
      trigger_en.add_hdl_path_slice("u_trigger_en_dwpu.q", 10, 1, 0);
      trigger_en.add_hdl_path_slice("u_trigger_en_d_dpu.q", 11, 1, 0);
      trigger_en.add_hdl_path_slice("u_trigger_en_d_iau.q", 12, 1, 0);
      trigger_en.add_hdl_path_slice("u_trigger_en_m_dpu.q", 13, 1, 0);
      trigger_en.add_hdl_path_slice("u_trigger_en_m_iau.q", 14, 1, 0);

      message_mode = (trace_unit_csr_reg_message_mode::
                      type_id::create("message_mode"));
      message_mode.configure(.blk_parent(this));
      message_mode.build(csr_excl);
      default_map.add_reg(.rg(message_mode),
                          .offset(64'h10),
                          .rights("RW"));
      message_mode.add_hdl_path_slice("u_message_mode_sw_ep.q", 0, 2, 0);
      message_mode.add_hdl_path_slice("u_message_mode_m_ifd0.q", 2, 2, 0);
      message_mode.add_hdl_path_slice("u_message_mode_m_ifd1.q", 4, 2, 0);
      message_mode.add_hdl_path_slice("u_message_mode_m_ifdw.q", 6, 2, 0);
      message_mode.add_hdl_path_slice("u_message_mode_m_odr.q", 8, 2, 0);
      message_mode.add_hdl_path_slice("u_message_mode_d_ifd0.q", 10, 2, 0);
      message_mode.add_hdl_path_slice("u_message_mode_d_ifd1.q", 12, 2, 0);
      message_mode.add_hdl_path_slice("u_message_mode_d_odr.q", 14, 2, 0);
      message_mode.add_hdl_path_slice("u_message_mode_mvm_exe.q", 16, 2, 0);
      message_mode.add_hdl_path_slice("u_message_mode_mvm_prg.q", 18, 2, 0);
      message_mode.add_hdl_path_slice("u_message_mode_dwpu.q", 20, 2, 0);
      message_mode.add_hdl_path_slice("u_message_mode_d_dpu.q", 22, 2, 0);
      message_mode.add_hdl_path_slice("u_message_mode_d_iau.q", 24, 2, 0);
      message_mode.add_hdl_path_slice("u_message_mode_m_dpu.q", 26, 2, 0);
      message_mode.add_hdl_path_slice("u_message_mode_m_iau.q", 28, 2, 0);

      entry_count = (trace_unit_csr_reg_entry_count::
                     type_id::create("entry_count"));
      entry_count.configure(.blk_parent(this));
      entry_count.build(csr_excl);
      default_map.add_reg(.rg(entry_count),
                          .offset(64'h18),
                          .rights("RO"));
      entry_count.add_hdl_path_slice("u_entry_count.qs", 0, 16, 0);

      sw_ep_trigger = (trace_unit_csr_reg_sw_ep_trigger::
                       type_id::create("sw_ep_trigger"));
      sw_ep_trigger.configure(.blk_parent(this));
      sw_ep_trigger.build(csr_excl);
      default_map.add_reg(.rg(sw_ep_trigger),
                          .offset(64'h20),
                          .rights("RW"));
      sw_ep_trigger.add_hdl_path_slice("u_sw_ep_trigger.q", 0, 2, 0);


    endfunction : build
  endclass : trace_unit_csr_reg_block

endpackage

