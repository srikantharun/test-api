Name,Type,Req_id,Priority,Description,Measure,Source,Coverpoints if applicable
Remove Software Datapath Control,UVM,DMC_CMDB_CLEANUP,High,Remove SWDP control related tests.,,{$module_name}_DMC_swdp_*test  {$module_name}_swdp_fifo_overflow_test   ifd_reg_cg odr_reg_cg,per instance: cp_swdp_fifo_count  [EMPTY ALMOST EMPTY ALMOST FULL FULL]
Unaligned Transfer VTRSP IRQ,UVM,DMC_UNALIGNED_VTRSP_ERROR,High,Generate Unaligned Transfer via AXI Stream. 64 Word Unaligned for INT8. 32 word Unaligned for FP16. !6 Word Unaligned for FP32.,Group,{$module_name}_DMC_cmdb_ifd_vtrsp_irq_test   odr_reg_cg,per instance: cp_ifd_vtrsp_irq [HAS_ERROR NO_ERROR]
VTRSP Not Present IRQ,UVM,DMC_VTRSP_NOT_PRESENT_ERROR,High,Enable VTRSP for IFDW instance that does not support it.,Group,{$module_name}_DMC_cmdb_ifd_vtrsp_access_error_test   odr_reg_cg,per instance: cp_ifd_vtrsp_access_error_irq [HAS_ERROR NO_ERROR]
VTRSP Enable,UVM + Python,DMC_VTRSP_ENABLE,High,Enable VTRSP for IFDW. The transpose function is checked against the Python model for all VTRSP modes.,Group,{$module_name}_DMC_cmdb_ifd_vtrsp_test   DMC_ag_cg,per instance: cp_ifd_vtrsp_mode [DISABLED INT8 FP16 FP32]
L1 AXI HP Slave Memory Access (moved from L1 plan),UVM,L1_AXI_HP_SLV_MEM_ACCESS,High,L1 Memory Access via HP AXI Slave port. Cover built-in AXI parameters from VIP aside form self-coded function coverage.,Group,{$module_name}_axi_rnd_test  {$module_name}_l1_mem_test l1_axi_slv_cg,per_instance:  cp_addr [L1_BANK0:L1_BANK15] cp_burst_len [1:64] cp_burst_size [AXI_BURST_SIZE_64_BYTE] cp_burst_type [FIXED INCR WRAP] cp_op [AXI_READ AXI_WRITE]
L1 External Access (moved from L1 plan),UVM,L1_EXTERNAL_ACCESS,High,IFD read from External and ODR write to External. This is executed by DMA reading/writing using an address outside this L1's address range.,Group,{$module_name}_ifd_odr_*_lc_*test   ifd_odr_ag_cg,per_instance:  cp_l1_external [AI_CORE_1 AI_CORE_2 AI_CORE_3 AI_CORE_4 L2]
L1 External Access Error Response (moved from L1 plan),UVM,L1_EXTERNAL_ACCESS_ERR_RESP,High,Verify by giving DECERR and SLVERR response to external access described in L1_EXTERNAL_ACCESS.,Group,{$module_name}_l1_axi_slverr_test {$module_name}_l1_axi_decerr_test   l1_lc_mmio_cg,per_instance:  cp_error [MMIO_ERROR NO_MMIO_ERROR]
Decompression + VTRSP,UVM,DMC_DECOMPRESSION_VTRSP,Low,Verify decompression + VTRSP flow. Ensure b2b decompression with VTRSP and combinations of toggling them ON and OFF in sequence of commands.,Group,{$module_name}_DMC_cmdb_decomp_vtrsp*_test   DMC_ag_cg,per instance: cp_decompression_vtrsp
Address Generator,UVM + Python,DMC_ADDR_GEN,Medium,RTL Design is consistent with Python Model. This is checked via DMC_addr_gen_ref_model which integrates ICDF python model for address generator intp the UVM testbench.,Group,{$module_name}_DMC_cmdb_*test   DMC_ag_cg,All IFD-ODR descriptor coverpoints per device instance.
MMIO Write and Read Access,UVM,DMC_MMIO_ACCESS,Medium,MMIO Access to read (IFD) or write (ODR) to and from the memory is implicitly verified by address and data scoreboards. MMIO RD is compared with data in memory (L1). MMIO WR is compared with the AXI Stream data.,Group,{$module_name}_DMC_cmdb_*test DMC_dpc_cg,All IFD-ODR descriptor coverpoints per device instance.
AXI Stream Input/ Output,UVM,DMC_AXI_STREAM,Medium,IFD Outputs AXI Stream according to command parameters and memory data. ODR receives AXI Stream with random data from master end. AXI Stream Monitor is tapped into the AXIS Interface.,Group,{$module_name}_DMC_cmdb_*test DMC_ag_cg,All IFD-ODR descriptor coverpoints per device instance.
Datapath Mask and Padding,UVM,DMC_MASK_AND_PAD,Medium,The combinations of mask and padding should be covered using random linear and non-linear data formats.,Group,{$module_name}_DMC_cmdb_*test   DMC_dpc_cg,per instance: cp_mask [ZERO IN_BETWEEN[8] ALL_ONE] cp_pad [PADDED UNPADDED]
CMD Descriptor Zero Header,UVM,DMC_CMD_DESC_ZERO_HEADER,Medium,Commands will be issued to the Command Block without regard to token mechanism.,Group,{$module_name}_DMC_cmdb_*test    tkn_mgr_DMC_cg,per instance: cp_producer_tkn_count  [NO_TOKEN] cp_consumer_tkn_count  [NO_TOKEN]
Token Production,UVM,DMC_TOKEN_PRODUCTION,Medium,Verify that IFD/ODR can produce token credits for the targeted device using token mechanism in the Command Block Header.,Group,{$module_name}_tkn_mgr_*test   tkn_mgr_DMC_cg,per instance: cp_producer_tkn_count  [ONE_TOKEN TWO_TOKENS ABOVE_TWO]
Token Consumption,UVM,DMC_TOKEN_CONSUMPTION,Medium,Verify that IFD/ODR can consume incoming token credits from and proceeds only with the command execution when the credit is already provided. Timing is checked by Token Manager Reference Model.,test.percent_pass,{$module_name}_tkn_mgr_*test tkn_mgr_DMC_cg,per instance: cp_consumer_tkn_count  [ONE_TOKEN TWO_TOKENS ABOVE_TWO]
CMD Descriptor Simple Linear Read,UVM,DMC_CMD_FORMAT_EQ_1,Medium,cmd_format=1 to activate Simple Linear Read Command. ,Group,{$module_name}_DMC_cmdb_lightcmd_test   DMC_ag_cg,per instance: cmd_format [LINEAR]
CMD Descriptor Done Notification,UVM,DMC_CMD_DONE,Medium,Polling of CMD Block Done status will be done in case of not using token mechanism.,test.percent_pass,,
Clock and Reset,UVM,DMC_CLK_RST,Medium,All tests will use the target frequency of 800Mhz. Reset will be done at random timing and ensure normal operation afterwards.,test.percent_pass,{$module_name}_reset_test,
Address Out of Range IRQ,UVM,DMC_ADDR_OUT_OF_RANGE_IRQ,Medium,Error scenario test with function coverage shall verify this. Membase address and mem_bsize will be constrained to limit memory range into values not enough to execute the IFD/ODR transfer.,Group,{$module_name}_DMC_cmdb_addr_out_of_range_test   DMC_dpc_cg,per instance: cp_addr_out_of_range [HAS_ERROR NO_ERROR]
TLAST High IRQ,UVM,DMC_TLAST_HIGH_IRQ,Medium,AXI Stream Master Will Assert Tlast on unexpected time. The corresponding interrupt should assert when enabled and not when disabled.,Group,{$module_name}_DMC_cmdb_tlast_high_test   odr_reg_cg,per instance: cp_unexp_tlast_high_irq [HAS_ERROR NO_ERROR]
TLAST Low IRQ,UVM,DMC_TLAST_HIGH_IRQ,Medium,AXI Stream Master Will Not Assert Tlast on expected time. The corresponding interrupt should assert when enabled and not when disabled.,Group,{$module_name}_DMC_cmdb_tlast_low_test   odr_reg_cg,per instance: cp_unexp_tlast_low_irq [HAS_ERROR NO_ERROR]
Unaligned Transfer VTRSP IRQ,UVM,DMC_UNALIGNED_VTRSP_ERROR,Medium,Generate Unaligned Transfer via AXI Stream. 64 Word Unaligned for INT8. 32 word Unaligned for FP16. !6 Word Unaligned for FP32.,Group,{$module_name}_DMC_cmdb_vtrsp_irq_test   odr_reg_cg,per instance: cp_vtrsp_irq [HAS_ERROR NO_ERROR]
VTRSP Not Present IRQ,UVM,DMC_VTRSP_NOT_PRESENT_ERROR,Medium,Enable VTRSP for ODR instance that does not support it.,Group,{$module_name}_DMC_cmdb_vtrsp_access_error_test   odr_reg_cg,per instance: cp_vtrsp_access_error_irq [HAS_ERROR NO_ERROR]
VTRSP Enable,UVM + Python,DMC_VTRSP_ENABLE,Medium,Enable VTRSP for ODR. The transpose function is checked against the Python model for all VTRSP modes.,Group,{$module_name}_DMC_cmdb_vtrsp_test   DMC_ag_cg,per instance: cp_vtrsp_mode [DISABLED INT8 FP16 FP32]
CMD FIFO Depth,UVM,DMC_CMD_FIFO_DEPTH,Medium,Issue commands that will cover full and empty conditions of the Command FIFO.,Group,{$module_name}_DMC_cmdb_fifo_overflow_test   ifd_reg_cg odr_reg_cg,per instance: cp_cmdb_fifo_count  [EMPTY ALMOST EMPTY ALMOST FULL FULL]
CMD Block Outstanding Commands,UVM,DMC_CMD_BLK_OUTSTANDING,Medium,Stress the command block to execute multiple commands without waiting for previous command to be done.,Group,{$module_name}_DMC_cmdb_b2b_test   ifd_reg_cg odr_reg_cg,per instance: cp_cmdb_outstanding_txn  [ZERO ONE MORE_THAN_ONE]
Register Access Layer,UVM,DMC_RAL,Medium,Standard RAL tests will be done.,test.percent_pass,{$module_name}_ral_*test,
Virtual Address,UVM,DMC_VIRTUAL_ADDRESS,Medium,Enable Virtual Address by driving va_base signal to non-zero. When mem_baseaddr is same as VA then the mem_baseaddress is changed to target the local L1 memory. Mem_baseaddr is unchanged otherwise.,Group,{$module_name}_DMC_cmdb_va_test   DMC_ag_cg,per instance: cp_va_base [MISS HIT]
Decompression,UVM,DMC_DECOMPRESSION,Medium,Verify the decompression for IFDW. Ensure back to back decompression and toggling it ON and OFF in sequence of commands.,Group,{$module_name}_DMC_cmdb_decomp*_test   DMC_ag_cg,per instance: cp_decompression [ENABLED DISABLED HIT]
Decompression Error,UVM,DMC_DECOMPRESSION_ERROR,Medium,Enable errors in the decompression stream. Generate stream header error scheme header error uncompressed length error and compressed length error. Inject these errors accordingly to different compression schemes: FVC ZRLE and NO_COMP.,Group,{$module_name}_DMC_cmdb_decomp_error_test  ifd_reg_cg,cp_decomp_invalid_compressed_size_irq [HAS_ERROR NO_ERROR] cp_decomp_invalid_scheme_irq [HAS_ERROR NO_ERROR] cp_decomp_invalid_stream_irq [HAS_ERROR NO_ERROR] cp_invalid_decomp_uncompressed_size_irq [HAS_ERROR NO_ERROR]
Decompression Not Present IRQ,UVM,DMC_DECOMPRESSION,Medium,Enable Decompression for IFD instance that does not support it.,Group,{$module_name}_DMC_cmdb_decomp_access_error_test   ifd_reg_cg,per instance: cp_decomp_access_error_irq [ENABLED DISABLED HIT]
Memory Base Address,UVM,DMC_PARAM_MEMBASEADDR,Medium,Randomize Memory Based Address to target L1 memory range as well as other AI Cores.,Group,{$module_name}_DMC_cmdb_*test   DMC_ag_cg,per instance: cp_l1_bank [ L1_BANKS_ADDRESS_RANGES[16]] cp_l1_external [AI_CORE_1 AI_CORE_2 AI_CORE_3 AI_CORE_4 L2]
Mask Start and End,UVM,DMC_PARAM_MASK_START_END,Medium,Cover all possible combinations of mask start and mask end.,Group,{$module_name}_DMC_cmdb_sweep_mask_*test   DMC_ag_cg,per instance: cp_mask_start [0..63] cp_mask_end [0..64]
Pad Value,UVM,DMC_PARAM_PAD_VAL,Medium,Cover all possible combinations of pad values both positive and negative.,Group,{$module_name}_DMC_cmdb_*test   DMC_ag_cg,per instance: cp_pad_val [-128:127]
Memory Offset,UVM,DMC_PARAM_MEMORY_OFFSET,Medium,Cover a range of memory offsets. This will be a combination of simple function coverage and toggle coverage of the MSB's of memory offsets.,Group,{$module_name}_DMC_cmdb_mem_offset_test   DMC_ag_cg,per instance: cp_mem_offset [NO_OFFSET SMALL_OFFSET LARGE_OFFSET]
Memory Block Size,UVM,DMC_PARAM_MEMBSIZE,Medium,Cover reasonable ranges of value for mem_bsize.,Group,{$module_name}_DMC_cmdb_*test   DMC_ag_cg,per instance: cp_membsize [ZERO BELOW_1K  BETWEEN_1K_AND_4K AFTER_4K_AND_ABOVE]
Number of Dimensions,UVM,DMC_PARAM_NUM_DIM,Medium,Cover 1 to 4 dimensions for all command formats.,Group,{$module_name}_DMC_cmdb_mem_offset_test   DMC_ag_cg,per instance: cp_cmd_format [LINEAR DEFBASED OFFSET_DEFBASED 3D_FALLBACK 4D_FALLBACK] cp_num_dim [1..4] cross_cmd_format__num_dim
Dimension and Loop Pointers,UVM,DMC_PARAM_DIM_LOOP_POINTER,Medium,Cover reasonable ranges of value for dimension definition and loop definition memory pointers.,Group,{$module_name}_DMC_cmdb_*test   DMC_ag_cg,per instance: cp_dim_def_ptr [0:127] cp_loop_def_ptr [0:127]  p_cmd_format [DEFBASED OFFSET_DEFBASED] cross cmd_format__dim_def_ptr cross cmd_format__loop_def_ptr
Pad Mode,UVM,DMC_PARAM_PAD_MODE,Medium,Cover both regular padding and edge padding.,Group,{$module_name}_DMC_cmdb_*test   DMC_ag_cg,per instance: cp_cmd_format [DEFBASED OFFSET_DEFBASED 3D_FALLBACK 4D_FALLBACK] cp_pad_mode [REGULAR EDGE] cross_cmd_format__pad_mode
Ringbuffer,UVM,DMC_PARAM_RINGBUFFER,Medium,Use the ringbuffer when executing IFD and ODR transfers.,Group,{$module_name}_DMC_cmdb_*ringbuff*_test   DMC_ag_cg,per instance: cp_ringbuffsize [DISABLED GRANULARITY_1 GRANULARITY_2_TO_8 GRANULARITY_9_TO_16 GRANULARITY_17_ABOVE]
Linear Length,UVM,DMC_PARAM_PAD_MODE,Medium,Cover PWORD length from 1 to 4096 using linear command format.,Group,{$module_name}_DMC_cmdb_lightcmd_test   DMC_ag_cg,per instance: cp_length [PW_1_TO_100 PW_101_TO_1000 PW_1001_ABOVE]
Dimension Widths,UVM,DMC_PARAM_DIM_WIDTHS,Medium,Cover meaningful combinations of dimension widths A to D. High dimension widths by toggling MSB's of the parameters should also be covered for code coverage.,Group,{$module_name}_DMC_cmdb_*test   DMC_ag_cg,per instance: cp_dim_width_a[b][c][d] [ZERO ONE TWO_TO_FIVE SIX_ABOVE] cross dim_width_AtoB cross dim_width_AtoC cross dim_width_AtoD
Dimension Offsets,UVM,DMC_PARAM_DIM_OFFSETS,Medium,Cover meaningful combinations of dimension offsets A to D. Both positive and negative values should be covered.,Group,{$module_name}_DMC_cmdb_*test   DMC_ag_cg,per instance: cp_dim_offset_a[b][c][d] [NEG_SIX_BELOW NEG_FIVE_TO_NEG_TWO NEG_ONE ZERO ONE TWO_TO_FIVE SIX_ABOVE] cross dim_offset_AtoB cross dim_offset_AtoC cross dim_offset_AtoD
Inner and Outer Lengths,UVM,DMC_PARAM_INNER_OUTER_LEN,Medium,Cover meaningful combinations of inner and outer lengths A to D. High inner or outer lengths by toggling MSB's of the parameters should also be covered for code coverage. Control simulation time by having only 1 parameter set to high value and the rest to 1.,Group,{$module_name}_DMC_cmdb_*test  {$module_name}_DMC_cmdb_high_*er_len_test  DMC_ag_cg,per instance: cp_inner[outer]_len_a[b][c][d] [NEG_SIX_BELOW NEG_FIVE_TO_NEG_TWO NEG_ONE ZERO ONE TWO_TO_FIVE SIX_ABOVE] cross inner[outer]_len_AtoB cross inner[outer]_len_AtoC cross inner[outer]_len_AtoD
Memory Strides,UVM,DMC_PARAM_MEM_STRIDES,Medium,Cover meaningful combinations of memory strides A to D. MSB's of memstride can be hit by constraining inner and outer lengths products to low value such as 1.,Group,{$module_name}_DMC_cmdb_*test  {$module_name}_DMC_cmdb_*memstride*_test    DMC_ag_cg,per instance: cp_mem_stride_a[b][c][d] [ZERO MEM_STR_64 MEM_STR_128 MEM_STR_192 MEM_STR_256] cross mem_stride_AtoB cross mem_stride_AtoC cross mem_stride_AtoD
Inner and Outer Strides,UVM,DMC_PARAM_INNER_OUTER_STRIDE,Medium,Cover meaningful combinations of inner and outer strides A to D. Cover postive negative and zero values.,Group,{$module_name}_DMC_cmdb_*test   DMC_ag_cg,per instance: cp_inner[outer]_stride_a[b][c][d] [NEG_FIVE_TO_NEG_FOUR NEG_THREE_TO_NEG_TWO NEG_ONE ZERO ONE TWO_TO_THREE FOUR_TO_FIVE] cross inner[outer]_stride_AtoB cross inner[outer]_stride_AtoC cross inner[outer]_stride_AtoD
Vector Dimension,UVM,DMC_PARAM_VECT_DIM,Medium,Cover meaningful combinations of vector dimensions pointing dimensions A to D. Cross it with number of dimensions.,Group,{$module_name}_DMC_cmdb_*test   DMC_ag_cg,per instance: cp_vect_dim [DIM1 DIM2 DIM3 DIM4] cross_vect_dim__num_dim
Mask Start and End WRT Vec DIM,UVM,DMC_PARAM_MASK_WRT_VECT_DIM,Medium,Cover meaningful combinations mask start and mask end depending on dimension width (=1 and > 1) and selected dimension specified by vect_dim,Group,{$module_name}_DMC_cmdb_*test   DMC_ag_cg,per instance: cp_mask_start_A[B][C][D]_width_eq_1 [0..63] cp_mask_start_A[B][C][D]_width_grt_1 [0..63] cp_mask_end_A[B][C][D]_width_eq_1 [0..64] cp_mask_end_A[B][C][D]_width_grt_1 [0..64]
