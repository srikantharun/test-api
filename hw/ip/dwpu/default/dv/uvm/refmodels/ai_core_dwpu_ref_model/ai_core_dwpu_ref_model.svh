`ifndef AI_CORE_DWPU_REF_MODEL_SV
`define AI_CORE_DWPU_REF_MODEL_SV


`uvm_analysis_imp_decl (_DP_CMD)

class ai_core_dwpu_ref_model extends uvm_component;
  `uvm_component_utils(ai_core_dwpu_ref_model)

  // AI Core DWPU RAL Model
  DWPU_RAL regmodel;

  bit[31:0] base_addr = DWPU_CSR_ST_ADDR;
  svt_axi_transaction cfg_item;
  svt_axi_transaction cfg_item_aux;
  svt_axi_transaction data_item;
  svt_axi_transaction data_out_item;
  ai_core_dwpu_seq_item dwpu_item;
  ai_core_dwpu_seq_item dwpu_out_item;
  token_agent_seq_item  tok_cons_q [$];
  token_agent_seq_item  tok_prod_q [$];
  ai_core_dwpu_seq_item trace_vld_q [$];

  //declare queue to save the DP commands that will be received from ai_core_dp_cmd_gen_model
  ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_command#(aic_dp_cmd_gen_pkg::dummy_dp_command_t)   dp_command_q[$];
  ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_model#(aic_dp_cmd_gen_pkg::dummy_dp_command_t)     dp_cmd_model;

  //declare analysis port that will be connected to ai_core_dp_cmd_gen_model to send the commands to be used by the model
  uvm_analysis_port#(ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_cmdb) ap_to_dp_cmd_model;
  //declare analysis port that will be connected to ai_core_dp_cmd_gen_model to receive DP commands generated by the model
  uvm_analysis_imp_DP_CMD#(ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_command#(aic_dp_cmd_gen_pkg::dummy_dp_command_t), ai_core_dwpu_ref_model) analysis_imp_dp_commands;

  uvm_tlm_analysis_fifo#(ai_core_dwpu_seq_item) taf_mon_dwpu;
  uvm_tlm_analysis_fifo#(svt_axi_transaction) taf_mon_cfg;
  uvm_tlm_analysis_fifo#(svt_axi_transaction) taf_mon_data;

  uvm_analysis_port#(svt_axi_transaction) ap_stream_out;
  uvm_analysis_port#(ai_core_dwpu_seq_item) ap_dwpu_out;
  uvm_analysis_port#(token_agent_seq_item) ap_tok_out;

  bit exec_en;
  bit header_received;
  bit cmd_run;
  bit active_out_stream;
  bit push_tlast_on_cmd;
  bit image_sign  = 1;
  bit weight_sign = 1;
  bit skip_illegal_prog;
  bit dbg_sw_irq;
  bit irq_en[string];
  bit read_input;
  /** Variable to inform if the input data stream Watchdog was triggered (watchdog do not exist on design, is to help on the test control) */
  bit wd_trig;

  bit [AXI_STREAM_IFD0_DATA_WIDTH-1:0] in_dt_stream_q[$];
  bit [AXI_STREAM_IFD0_DATA_WIDTH-1:0] in_dt_stream;
  bit [AIC_PWORD_SIZE-1:0][DWPU_OUT_WORD_DW-1:0] dt_out_q[$];
  bit [NUM_WB_REGS-1:0][DWPU_IN_WORD_DW-1:0] wb_ff[NUM_CHANNELS-1:0];
  bit [NUM_SP_REGS-1:2][DWPU_IN_WORD_DW-1:0] sp_ff[NUM_CHANNELS-1:0];
  bit [DWPU_IN_WORD_DW-1:0] sp0_ff[NUM_CHANNELS-1:0];
  bit [NUM_OPERANDS-1:0][DWPU_IN_WORD_DW-1:0] image_reg[NUM_CHANNELS-1:0];
  bit [NUM_OPERANDS-1:0][DWPU_IN_WORD_DW-1:0] weight_reg[NUM_CHANNELS-1:0];

  dwpu_dp_command_t prog_mem[int];
  dwpu_dp_command_t curr_instr;
  bit [DP_INSTRUCTION_WIDTH-1:0] instr;
  int instr_cnt;

  //declare variables that will be used to decode the different types of commands
  ai_core_dwpu_cmd_tr   cmd_q [$];
  ai_core_dwpu_cmd_tr   curr_cmd;
  bit [DWPU_CMD_MEM_WIDTH-1:0] cmd;
  bit [DWPU_CMD_MEM_WIDTH-1:0] aux_cmd;
  int cmd_cnt;
  int last_cmd_q_size; //used to control the sending of irq regarding CMDBLK_CMD_DROPPED interrupt
  dwpu_cmd_header_t header_cmd_q [$];
  dwpu_cmd_header_t curr_header_cmd;
  aic_dp_cmd_gen_pkg::cmd_format_e curr_cmd_format;
  int cmd_num_rows;

  bit [NUM_CHANNELS-1:0][DWPU_OUT_WORD_DW-1:0] out_res;

  /** struct that contains the information regarding loops */
  //cmd_loop_info_t loop_info;

  //verbosity options
  uvm_verbosity dp_dbg_verbosity = UVM_DEBUG;
  uvm_verbosity tok_dbg_verbosity = UVM_DEBUG;
  typedef uvm_enum_wrapper#(uvm_verbosity) verbosity_wrapper;

  function new(string name ="", uvm_component parent = null);
    super.new(name,parent);
    analysis_imp_dp_commands = new("analysis_imp_dp_commands", this);
  endfunction

  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);

    //output data generated by ref_model
    ap_stream_out = new("ap_stream_out",this);
    ap_dwpu_out   = new("ap_dwpu_out",this);
    ap_tok_out    = new("ap_tok_out",this);
    dwpu_item     = ai_core_dwpu_seq_item::type_id::create("dwpu_item");
    cfg_item      = svt_axi_transaction::type_id::create("cfg_item");
    cfg_item_aux  = svt_axi_transaction::type_id::create("cfg_item_aux");
    data_item     = svt_axi_transaction::type_id::create("data_item");

    //input data fifos
    taf_mon_cfg  = new("taf_mon_cfg", this);
    taf_mon_data = new("taf_mon_data", this);
    taf_mon_dwpu = new("taf_mon_dwpu", this);

    // DP command Model
    dp_cmd_model = ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_model#(aic_dp_cmd_gen_pkg::dummy_dp_command_t)::type_id::create("dp_cmd_model", this);
    ap_to_dp_cmd_model = new("ap_to_dp_cmd_model",this);
  endfunction : build_phase

  virtual function void connect_phase(uvm_phase phase);
    super.connect_phase(phase);
    uvm_config_db#(uvm_verbosity)::get(this, "", "dp_dbg_verbosity", dp_dbg_verbosity);
    uvm_config_db#(uvm_verbosity)::get(this, "", "tok_dbg_verbosity", tok_dbg_verbosity);
    // Connect this analysis port to model analysis export
    this.ap_to_dp_cmd_model.connect(dp_cmd_model.analysis_export);

    // Connect Scoreboards
    dp_cmd_model.command_ap.connect(this.analysis_imp_dp_commands);
  endfunction : connect_phase

  virtual task run_phase(uvm_phase phase);
    super.run_phase(phase);
    forever begin
      fork
        forever begin // configuration monitoring
          taf_mon_cfg.get(cfg_item_aux);
          cfg_item.do_copy(cfg_item_aux);
          if (cfg_item.xact_type == svt_axi_transaction::WRITE) begin
            foreach (cfg_item.data[i]) begin
              decode_addr(cfg_item.addr, cfg_item.data[i]);
              if (cfg_item.burst_type != svt_axi_transaction::FIXED)
                cfg_item.addr+=8;
            end
          end
        end
        forever exec_cmd();
        forever exec_program();
        forever begin //reset monitoring
          taf_mon_dwpu.get(dwpu_item);
          if (!dwpu_item.reset_an_i) begin
            reset();
            break;
          end
        end
      join_any
      disable fork;
    end
  endtask : run_phase

  virtual function void write_DP_CMD(ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_command#(aic_dp_cmd_gen_pkg::dummy_dp_command_t) t);
    dp_command_q.push_back(t);
    `uvm_info("dwpu_mdl", $sformatf("Received a DP command: %s", t.sprint()), dp_dbg_verbosity)
  endfunction

  function void reset();
    `uvm_info("dwpu_mdl", "Resetting model", UVM_HIGH)
    exec_en           = 0;
    push_tlast_on_cmd = 0;
    header_received   = 0;
    cmd_run           = 0;
    active_out_stream = 0;
    image_sign        = 1;
    weight_sign       = 1;
    skip_illegal_prog = 0;
    curr_header_cmd   = 0;
    curr_instr        = 0;
    exec_en           = 0;
    last_cmd_q_size   = 0;
    cmd_num_rows      = DWPU_CMD_NUM_ROWS_FULL;
    wb_ff             = '{default:0};
    sp_ff             = '{default:0};
    sp0_ff            = '{default:0};
    image_reg         = '{default:0};
    weight_reg        = '{default:0};
    out_res           = 0;
    in_dt_stream_q.delete();
    dt_out_q.delete();
    cmd_q.delete();
    header_cmd_q.delete();
    taf_mon_data.flush();
    tok_cons_q.delete();
    tok_prod_q.delete();
    trace_vld_q.delete();
    //reset regmodel
    regmodel.reset();
  endfunction

  function void update_irq_en(bit [AIC_LT_AXI_DATA_WIDTH-1:0] a_data);
    irq_en["ERR_ACT_STREAM_IN"]     = a_data[0];
    irq_en["ERR_ACT_STREAM_OUT"]    = a_data[1];
    irq_en["ERR_ILLEGAL_FORMAT"]    = a_data[2];
    irq_en["ERR_EMPTY_PROGRAM"]     = a_data[3];
    irq_en["ERR_MAIN_0_LENGTH"]     = a_data[4];
    irq_en["ERR_MAIN_1_LENGTH"]     = a_data[5];
    irq_en["ERR_MAIN_2_LENGTH"]     = a_data[6];
    irq_en["ERR_NESTED_0_LENGTH"]   = a_data[7];
    irq_en["ERR_NESTED_1_LENGTH"]   = a_data[8];
    irq_en["ERR_NESTED_0_MAPPING"]  = a_data[9];
    irq_en["ERR_NESTED_1_MAPPING"]  = a_data[10];
    irq_en["ERR_NESTED_0_SEGFAULT"] = a_data[11];
    irq_en["ERR_NESTED_1_SEGFAULT"] = a_data[12];
    irq_en["ERR_NESTED_ORDER"]      = a_data[13];
    irq_en["ERR_NESTED_NESTING"]    = a_data[14];
    irq_en["ERR_NESTED_OVERLAP"]    = a_data[15];
    irq_en["CMDBLK_CMD_DROPPED"]    = a_data[16];
    irq_en["DBG_SW_INTERRUPT"]      = a_data[32];
  endfunction : update_irq_en

  function void decode_header_cmd (bit [AIC_LT_AXI_DATA_WIDTH-1:0] p_data);
    /** push back header information to header_cmd_q and tok_prod/cons_q */
    header_cmd_q.push_back(dwpu_cmd_header_t'(p_data));
    tok_cons_add_to_queue(p_data);
    tok_prod_add_to_queue(p_data);
    trace_vld_add_to_queue(p_data);

    /** update cmd_num_rows variable depending on the format type */
    cmd_num_rows = ai_core_dwpu_utils::get_cmd_num_rows(header_cmd_q[header_cmd_q.size-1].format);

    if(header_cmd_q[header_cmd_q.size-1].format == aic_dp_cmd_gen_pkg::Bypass) begin
      ai_core_dwpu_cmd_tr empty_cmd = ai_core_dwpu_cmd_tr::type_id::create("empty_cmd");
      // since the bypass command is only the header, means that the next command will start again with the header. So reset header_received variable.
      header_received = 0;
      //update cmd with all zeros and push it back to cmd_q
      cmd_q.push_back(ai_core_dwpu_cmd_tr'(empty_cmd));
    end
  endfunction : decode_header_cmd

  function void decode_cmd (bit [AIC_LT_AXI_DATA_WIDTH-1:0] p_data);
    aux_cmd[AIC_LT_AXI_DATA_WIDTH * cmd_cnt++ +: AIC_LT_AXI_DATA_WIDTH] = p_data;

    if (cmd_cnt == cmd_num_rows) begin
      ai_core_dwpu_cmd_tr                                   cmd_to_model = ai_core_dwpu_cmd_tr::type_id::create("cmd_to_model");
      ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_cmdb   cmd_info = ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_cmdb::type_id::create("cmd_info");

      cmd_info = ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_utils::get_full_cmd_from_alternative_cmd(aux_cmd, header_cmd_q[header_cmd_q.size-1].format);
      cmd_to_model.do_copy_from_base(cmd_info);

      cmd_q.push_back(ai_core_dwpu_cmd_tr'(cmd_to_model));
      cmd_cnt = 0;
      header_received = 0;
      `uvm_info("dwpu_mdl", $sformatf("cmd: %s", cmd_to_model.sprint()), dp_dbg_verbosity)
    end
  endfunction : decode_cmd

  function void decode_addr(bit [AIC_LT_AXI_LOCAL_ADDR_WIDTH-1:0] addr, bit [AIC_LT_AXI_DATA_WIDTH-1:0] data);
    `uvm_info("dwpu_mdl", $sformatf("Decoding addr: %0h, data: %0h", addr, data), UVM_HIGH)
    //dwpu_csr
    if (addr == regmodel.cmdblk_ctrl.get_address()) begin
      exec_en = data[0];
    end else if (addr == regmodel.dp_ctrl.get_address()) begin
      weight_sign       = data[0];
      image_sign        = data[1];
      skip_illegal_prog = data[2];
      dbg_sw_irq        = data[DWPU_IRQ_DBG_SW_INTERRUPT];
      `uvm_info("dwpu_mdl", $sformatf("Weight signed: %b, image signed: %b, skip illegal: %b, dbg_sw_irq: %b", weight_sign, image_sign, skip_illegal_prog, dbg_sw_irq), dp_dbg_verbosity)
      if(get_irq_en("DBG_SW_INTERRUPT") && dbg_sw_irq) begin
        `uvm_info("dwpu_mdl", $sformatf("DWPU_IRQ_DBG_SW_INTERRUPT was predicted by the reference model"), UVM_NONE)
        send_irq_item(DWPU_IRQ_DBG_SW_INTERRUPT);
      end
    end else if (addr inside {[DWPU_IMEM_ST_ADDR : DWPU_IMEM_END_ADDR]}) begin
      //cmdgen
      instr[AIC_LT_AXI_DATA_WIDTH * instr_cnt++ +: AIC_LT_AXI_DATA_WIDTH] = data;
      if (instr_cnt == DWPU_INSTR_NUM_ROWS) begin
        addr -= DWPU_IMEM_ST_ADDR;
        prog_mem[addr/DWPU_INSTR_BYTES] = instr;
        instr_cnt = 0;
        `uvm_info("dwpu_mdl", $sformatf("write instr in prog mem[%0d]: %p",addr/DWPU_INSTR_BYTES, prog_mem[addr/DWPU_INSTR_BYTES]), UVM_HIGH)
      end
    end else if (addr inside {[DWPU_CMD_ST_ADDR : DWPU_CMD_END_ADDR]}) begin
      //HEADER + COMMAND
      if (header_received) begin
        decode_cmd(data);
      end else begin
        header_received = 1;
        decode_header_cmd(data);
      end
    end
  endfunction : decode_addr

  function void send_irq_item(dwpu_irq_t a_irq_type);
    `uvm_info("dwpu_mdl", $sformatf("send_irq_item irq %s", a_irq_type.name()), UVM_HIGH)
    dwpu_out_item = ai_core_dwpu_seq_item::type_id::create("dwpu_out_item");
    dwpu_out_item.irq_o = 1;
    dwpu_out_item.irq_type = a_irq_type;
    ap_dwpu_out.write(dwpu_out_item);
  endfunction : send_irq_item

  function void drop_cmd_if_fifo_full();
    if (last_cmd_q_size != cmd_q.size) begin
      `uvm_info("dwpu_mdl", $sformatf("Size of cmd_q = %0d and IRQ CMDBLK_CMD_DROPPED enable = %0d", cmd_q.size(), get_irq_en("CMDBLK_CMD_DROPPED")), UVM_HIGH)
      if (cmd_q.size > aic_common_pkg::AIC_GEN_CMDB_CMD_FIFO_DEPTH) begin
        if (get_irq_en("CMDBLK_CMD_DROPPED")) begin
          `uvm_info("dwpu_mdl", $sformatf("Sending prediction of CMDBLK_CMD_DROPPED"), UVM_HIGH)
          send_irq_item(DWPU_IRQ_CMDBLK_CMD_DROPPED);
        end
        //discard the last command
        void'(cmd_q.pop_back);
        void'(header_cmd_q.pop_back);
      end
      //updating last_cmd_q_size
      last_cmd_q_size = cmd_q.size();
    end
  endfunction : drop_cmd_if_fifo_full

  //get the exec_en from csr and the cmd from cmdblock fifo
  //and enable execution of standard or bypass mode
  task exec_cmd();
    int return_val;
    int error;
    wait (!cmd_run && cmd_q.size > 0);
    if (exec_en) begin
      curr_cmd = cmd_q.pop_front();
      curr_header_cmd = header_cmd_q.pop_front();
      error=0;
      return_val = $cast(curr_cmd_format, curr_header_cmd.format);
      `uvm_info("dwpu_mdl", $sformatf("return_val: %0d and curr_cmd_format.name: %s", return_val, curr_cmd_format.name()), dp_dbg_verbosity)
      `uvm_info("dwpu_mdl", $sformatf("curr_header_cmd: %p", curr_header_cmd), dp_dbg_verbosity)
      `uvm_info("dwpu_mdl", $sformatf("curr_cmd: %s", curr_cmd.sprint()), dp_dbg_verbosity)

      if  ( (curr_header_cmd.format != aic_dp_cmd_gen_pkg::Bypass) &&
            (curr_cmd.main_empty(0) && curr_cmd.main_empty(1) && curr_cmd.main_empty(2))
          ) begin
        `uvm_info("dwpu_mdl", "[IRQ] Invalid Program, length == 0", UVM_LOW)
        error=1;
        if (get_irq_en("ERR_EMPTY_PROGRAM"))
          send_irq_item(DWPU_IRQ_ERR_EMPTY_PROGRAM);
      end
      if (curr_cmd.main_valid(0) && (curr_cmd.get_end(1,0) > INSTR_MEM_DEPTH)) begin
        `uvm_info("dwpu_mdl", "[IRQ] Invalid Program, main 0 len larger than instruction memory ", UVM_LOW)
        error=1;
        if (get_irq_en("ERR_MAIN_0_LENGTH"))
          send_irq_item(DWPU_IRQ_ERR_MAIN_0_LEN);
      end
      if (curr_cmd.main_valid(1) && (curr_cmd.get_end(1,1) > INSTR_MEM_DEPTH)) begin
        `uvm_info("dwpu_mdl", "[IRQ] Invalid Program, main 1 len larger than instruction memory ", UVM_LOW)
        error=1;
        if (get_irq_en("ERR_MAIN_1_LENGTH"))
          send_irq_item(DWPU_IRQ_ERR_MAIN_1_LEN);
      end
      if (curr_cmd.main_valid(2) && (curr_cmd.get_end(1,2) > INSTR_MEM_DEPTH)) begin
        `uvm_info("dwpu_mdl", "[IRQ] Invalid Program, main 2 len larger than instruction memory ", UVM_LOW)
        error=1;
        if (get_irq_en("ERR_MAIN_2_LENGTH"))
          send_irq_item(DWPU_IRQ_ERR_MAIN_2_LEN);
      end
      if (curr_cmd.nested_valid(0) && (curr_cmd.get_end(0,0) > INSTR_MEM_DEPTH)) begin
        `uvm_info("dwpu_mdl", "[IRQ] Invalid Program, nested 0 len larger than instruction memory ", UVM_LOW)
        error=1;
        if (get_irq_en("ERR_NESTED_0_LENGTH"))
          send_irq_item(DWPU_IRQ_ERR_NESTED_0_LEN);
      end
      if (curr_cmd.nested_valid(1) && (curr_cmd.get_end(0,1) > INSTR_MEM_DEPTH)) begin
        `uvm_info("dwpu_mdl", "[IRQ] Invalid Program, nested 1 len larger than instruction memory ", UVM_LOW)
        error=1;
        if (get_irq_en("ERR_NESTED_1_LENGTH"))
          send_irq_item(DWPU_IRQ_ERR_NESTED_1_LEN);
      end
      if (curr_cmd.nested_valid(0) &&
               (    (curr_cmd.main_valid(2) &&                                  curr_cmd.get_map_main(0) > 2)
                 || ((!curr_cmd.main_valid(2)) &&                               curr_cmd.get_map_main(0) > 1)
                 || ((!curr_cmd.main_valid(2)) && (!curr_cmd.main_valid(1)) &&  curr_cmd.get_map_main(0) > 0)
               )
      ) begin
        `uvm_info("dwpu_mdl", $sformatf("[IRQ] Invalid Program, Nested 0 mapping is invalid. Nested map main = %0d", curr_cmd.get_map_main(0)), UVM_LOW)
        error=1;
        if (get_irq_en("ERR_NESTED_0_MAP"))
          send_irq_item(DWPU_IRQ_ERR_NESTED_0_MAP);
      end
      if (curr_cmd.nested_valid(1) &&
               (    (curr_cmd.main_valid(2) &&                                  curr_cmd.get_map_main(1) > 2)
                 || ((!curr_cmd.main_valid(2)) &&                               curr_cmd.get_map_main(1) > 1)
                 || ((!curr_cmd.main_valid(2)) && (!curr_cmd.main_valid(1)) &&  curr_cmd.get_map_main(1) > 0)
               )
      ) begin
        `uvm_info("dwpu_mdl", $sformatf("[IRQ] Invalid Program, Nested 0 mapping is invalid. Nested map main = %0d", curr_cmd.get_map_main(1)), UVM_LOW)
        error=1;
        if (get_irq_en("ERR_NESTED_1_MAP"))
          send_irq_item(DWPU_IRQ_ERR_NESTED_1_MAP);
      end
      if (curr_cmd.nested_valid(0) &&
                (     ((curr_cmd.get_map_main(0) == 0) && (curr_cmd.nested_0.start<curr_cmd.main_0.start || curr_cmd.get_end(0,0) > curr_cmd.get_end(1,0)))
                  ||  ((curr_cmd.get_map_main(0) == 1) && (curr_cmd.nested_0.start<curr_cmd.main_1.start || curr_cmd.get_end(0,0) > curr_cmd.get_end(1,1)))
                  ||  ((curr_cmd.get_map_main(0) == 2) && (curr_cmd.nested_0.start<curr_cmd.main_2.start || curr_cmd.get_end(0,0) > curr_cmd.get_end(1,2)))
                )
              ) begin
        `uvm_info("dwpu_mdl", "[IRQ] Invalid Program, nested 0 exceeds main boundaries", UVM_LOW)
        error=1;
        if (get_irq_en("ERR_NESTED_0_SEGFAULT"))
          send_irq_item(DWPU_IRQ_ERR_NESTED_0_SEGFAULT);
      end
      if (curr_cmd.nested_valid(1) &&
                (     ((curr_cmd.get_map_main(1) == 0) && (curr_cmd.nested_1.start<curr_cmd.main_0.start || curr_cmd.get_end(0,1) > curr_cmd.get_end(1,0)))
                  ||  ((curr_cmd.get_map_main(1) == 1) && (curr_cmd.nested_1.start<curr_cmd.main_1.start || curr_cmd.get_end(0,1) > curr_cmd.get_end(1,1)))
                  ||  ((curr_cmd.get_map_main(1) == 2) && (curr_cmd.nested_1.start<curr_cmd.main_2.start || curr_cmd.get_end(0,1) > curr_cmd.get_end(1,2)))
                )
              ) begin
        `uvm_info("dwpu_mdl", "[IRQ] Invalid Program, nested 1 exceeds main boundaries", UVM_LOW)
        error=1;
        if (get_irq_en("ERR_NESTED_1_SEGFAULT"))
          send_irq_item(DWPU_IRQ_ERR_NESTED_1_SEGFAULT);
      end
      if(curr_cmd.nested_valid(1) && curr_cmd.co_nested() && curr_cmd.nested_1.start < curr_cmd.nested_0.start) begin
        `uvm_info("dwpu_mdl", "[IRQ] Invalid Program, nested 1 starts before nested 0", UVM_LOW)
        if (get_irq_en("ERR_NESTED_ORDER"))
          send_irq_item(DWPU_IRQ_ERR_NESTED_ORDER);
      end
      if(curr_cmd.nested_valid(1) &&
            ( ((curr_cmd.nested_1.start <= curr_cmd.nested_0.start) && (curr_cmd.get_end(0,1)> curr_cmd.get_end(0,0)))
              ||
              ((curr_cmd.nested_1.start < curr_cmd.nested_0.start) && (curr_cmd.get_end(0,1)>= curr_cmd.get_end(0,0)))
            )
      ) begin
        `uvm_info("dwpu_mdl", "[IRQ] Invalid Program, nested 0 is inside nested 1", UVM_LOW)
        error=1;
        if (get_irq_en("ERR_NESTED_NESTING"))
          send_irq_item(DWPU_IRQ_ERR_NESTED_NESTING);
      end
      if(curr_cmd.nested_valid(1) && curr_cmd.co_nested() &&
                ( ((curr_cmd.nested_1.start < curr_cmd.nested_0.start) && (curr_cmd.get_end(0,1) <= curr_cmd.get_end(0,0)))
                  ||
                  ((curr_cmd.nested_1.start <= curr_cmd.get_end(0,0)) && (curr_cmd.get_end(0,1) > curr_cmd.get_end(0,0)))
                )
              ) begin
        `uvm_info("dwpu_mdl", "[IRQ] Invalid Program, nested 1 overlaps nested 0", UVM_LOW)
        error=1;
        if (get_irq_en("ERR_NESTED_OVERLAP"))
          send_irq_item(DWPU_IRQ_ERR_NESTED_OVERLAP);
      end
      if ( (return_val==0)||(curr_cmd_format.name() == "") ) begin //vcs will return 0 to cast while vsim will return 1
        `uvm_info("dwpu_mdl", $sformatf("[IRQ] Invalid Program, command format is invalid. cmd_format = %0d", curr_header_cmd.format), UVM_LOW)
        error=1;
        if (get_irq_en("ERR_ILLEGAL_FORMAT"))
          send_irq_item(DWPU_IRQ_ERR_ILLEGAL_FORMAT);
      end
      if(error==0) begin
        cmd_run=1;
        `uvm_info("dwpu_mdl", $sformatf("Enabled cmd execution, cmd: %0s", "EXE"), UVM_HIGH)
      end
      //remove consumer token from queue and send it to the scoreboard
      tok_cons_remove_from_queue();
    end
    else begin //exec_en equal to 0
      drop_cmd_if_fifo_full();
      #1ns;
    end
  endtask : exec_cmd

  //upon a instruction data request, if no data available in queue
  //wait for a new data stream to continue executing
  task get_data_stream(bit req_data);
    if (in_dt_stream_q.size == 0 && req_data) begin
      `uvm_info("dwpu_mdl", $sformatf("Waiting Input Data"),dp_dbg_verbosity)
      taf_mon_data.get(data_item);
      `uvm_info("dwpu_mdl", $sformatf("Got Input Data"),dp_dbg_verbosity)
      foreach (data_item.tdata[i])  begin
        //axi vip creates tdata with SVT_AXI_MAX_TDATA_WIDTH, which is stream output = 1663b
        in_dt_stream_q.push_back(data_item.tdata[i][AXI_STREAM_IFD0_DATA_WIDTH-1:0]);
        `uvm_info("dwpu_mdl", $sformatf("Got data from input and AXI_STREAM_IFD0_DATA_WIDTH = 0d%0d while SVT_AXI_MAX_TDATA_WIDTH = %0d",AXI_STREAM_IFD0_DATA_WIDTH, `SVT_AXI_MAX_TDATA_WIDTH), UVM_FULL)
      end
    end
    if (req_data) begin
      `uvm_info("dwpu_mdl", $sformatf("removing 1 input from queue with %0d data words", in_dt_stream_q.size),dp_dbg_verbosity)
      in_dt_stream = in_dt_stream_q.pop_front();
    end
    else if (in_dt_stream_q.size) begin
      in_dt_stream = in_dt_stream_q[0];
    end

  endtask


  //load all registers and execute instruction operation
  function void dwpu_channel(int ch, bit [DWPU_IN_WORD_DW-1:0] data_channel);
    bit [15:0] prod_res;
    int dbg_ch = 0;
    if(!$value$plusargs("DWPU_DBG_CHANNEL=%d", dbg_ch)) dbg_ch = 0;


    //sp0 holds absorbing element which content depends on operation and cfg
    case (curr_instr.op_desc.opcode)
      MAX     : sp0_ff[ch] = image_sign ? -128 : 0;
      MIN     : sp0_ff[ch] = image_sign ? 127 : 255;
      default : sp0_ff[ch] = 0; //SOP and SUM
    endcase

    //************************************************
    //loads image and weight registers first to add 1 cycle delay
    //between scratchpad and weight buffer regs load
    foreach (image_reg[ch][i]) begin
      case (curr_instr.i_sel[i]) inside
        0       : image_reg[ch][i] = sp0_ff[ch];
        1       : image_reg[ch][i] = data_channel;
        [2:127] : image_reg[ch][i] = sp_ff[ch][curr_instr.i_sel[i]];
      endcase
      if (ch == dbg_ch) `uvm_info("dwpu_mdl", $sformatf("ch: %0d curr_instr.i_sel[%0d] = %0d | data_channel = 0x%0x | sp_ff[%0d][%0d] = 0x%0x | sp0_ff[%0d] = 0x%0x",ch, i, curr_instr.i_sel[i], data_channel, ch, curr_instr.i_sel[i], sp_ff[ch][curr_instr.i_sel[i]], ch, sp0_ff[ch]), dp_dbg_verbosity)
    end

    foreach (weight_reg[ch][i]) begin
      weight_reg[ch][i] = wb_ff[ch][(curr_instr.w_sel[i]+curr_cmd.extra)%(NUM_WB_REGS)];
      if (ch == dbg_ch) `uvm_info("dwpu_mdl", $sformatf("ch: %0d wb_ff[%0d][%0d] = %h | w_sel[%0d] = %0d | w_offset = %0d | NUM_WB_REGS = %0d",ch, ch, (curr_instr.w_sel[i]+curr_cmd.extra)%(NUM_WB_REGS), wb_ff[ch][(curr_instr.w_sel[i]+curr_cmd.extra)%(NUM_WB_REGS)], i, curr_instr.w_sel[i], curr_cmd.extra, NUM_WB_REGS), dp_dbg_verbosity)
      if (ch == dbg_ch) `uvm_info("dwpu_mdl", $sformatf("ch: %0d weight_reg[%0d][%0d] = %h",ch, ch, i, weight_reg[ch][i]), dp_dbg_verbosity)
    end

    if (ch == dbg_ch) `uvm_info("dwpu_mdl", $sformatf("ch: %0d wb_ff[ch][0] = %h in_data: %h", dbg_ch, wb_ff[dbg_ch][0], data_channel), dp_dbg_verbosity)

    //************************************************
    //execute operations
    //sum of products
    if (curr_instr.op_desc.opcode == SOP) begin
      foreach (image_reg[ch][i]) begin
          if (image_sign)
            prod_res = signed'(image_reg[ch][i]);
          else
            prod_res = image_reg[ch][i];

          if (weight_sign)
            prod_res = signed'(prod_res) * signed'(weight_reg[ch][i]);
          else
            prod_res = signed'(prod_res) * signed'({1'b0,weight_reg[ch][i]});

          if (image_sign || weight_sign)
            out_res[ch] = signed'(out_res[ch]) + signed'(prod_res);
          else
            out_res[ch] += prod_res;
        if (ch == dbg_ch )
          `uvm_info("dwpu_mdl", $sformatf("SOP op, ch: %0d: i_reg: %0h w_reg: %0h, prod res: %0h",i, image_reg[dbg_ch][i], weight_reg[dbg_ch][i] ,prod_res), dp_dbg_verbosity)
      end
    end else begin
      if (image_sign) begin
        bit signed [DWPU_OUT_WORD_DW-1:0] arr[NUM_OPERANDS-1:0];
        bit signed [DWPU_OUT_WORD_DW-1:0] res[$];
        foreach (image_reg[ch][i]) begin
          arr[i] = signed'(image_reg[ch][i]);
          if(ch==dbg_ch)`uvm_info("dwpu_mdl", $sformatf("ch: %0d: arr[%0d]: %0h image_reg[%0d][%0d]: %0h",ch, i, arr[i], ch, i, image_reg[ch][i]), dp_dbg_verbosity)
        end
        case (curr_instr.op_desc.opcode)
          MIN:      res = arr.min();
          MAX:      res = arr.max();
          default:  res[0] = arr.sum();
        endcase
        out_res[ch] = res[0];
      end else begin
        bit [DWPU_OUT_WORD_DW-1:0] arr[NUM_OPERANDS-1:0];
        bit [DWPU_OUT_WORD_DW-1:0] res[$];
        foreach (image_reg[ch][i]) begin
          arr[i] = image_reg[ch][i];
          if(ch==dbg_ch)`uvm_info("dwpu_mdl", $sformatf("ch: %0d: arr[%0d]: %0h image_reg[%0d][%0d]: %0h",ch, i, arr[i], ch, i, image_reg[ch][i]), dp_dbg_verbosity)
        end
        case (curr_instr.op_desc.opcode)
          MIN:      res = arr.min();
          MAX:      res = arr.max();
          default:  res[0] = arr.sum();
        endcase
        out_res[ch] = res[0];
      end
      if (ch == dbg_ch ) begin
        foreach (image_reg[ch][i]) begin
          `uvm_info("dwpu_mdl", $sformatf("ch: %0d, idx: %0d, image: %0h  weight: %0h", ch,i,image_reg[ch][i], weight_reg[ch][i]), dp_dbg_verbosity)
        end
        `uvm_info("dwpu_mdl", $sformatf("op: %s, sign: %b, ch: %0d: res: %0h", curr_instr.op_desc.opcode.name,
                                        image_sign, ch, out_res[ch]), dp_dbg_verbosity)
      end
    end
    if (ch == dbg_ch ) `uvm_info("dwpu_mdl", $sformatf("out_res[%0d]: %0h", dbg_ch, out_res[dbg_ch]), dp_dbg_verbosity)


    //************************************************
    //loads scratchpad and weight buffer registers
    //last executed to mimic reg cycle delay
    foreach (wb_ff[ch][i]) begin
      if(curr_instr.op_desc.shift_wb) begin
        if(i==0)  wb_ff[ch][i] = data_channel;
        else      wb_ff[ch][i] = wb_ff[ch][i-1];
      end
    end
    foreach (sp_ff[ch][i]) begin
      if(curr_instr.op_desc.shift_sp) begin
        if(i==2)  sp_ff[ch][i] = data_channel;
        else      sp_ff[ch][i] = sp_ff[ch][i-1];
      end
    end
  endfunction : dwpu_channel

  task automatic exec_instr(int p_address, bit p_clr_last_push = 1);
    `uvm_info("dwpu_mdl", $sformatf("exec_instr addr %0d and p_clr_last_push= %0d", p_address, p_clr_last_push), dp_dbg_verbosity)
    /** Get the new instruction */
    curr_instr = prog_mem[p_address];
    `uvm_info("dwpu_mdl", $sformatf("exec instr[%0d]: %p", p_address, curr_instr), dp_dbg_verbosity)

    /** Clear the last push indication if is intended to */
    if(p_clr_last_push && curr_instr.op_desc.op_exe && curr_instr.op_desc.last_push) begin
      `uvm_info("dwpu_mdl", $sformatf("Instr w/ push_last and not last loop: downgrade to push without last"), dp_dbg_verbosity)
      curr_instr.op_desc.last_push = 0;
    end

    /** Get input data stream.
     * Its is necessary to fork join the read of data with a watchdog of 500us to make sure that if there is no more data comming in, the testbench model does not get hang.
     * If the watchdog gets triggered then we are facing the invalid situation of having the input stream shorter than it should be.
     */
    read_input = ai_core_dwpu_utils::get_read_input(curr_instr);
    wd_trig = 0;
      fork
        begin
          get_data_stream(read_input);
        end
        begin
          #500us;
          wd_trig = 1;
          `uvm_info("dwpu_mdl", $sformatf("Watchdog of 500us was triggered for input stream"), UVM_NONE)
        end
      join_any
      disable fork;

    if(wd_trig == 0) begin
      /** Executing dwpu instruction if channel is enabled */
      for(int i=0; i<NUM_CHANNELS; i++) begin
        dwpu_channel(i, in_dt_stream[i * DWPU_IN_WORD_DW +: DWPU_IN_WORD_DW]);
      end

      /** If op_exe is enabled, send the result ot the scoreboard to be compared */
      if (curr_instr.op_desc.op_exe) begin
       `uvm_info("dwpu_mdl", $sformatf("Pushing out_data: %0h", out_res), dp_dbg_verbosity)
        dt_out_q.push_back(out_res);
        if (curr_instr.op_desc.last_push) begin
          data_out_item = svt_axi_transaction::type_id::create("data_out_item");
          data_out_item.tdata = dt_out_q;
          dt_out_q.delete();
          `uvm_info("dwpu_mdl", $sformatf("Push-last output data stream, tdata size: %0d", data_out_item.tdata.size()), dp_dbg_verbosity)
          ap_stream_out.write(data_out_item);
        end
      end
      out_res = 0;

      //update push_tlast_on_cmd
      if(push_tlast_on_cmd==0) begin
        push_tlast_on_cmd = (curr_instr.op_desc.last_push && curr_instr.op_desc.op_exe);
      end
      //update active_out_stream
      active_out_stream |= curr_instr.op_desc.op_exe;
    end
  endtask : exec_instr


  task exec_program();
    int curr_last_main_idx;
    /** Wait for a command in order to be able to run the program */
    `uvm_info("dwpu_mdl", $sformatf("exec_program Entering"), UVM_HIGH)
    wait (cmd_run == 1);
    if (curr_header_cmd.format != aic_dp_cmd_gen_pkg::Bypass) begin
      //send to model
      ap_to_dp_cmd_model.write(ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_cmdb'(curr_cmd));
      //set current last main index to be used on the comparison on when is the last instruction of the program
      if(curr_cmd.format inside {[aic_dp_cmd_gen_pkg::LoopsM1N0:aic_dp_cmd_gen_pkg::LoopsM1N2]}) begin
        curr_last_main_idx = 0;
      end
      else if(curr_cmd.format inside {[aic_dp_cmd_gen_pkg::LoopsM2N0:aic_dp_cmd_gen_pkg::LoopsM2N2]}) begin
        curr_last_main_idx = 1;
      end
      else if(curr_cmd.format inside {[aic_dp_cmd_gen_pkg::LoopsM3N0:aic_dp_cmd_gen_pkg::LoopsM3N2]}) begin
        curr_last_main_idx = 2;
      end
      else begin
        `uvm_fatal(get_name, $sformatf("Command format %0d not implemented", curr_header_cmd.format));
      end
      //while the command is running
      while (cmd_run) begin
        //check the size of the dp_command_q that is filled by the model output
        if(dp_command_q.size>=1) begin
          ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_command#(aic_dp_cmd_gen_pkg::dummy_dp_command_t) aux_dp_cmd;
          bit [63:0] prog_mem_addr;

          //load DP command which will have the address on "data" field
          aux_dp_cmd = dp_command_q.pop_front();
          `uvm_info("dwpu_mdl", $sformatf("after pop_front dp_command_q.size %0d", dp_command_q.size()), dp_dbg_verbosity)
          prog_mem_addr = aux_dp_cmd.data;
          `uvm_info("dwpu_mdl", $sformatf("exec_program address %0d", prog_mem_addr), dp_dbg_verbosity)
          exec_instr(prog_mem_addr, (aux_dp_cmd.overall_last==0));

          `uvm_info("dwpu_mdl", $sformatf("overall_last: %0d | curr_last_main_idx: %0d | main_index: %0d | prog_mem_addr: %0d | end_addr: %0d", aux_dp_cmd.overall_last, curr_last_main_idx, aux_dp_cmd.main_index, prog_mem_addr, curr_cmd.get_end(1, aux_dp_cmd.main_index)), dp_dbg_verbosity)
          if(aux_dp_cmd.overall_last && (curr_last_main_idx == aux_dp_cmd.main_index) && prog_mem_addr == curr_cmd.get_end(1, aux_dp_cmd.main_index)) begin
            `uvm_info("dwpu_mdl", $sformatf("program finished"), dp_dbg_verbosity)
            cmd_run = 0;
          end
        end
      end

      //if watchdog was triggered while running the program, means that the input data was not enough to the whole program
      if(wd_trig) begin
        `uvm_info("dwpu_mdl", $sformatf("[IRQ] Invalid Program, input stream is too short, irq enable : %b", get_irq_en("ERR_ACT_STREAM_IN")), UVM_LOW)
        if (get_irq_en("ERR_ACT_STREAM_IN"))
          send_irq_item(DWPU_IRQ_ERR_ACT_STREAM_IN);
      end
      //program ended & last push to output does not assert TLAST or
      //not all inputs consumed : raise interruption signal irq_o
      else if ( ((push_tlast_on_cmd==0) && (active_out_stream))
                || in_dt_stream_q.size()) begin
        if ((push_tlast_on_cmd==0) && (active_out_stream)) begin
          `uvm_info("dwpu_mdl", $sformatf("[IRQ] Invalid Program, unfinished output stream, irq enable: %b", get_irq_en("ERR_ACT_STREAM_OUT")), UVM_LOW)
          data_out_item = svt_axi_transaction::type_id::create("data_out_item");
          data_out_item.tdata = dt_out_q;
          dt_out_q.delete();
          ap_stream_out.write(data_out_item);
        end else begin
          `uvm_info("dwpu_mdl", $sformatf("[IRQ] Invalid Program, not all inputs consumed, irq enable : %b", get_irq_en("ERR_ACT_STREAM_IN")), UVM_LOW)
        end
        if (get_irq_en("ERR_ACT_STREAM_OUT") && (push_tlast_on_cmd==0) && (active_out_stream))
          send_irq_item(DWPU_IRQ_ERR_ACT_STREAM_OUT);
        if (get_irq_en("ERR_ACT_STREAM_IN") && in_dt_stream_q.size())
          send_irq_item(DWPU_IRQ_ERR_ACT_STREAM_IN);
        //reset push_tlast_on_cmd variable
        push_tlast_on_cmd = 0;
      end
    end else begin
      //bypass
      `uvm_info("dwpu_mdl", $sformatf("Executing bypass cmd, input data forwarded to output"), dp_dbg_verbosity)
      taf_mon_data.get(data_item);
      //check that all previous data was sent to the output stream
      if(dt_out_q.size!=0) begin
        `uvm_error("dwpu_mdl", $sformatf("There is data from the previous command still to be sent out. dt_out_q.size()=%0d", dt_out_q.size()))
      end
      data_out_item = svt_axi_transaction::type_id::create("data_out_item");
      //create an array with the size of data comming from input (data_item) plus the remaing data from previous command that was not pushed to the output stream
      data_out_item.tdata = new[data_item.tdata.size()];
      foreach (data_out_item.tdata[i]) begin
        data_out_item.tdata[i] = stream_sign_ext(data_item.tdata[i]);
      end
      `uvm_info("dwpu_mdl", $sformatf("bypass-> Push-last output data stream, tdata size: %0d", data_out_item.tdata.size()), dp_dbg_verbosity)
      ap_stream_out.write(data_out_item);
      //command done, wait for next cmd
      cmd_run = 0;
    end
    active_out_stream = 0;
    `uvm_info("dwpu_mdl", $sformatf("Program done"), dp_dbg_verbosity)
    //remove producer token from queue and send it to the scoreboard
    tok_prod_remove_from_queue();
    //remove trace valid information from the queue and send it to the scoreboard
    trace_vld_remove_from_queue();
  endtask : exec_program

  //sign extend words from input stream to output stream
  function [AXI_STREAM_IAU_DATA_WIDTH-1:0] stream_sign_ext(bit [AXI_STREAM_IFD0_DATA_WIDTH-1:0] dt);
    bit [AIC_PWORD_SIZE-1:0][DWPU_OUT_WORD_DW-1:0] in_dt_sign_ext;
    for (int i = 0; i < AIC_PWORD_SIZE; i ++ ) begin
      if (image_sign)
        in_dt_sign_ext[i] = signed'(dt[DWPU_IN_WORD_DW*i +: DWPU_IN_WORD_DW]);
      else
        in_dt_sign_ext[i] = dt[DWPU_IN_WORD_DW*i +: DWPU_IN_WORD_DW];
    end
    return in_dt_sign_ext;
  endfunction

  //function to add to tok_cons_q queue the token new token information
  function void tok_cons_add_to_queue(dwpu_cmd_header_t p_header);
    token_agent_seq_item l_tok_item;

    l_tok_item = token_agent_seq_item::type_id::create("l_tok_item", this);

    //check into the data if the consumer token bit is active or not
    if(p_header.token_cons==1) begin
      l_tok_item.m_type_enm = TOK_CONS_MON;
      `uvm_info("dwpu_mdl", $sformatf("adding tok to queue tok_cons_q.size=%0d", tok_cons_q.size()+1), tok_dbg_verbosity)
    end
    else begin
      l_tok_item.m_type_enm = TOK_NOT_VALID;
    end
    //push the new token to the queue
    tok_cons_q.push_back(l_tok_item);
  endfunction : tok_cons_add_to_queue

  //function to add to tok_prod_q queue the token new token information
  function void tok_prod_add_to_queue(dwpu_cmd_header_t p_header);
    token_agent_seq_item l_tok_item;

    l_tok_item = token_agent_seq_item::type_id::create("l_tok_item", this);

    //check into the data if the producer token bit is active or not (only bit 0 is used to the token mechanism)
    if(p_header.token_prod[0]==1) begin
      l_tok_item.m_type_enm = TOK_PROD_MON;
      `uvm_info("dwpu_mdl", $sformatf("adding tok to queue tok_prod_q.size=%0d", tok_prod_q.size()+1), tok_dbg_verbosity)
    end
    else begin
      l_tok_item.m_type_enm = TOK_NOT_VALID;
    end
    //push the new token to the queue
    tok_prod_q.push_back(l_tok_item);
  endfunction : tok_prod_add_to_queue

  //function to remove from tok_cons_q queue the token and send to the scoreboard if it is a valid token
  function void tok_cons_remove_from_queue();
    token_agent_seq_item l_tok_item;
    if(tok_cons_q.size() > 0) begin
      `uvm_info("dwpu_mdl", $sformatf("calling tok_cons_remove_from_queue tok_cons_q.size=%0d", tok_cons_q.size()), tok_dbg_verbosity)
      l_tok_item = tok_cons_q.pop_front();
      if(l_tok_item.m_type_enm != TOK_NOT_VALID) begin
        //send to the scoreboard
        ap_tok_out.write(l_tok_item);
      end
    end
  endfunction : tok_cons_remove_from_queue

  //function to remove from tok_prod_q queue the token and send to the scoreboard if it is a valid token
  function void tok_prod_remove_from_queue();
    token_agent_seq_item l_tok_item;
    if(tok_prod_q.size() > 0) begin
      `uvm_info("dwpu_mdl", $sformatf("calling tok_prod_remove_from_queue tok_prod_q.size=%0d", tok_prod_q.size()), tok_dbg_verbosity)
      l_tok_item = tok_prod_q.pop_front();
      if(l_tok_item.m_type_enm != TOK_NOT_VALID) begin
        //send to the scoreboard
        ap_tok_out.write(l_tok_item);
      end
    end
  endfunction : tok_prod_remove_from_queue

  //function to add to trace_vld_q queue the information that will occur a posedge of trace valid line on the output of dwpu
  function void trace_vld_add_to_queue(dwpu_cmd_header_t p_header);
    ai_core_dwpu_seq_item l_dwpu_item;

    l_dwpu_item = ai_core_dwpu_seq_item::type_id::create("l_dwpu_item", this);

    //check into the data if the producer token bit 1 is active or not
    if(p_header.token_prod[1]==1) begin
      l_dwpu_item.trace_vld_o = 1;
    end
    else begin
      l_dwpu_item.trace_vld_o = 0;
    end
    //push the new trace_vld signalization to the queue
    trace_vld_q.push_back(l_dwpu_item);
  endfunction : trace_vld_add_to_queue

  //function to remove from trace_vld_q queue the information that a trace valid will occur and send to the scoreboard
  function void trace_vld_remove_from_queue();
    ai_core_dwpu_seq_item l_dwpu_item;
    if(trace_vld_q.size() > 0) begin
      l_dwpu_item = trace_vld_q.pop_front();
      if(l_dwpu_item.trace_vld_o == 1) begin
        //send to the scoreboard
        ap_dwpu_out.write(l_dwpu_item);
      end
    end
  endfunction : trace_vld_remove_from_queue

  function bit get_irq_en(string p_irq_name);
    bit [63:0] data_from_reg;
    /** update variables that come from the register configuration */
    //update IRQ_EN
    data_from_reg = regmodel.irq_en.get();
    `uvm_info("dwpu_mdl", $sformatf("get_irq_en : Data value from IRQ_EN: 0x%0x", data_from_reg), UVM_HIGH)
    update_irq_en(data_from_reg);

    foreach (irq_en[str]) begin
      `uvm_info("dwpu_mdl", $sformatf("get_irq_en : irq_en[%s]: 0x%0d", str, irq_en[str]), UVM_HIGH)
    end

    return irq_en[p_irq_name];
  endfunction : get_irq_en

  function bit set_irq_en(bit [AIC_LT_AXI_DATA_WIDTH-1:0] a_data);
    regmodel.irq_en.set(.value(a_data));
    `uvm_info("dwpu_mdl", $sformatf("set_irq_en : Data value from IRQ_EN: 0x%0x", a_data), UVM_HIGH)
    update_irq_en(a_data);

    foreach (irq_en[str]) begin
      `uvm_info("dwpu_mdl", $sformatf("set_irq_en : irq_en[%s]: 0x%0d", str, irq_en[str]), UVM_HIGH)
    end
  endfunction : set_irq_en
endclass
`endif
