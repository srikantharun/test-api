`ifndef DPU_REF_MODEL_SV
`define DPU_REF_MODEL_SV

`uvm_analysis_imp_decl (_DP_CMD)

class dpu_ref_model extends uvm_component;
  `uvm_component_utils(dpu_ref_model)

  //covergroup to cover 2 input and 1 output streams
  cvg_in_data cvg_in_data;
  cvg_out_data cvg_out_data;


  svt_axi_transaction cfg_item;
  svt_axi_transaction s0_data_item;
  svt_axi_transaction s1_data_item;
  svt_axi_transaction data_out_item;
  dpu_seq_item dpu_item;
  dpu_seq_item dpu_out_item;
  token_agent_seq_item  tok_cons_q [$];
  token_agent_seq_item  tok_prod_q [$];


  //declare queue to save the DP commands that will be received from ai_core_dp_cmd_gen_model
  ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_command#(aic_dp_cmd_gen_pkg::dummy_dp_command_t)   dp_command_q[$];
  ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_model#(aic_dp_cmd_gen_pkg::dummy_dp_command_t)     dp_cmd_model;

  //declare analysis port that will be connected to ai_core_dp_cmd_gen_model to send the commands to be used by the model
  uvm_analysis_port#(ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_cmdb) ap_to_dp_cmd_model;
  //declare analysis port that will be connected to ai_core_dp_cmd_gen_model to receive DP commands generated by the model
  uvm_analysis_imp_DP_CMD#(ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_command#(aic_dp_cmd_gen_pkg::dummy_dp_command_t), dpu_ref_model) analysis_imp_dp_commands;


  fp_utils c_fp; 

  dp_ctrl_reg_t dp_ctrl;

  uvm_tlm_analysis_fifo#(dpu_seq_item) taf_mon_dpu;
  uvm_tlm_analysis_fifo#(svt_axi_transaction) taf_mon_cfg;
  uvm_tlm_analysis_fifo#(svt_axi_transaction) taf_mon_s0_data;
  uvm_tlm_analysis_fifo#(svt_axi_transaction) taf_mon_s1_data;
  uvm_analysis_port#(token_agent_seq_item) ap_tok_out;

  uvm_analysis_port#(svt_axi_transaction) ap_stream_out;
  uvm_analysis_port#(dpu_seq_item) ap_dpu_out;


  DPU_RAL regmodel;
  bit exec_en;
  bit header_received;
  bit cmd_run;

  bit irq_sent;

  bit [`SVT_AXI_MAX_TDATA_WIDTH-1:0] s0_dt_stream_q[$];
  bit [`SVT_AXI_MAX_TDATA_WIDTH-1:0] s1_dt_stream_q[$];
  pw_dpu_fp_t dt_src0, dt_src2, dt_res;
  pw_dpu_fp_t dt_src1[2];
  bit [PWORD_SIZE-1:0][OUT_WORD_DW-1:0] dt_out_q[$];
  int stream_pword_len;
  pw_dpu_fp_t a_reg[ACC_REG_SIZE];
  pw_dpu_fp_t b_reg[GENERAL_AND_BIN_REG_SIZE];
  pw_dpu_fp_t c_reg[2][PAIRED_COEF_REG_SIZE];
  pw_dpu_fp_t lut_reg;//TODO[LUT_REG_SIZE];
  bit_dw_t cmd_data[$];
  
  dpu_cmd_header_t curr_header;
  dpu_cmd_header_t header_q [$];
  
  dpu_cmd_tr curr_cmd;
  dpu_cmd_tr cmd_q[$];

  //dpu_cmd dp command
  dpu_pkg::dpu_dp_cmd_t prog_mem[int];

  //dp command converted to instructions
  dpu_pkg::dpu_instr_t instr_q[$];
  dpu_pkg::dpu_instr_t curr_instr;

  dpu_irq_reg_t irq;
  dpu_irq_reg_t irq_en;

  bit [CMD_MEM_WIDTH-1:0] aux_cmd;
  int cmd_num_rows;
  int cmd_cnt;

  function new(string name ="", uvm_component parent = null);
    super.new(name,parent);
    analysis_imp_dp_commands = new("analysis_imp_dp_commands", this);
  endfunction

  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);

    //output data generated by ref_model
    ap_stream_out = new("ap_stream_out",this);
    ap_dpu_out    = new("ap_dpu_out",this);
    ap_tok_out    = new("ap_tok_out",this);
    dpu_item      = new("dpu_item");
    cfg_item      = new("cfg_item");
    s0_data_item  = new("s0_data_item");
    s1_data_item  = new("s1_data_item");

    //input data fifos
    taf_mon_cfg  = new("taf_mon_cfg", this);
    taf_mon_s0_data = new("taf_mon_s0_data", this);
    taf_mon_s1_data = new("taf_mon_s1_data", this);
    taf_mon_dpu  = new("taf_mon_dpu", this);
    c_fp = new();

    cvg_in_data = new();
    cvg_out_data  = new();

    // DP command Model
    dp_cmd_model = ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_model#(aic_dp_cmd_gen_pkg::dummy_dp_command_t)::type_id::create("dp_cmd_model", this);
    ap_to_dp_cmd_model = new("ap_to_dp_cmd_model",this);
  endfunction : build_phase

  virtual function void connect_phase(uvm_phase phase);
    super.connect_phase(phase);
    // Connect this analysis port to model analysis export
    this.ap_to_dp_cmd_model.connect(dp_cmd_model.analysis_export);
    // Connect Scoreboards
    dp_cmd_model.command_ap.connect(this.analysis_imp_dp_commands);
  endfunction : connect_phase


  virtual task run_phase(uvm_phase phase);
    super.run_phase(phase);
    reset();
    forever begin
      fork
        forever begin
          svt_axi_transaction item;
          taf_mon_cfg.get(item);
          cfg_item.do_copy(item);
          if (cfg_item.xact_type == svt_axi_transaction::WRITE) begin
            if (cfg_item.addr inside {[DPU_PRG_ADDR_ST:DPU_PRG_ADDR_END]}) begin
              foreach (cfg_item.data[i]) begin
                int num_valid_writes = $countones(cfg_item.wstrb[i]) / 4;
                for (int j = 0; j < num_valid_writes; j++) begin
                  dpu_pkg::dpu_dp_cmd_t prg;
                  prg = cfg_item.data[i][j *32 +: 32];
                  decode_addr(cfg_item.addr, cfg_item.data[i][(j*32)+:32]);
                  if (cfg_item.burst_type != svt_axi_transaction::FIXED)
                    cfg_item.addr+=4;
                end
              end //foreach data
            end //if addr
            else begin
              foreach (cfg_item.data[i]) begin
                decode_addr(cfg_item.addr, cfg_item.data[i]);
                if (cfg_item.burst_type != svt_axi_transaction::FIXED)
                  cfg_item.addr+=8;
              end
            end
          end // if write
        end //forever
        forever exec_cmd();
        forever exec_program();
        forever begin
          taf_mon_dpu.get(dpu_item);
          if (!dpu_item.reset_an_i) begin
            reset();
            break;
          end
        end
      join_any
      disable fork;
    end
  endtask : run_phase

  virtual function void write_DP_CMD(ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_command#(aic_dp_cmd_gen_pkg::dummy_dp_command_t) t);
    dp_command_q.push_back(t);
    `uvm_info("dpu_mdl", $sformatf("Received a DP command: %s", t.sprint()), UVM_HIGH)
  endfunction

  function void reset();
    `uvm_info("dpu_mdl", "Resetting model", UVM_HIGH)
    exec_en          = 0;
    header_received  = 0;
    cmd_run          = 0;
    dp_ctrl          = 0;
    dt_src0          = 0;
    dt_src1[0]       = 0;
    dt_src1[1]       = 0;
    dt_src2          = 0;
    curr_instr       = 0;
    irq_sent         = 0;
    irq              = 0;
    irq_en           = 0;
    stream_pword_len = 0;
    cmd_num_rows     = 0;
    cmd_data.delete();
    header_q.delete();
    cmd_q.delete();
    s0_dt_stream_q.delete();
    s1_dt_stream_q.delete();
    dt_out_q.delete();
    tok_cons_q.delete();
    tok_prod_q.delete();
    foreach (a_reg[i])
      a_reg[i] = 0;
    foreach (b_reg[i])
      b_reg[i] = 0;
    foreach (c_reg[0][i]) begin
      c_reg[0][i] = 0;
      c_reg[1][i] = 0;
    end
    taf_mon_s0_data.flush();
    taf_mon_s1_data.flush();
  endfunction

  function void irq_control(dpu_irq_bit_pos_t irq_position);
    case (irq_position)
      dbg_sw_interrupt :
        irq.dbg_sw_interrupt = dp_ctrl.dbg_sw_irq && irq_en.dbg_sw_interrupt && !irq.dbg_sw_interrupt;
      default:
        irq[irq_position] = irq_en[irq_position] && ! irq[irq_position];
    endcase

    if (|irq && !irq_sent) begin
      dpu_out_item = new();
      dpu_out_item.irq_o = 1;
      `uvm_info("dpu_mdl", $sformatf("irq generated by : %p", irq), UVM_HIGH)
      irq_sent = 1;
      ap_dpu_out.write(dpu_out_item);
    end
  endfunction

  task decode_addr(bit [AXI_AW:0] addr, bit_dw_t data);
    `uvm_info("dpu_mdl", $sformatf("Decoding addr: %0h, data: %0h", addr, data), UVM_HIGH)
    //dpu_csr
    if (addr == regmodel.cmdblk_ctrl.get_address()) begin
      exec_en = data[0];
      `uvm_info("dpu_mdl", $sformatf("exec_en: %b", exec_en), UVM_HIGH)
    end
    else if (addr == regmodel.dp_ctrl.get_address()) begin
      dp_ctrl = data;
      irq_control(dbg_sw_interrupt);
      `uvm_info("dpu_mdl", $sformatf("dp_ctrl: %p", dp_ctrl), UVM_HIGH)
    end 
    else if (addr == regmodel.irq_en.get_address()) begin
      irq_en = data;
      `uvm_info("dpu_mdl", $sformatf("irq_en: %p", irq_en), UVM_HIGH)
    end
    else if (addr == regmodel.irq_status.get_address()) begin
      //irq_status, write 1 to clear
      foreach(data[i]) irq[i] = data[i] ? 0 : irq[i];
    end
    else if (addr inside {[DPU_PRG_ADDR_ST:DPU_PRG_ADDR_END]}) begin
      dpu_pkg::dpu_dp_cmd_t aux = data; 
      addr = (addr - DPU_PRG_ADDR_ST) >> 2;
      //cmdgen
      prog_mem[addr] = aux;
      `uvm_info("dpu_mdl", $sformatf("prog mem[%0h]: %0h, %p", addr, data,  aux), UVM_HIGH)
    end
    else if (addr inside {[DPU_CMD_ADDR_ST : DPU_CMD_ADDR_END]}) begin
      //HEADER + COMMAND
      if (header_received)
        decode_cmd(data);
      else begin
        header_received = 1;
        decode_header(data);
      end
    end
  endtask : decode_addr

  function void decode_header (bit_dw_t p_data);
    /** push back header information to header_q and tok_prod/cons_q */
    header_q.push_back(dpu_cmd_header_t'(p_data));
    tok_cons_add_to_queue(p_data);
    tok_prod_add_to_queue(p_data);

    /** update cmd_num_rows variable depending on the format type */
    cmd_num_rows = get_cmd_num_rows(header_q[$].format);
 
    `uvm_info("dpu_mdl", $sformatf("dp header: %p", header_q[$]), UVM_HIGH)
    if ( header_q[$].format > aic_dp_cmd_gen_pkg::Bypass)
      irq_control(err_illegal_format);
    else if(header_q[$].format == aic_dp_cmd_gen_pkg::Bypass) begin
      dpu_cmd_tr empty_cmd = dpu_cmd_tr::type_id::create("empty_cmd");
      // since the bypass command is only the header, means that the next command will start again with the header. So reset header_received variable.
      header_received = 0;
      //update cmd with all zeros and push it back to cmd_q
      cmd_q.push_back(dpu_cmd_tr'(empty_cmd));
    end
  endfunction : decode_header


  function void decode_cmd (bit_dw_t p_data);
    aux_cmd[AXI_DW * cmd_cnt++ +: AXI_DW] = p_data;
    if (cmd_cnt == cmd_num_rows) begin
      dpu_cmd_tr cmd_to_model = dpu_cmd_tr::type_id::create("cmd_to_model");
      ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_cmdb   cmd_info = ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_cmdb::type_id::create("cmd_info");

      cmd_info = ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_utils::get_full_cmd_from_alternative_cmd(aux_cmd, header_q[$].format);
      cmd_to_model.do_copy_from_base(cmd_info);

      cmd_q.push_back(dpu_cmd_tr'(cmd_to_model));
      cmd_cnt = 0;
      header_received = 0;
      `uvm_info("dpu_mdl", $sformatf("dp cmd: %s", cmd_to_model.sprint()), UVM_HIGH)
    end
    if (cmd_q.size() > dpu_pkg::CMDB_FIFO_DEPTH) begin
      `uvm_info("dpu_mdl", "[IRQ] CMDBLK_CMD_DROPPED: Cmdblk fifo full, dropping command", UVM_LOW)
      `uvm_info("dpu_mdl", $sformatf("cmd dropped: %p, cmd: %p", header_q[$], cmd_q[$]), UVM_HIGH)
      void'(header_q.pop_back);
      void'(cmd_q.pop_back);
      irq_control(cmdblk_cmd_dropped);
    end

  endfunction : decode_cmd


  function void decode_dp_cmd(ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_command#(aic_dp_cmd_gen_pkg::dummy_dp_command_t) dp_cmd);
    dpu_pkg::dpu_dp_cmd_t aux_cmd = prog_mem[dp_cmd.data];
    dpu_pkg::dpu_instr_t instr;

    instr = aux_cmd; 
    instr.vm = vector_mode_e'(curr_header.h_config[0]); //vector_mode

    //broadcasting/offsetting
    if (instr.opcode inside {[OPC_MUL:OPC_CMADD]} && instr.src2[1:0] inside {1,3} && instr.src1 inside {[a0 : a7], [b_c0 : b_c63]} ) begin
      bit [1:0] loop_select  = instr.src2[3:2];
      int       src1_size    = instr.src1 inside {[a0:a7]} ? 8 : instr.src1 inside {[b_c0: b_c63]} ? 64 : 0;
      int       loop_counter = dp_cmd.main || dp_cmd.nested_0 || dp_cmd.nested_1; 
      //offset enabled
      if (instr.src2[1:0] == 1) begin
        instr.src1 = aux_cmd.src1 + loop_counter % src1_size; 
      end
      //broadcast enabled
      else begin
        instr.src1      = aux_cmd.src1 + int'($floor(loop_counter / 64)) % src1_size;
        instr.src2[0]   = 1; //broadcast enable
        instr.src2[6:2] = loop_counter % 64; //broadcast index
      end
    end

    instr_q.push_back(instr);
    //TODO: treat pseudocode (one dp_command can generate multiple instructions)
  endfunction : decode_dp_cmd


  //get the exec_en from csr and the cmd from cmdblock fifo
  //and enable execution of standard or bypass mode
  task exec_cmd();
    wait (!cmd_run && cmd_q.size() && header_q.size() == cmd_q.size());
    if (exec_en) begin
      `uvm_info("dpu_mdl", $sformatf("popping header/cmd size: %0d / %0d, header: %p, cmd: %p", 
                  header_q.size, cmd_q.size, header_q[0], cmd_q[0]), UVM_HIGH)

      curr_header  = header_q.pop_front();
      curr_cmd     = cmd_q.pop_front();

      `uvm_info("dpu_mdl", $sformatf("Cmd execution, cmd: %0s", curr_header.format.name()), UVM_HIGH)
      /*TODO: check those interruptions
       if (! curr_cmd.cmd.init_len && curr_cmd.cmd.loop_len)
        irq_control(err_empty_program);
      else if (curr_cmd.cmd.init_start + curr_cmd.cmd.init_len > PROG_MEM_DEPTH) begin 
        irq_control(err_init_segfault);
        if (!dp_ctrl.skip_illegal_prog) cmd_run = 1;
      end
      else if (curr_cmd.cmd.loop_start + curr_cmd.cmd.loop_len > PROG_MEM_DEPTH) begin
        irq_control(err_loop_segfault);
        if (!dp_ctrl.skip_illegal_prog) cmd_run = 1;
      end
      else 
        */
      cmd_run = 1;
      //remove consumer token from queue and send it to the scoreboard
      tok_cons_remove_from_queue();
    end
  endtask : exec_cmd


  function bit check_valid_instr();
    bit valid;
    instr_src_t num_srcs;
    num_srcs= get_instr_num_srcs(curr_instr);

    valid = !(curr_instr.opcode == OPC_UNARY && curr_instr.src1 == FUNC_NOP);
    valid &= num_srcs >= SINGLE_INSTR_SRC && curr_instr.src0 inside {[i0 : i0_f24], [i1 : i1_f24], [pi0 : pi0_f24], [pi1 : pi1_f24], [a0 : a7], [b_c0 : b_c63]};
    valid &= num_srcs >= DUAL_INSTR_SRC   ? curr_instr.src1 inside {[i0 : i0_f24], [i1 : i1_f24], [pi0 : pi0_f24], [pi1 : pi1_f24], [a0 : a7], [b_c0 : b_c63]} : 1;
    valid &= num_srcs >= TRIPLE_INSTR_SRC ? curr_instr.src2 inside {[i0 : i0_f24], [i1 : i1_f24], [pi0 : pi0_f24], [pi1 : pi1_f24], [a0 : a7], [b_c0 : b_c63]} : 1;
    valid &= curr_instr.dst inside {[o : o_f24], [l : l_f24], [dst_a0 : dst_a7], [dst_b_c0 : dst_b_c63]};

    //specific dst restrictions
    valid &= curr_instr.opcode == OPC_UNARY && curr_instr.src1 inside {FUNC_MVCL, FUNC_MVCH, FUNC_CLMVCL, FUNC_CHMVCL, FUNC_CLMVCH, FUNC_CHMVCH, FUNC_MVCL64, FUNC_MVCH64} ? curr_instr.dst inside {[0: 63]} : 1;
    //TODO fix LUT_ADDR
    //valid &= curr_instr.opcode == OPC_UNARY && curr_instr.src1 inside {FUNC_MVLUT64} ? curr_instr.dst inside {[LUT_ADDR]}: 1;
    valid &= curr_instr.opcode == OPC_RFS && curr_instr.src2 inside {[FUNC_NEG: FUNC_MV], FUNC_SUB, FUNC_PRELU, FUNC_CMADD} ? curr_instr.dst inside {[o : o_f24], [l : l_f24]} : 1;
    valid &= curr_instr.opcode == OPC_RFS && curr_instr.src2 inside {FUNC_MUL, FUNC_ADD, FUNC_MAX, FUNC_MIN} ? curr_instr.dst inside {[o : o_f24], [l : l_f24], curr_instr.src1} : 1;
    valid &= curr_instr.opcode == OPC_MADD_RFS ? curr_instr.dst inside {[o : o_f24], [l : l_f24], curr_instr.src2} : 1;

    //specific src restrictions
    valid &= curr_instr.opcode inside {OPC_RFS,OPC_MADD_RFS} ? curr_instr.src0 inside {[i0 : i0_f24], [i1 : i1_f24]} : 1;
    valid &= curr_instr.opcode == OPC_RFS && curr_instr.src2 inside {FUNC_CLLUT, FUNC_CHLUT} ? curr_instr.src1 inside {[0 : 63]} : 1;
    //TODO fix LUT_ADDR
    //valid &= curr_instr.opcode == OPC_RFS && curr_instr.src2 == FUNC_DLUT ? curr_instr.src1 == LUT_ADDR : 1;
    valid &= curr_instr.opcode == OPC_UNARY && curr_instr.src1 inside {FUNC_CLMV, FUNC_CHMV, FUNC_CLMVCL, FUNC_CHMVCL, FUNC_CLMVCH, FUNC_CHMVCH} ? curr_instr.src0 inside {[0 : 63]} : 1;
    //TODO fix LUT_ADDR
    //valid &= curr_instr.opcode == OPC_LUT && curr_instr.src2 inside {FUNC_DLUT} ? curr_instr.src1 inside LUT_ADDR]};
    valid &= curr_instr.opcode == OPC_LUT && curr_instr.src2 inside {FUNC_CLLUT, FUNC_CHLUT, FUNC_MVCL} ? curr_instr.src1 inside {[0 : 63]} : 1;
    valid &= curr_instr.opcode inside {OPC_RFS,OPC_MADD_RFS} ? curr_instr.dst inside {[i0 : i0_f24], [i1 : i1_f24]} : 1;

    return valid;
  endfunction


  task exec_program();
    int curr_last_main_idx;
    bit [63:0] prog_mem_addr;
    wait (cmd_run == 1);
    if (curr_header.format == aic_dp_cmd_gen_pkg::Bypass) begin 
      curr_instr.opcode = OPC_MV;
      curr_instr.src0   = i0_bp;
      curr_instr.dst    = l_bp;

      issue_srcs();
      exec_instr();
      write_back();
      cmd_run = 0;
    end
    else begin
      ap_to_dp_cmd_model.write(ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_cmdb'(curr_cmd));
      `uvm_info("dpu_mdl", $sformatf("got dp_cmd from model: %p", curr_cmd), UVM_HIGH)
      //set current last main index to be used on the comparison on when is the last instruction of the program
      if(curr_cmd.format inside {[aic_dp_cmd_gen_pkg::LoopsM1N0:aic_dp_cmd_gen_pkg::LoopsM1N2]}) begin
        curr_last_main_idx = 0;
      end
      else if(curr_cmd.format inside {[aic_dp_cmd_gen_pkg::LoopsM2N0:aic_dp_cmd_gen_pkg::LoopsM2N2]}) begin
        curr_last_main_idx = 1;
      end
      else if(curr_cmd.format inside {[aic_dp_cmd_gen_pkg::LoopsM3N0:aic_dp_cmd_gen_pkg::LoopsM3N2]}) begin
        curr_last_main_idx = 2;
      end
      //while the command is running
      while (cmd_run) begin
        bit rfs_cmd;
        //check the size of the dp_command_q that is filled by the model output
        if(dp_command_q.size()) begin
          ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_command#(aic_dp_cmd_gen_pkg::dummy_dp_command_t) aux_dp_cmd;

          //load DP command which will have the address on "data" field
          aux_dp_cmd = dp_command_q.pop_front();
          prog_mem_addr = aux_dp_cmd.data;
          decode_dp_cmd(aux_dp_cmd);
          `uvm_info("dpu_mdl", $sformatf("exec_program address %0d", prog_mem_addr), UVM_HIGH)
          curr_instr = instr_q.pop_front();

          //prevents that only last instr w/ dst = PUSH-LAST in the LAST LOOP is executed in the entire program
          //just push otherwise
          if (curr_instr.dst inside {[l:l_f24]} && !(aux_dp_cmd.last)) begin
            `uvm_info("dpu_mdl", $sformatf("Instr w/ push-last dst and not last loop: downgrade to push dst"), UVM_HIGH)
            curr_instr.dst[4] = 0;
          end

          //NOP is treated as invalid op just because it does nothing
          if (check_valid_instr()) begin
            //get data stream if current instruction source = pop
            rfs_cmd = curr_instr.opcode inside {OPC_RFS, OPC_MADD_RFS};

            //get data from input stream, make the coversions and load the sources
            issue_srcs();

            //rfs set -> execute same instr using whole input stream
            if (rfs_cmd) begin
              int pw_len = stream_pword_len;
              bit push_cmd = curr_instr.dst inside {[o:l_f24]};
              
              //rfs cmd: convert opcode before executing
              if (curr_instr.opcode == OPC_MADD_RFS) curr_instr.opcode = OPC_MADD;
              else begin
                case (curr_instr.src2) inside
                  [FUNC_NEG : FUNC_SUMR]  : begin
                    curr_instr.opcode = OPC_UNARY;
                    curr_instr.src1   = curr_instr.src2;
                  end
                  [FUNC_LUT : FUNC_CHLUT] : curr_instr.opcode = OPC_LUT;
                  FUNC_MUL                : curr_instr.opcode = OPC_MUL;
                  FUNC_ADD                : curr_instr.opcode = OPC_ADD;
                  FUNC_SUB                : curr_instr.opcode = OPC_SUB;
                  FUNC_MAX                : curr_instr.opcode = OPC_MAX;
                  FUNC_MIN                : curr_instr.opcode = OPC_MIN;
                  FUNC_PRELU              : curr_instr.opcode = OPC_PRELU;
                  FUNC_CMADD              : curr_instr.opcode = OPC_CMADD;
                endcase
                if (curr_instr.src2 inside {[FUNC_MUL : FUNC_CMADD]})
                  curr_instr.src2 = 0;
                
              end
             

              for (int i = 1; i <= pw_len; i++) begin
                if (push_cmd) begin 
                  if (i == pw_len && aux_dp_cmd.last) 
                    curr_instr.dst[4] = 1;
                  else   //the input TLAST signal is always forwarded to output
                    curr_instr.dst[4] = 0;
                end
                exec_instr();
                write_back();
                `uvm_info("dpu_mdl", $sformatf("executed instr: %p", curr_instr), UVM_HIGH);
                foreach (dt_out_q[i])
                  `uvm_info("dpu_mdl", $sformatf("generated data[%0d] : %0h", i, dt_out_q[i]), UVM_HIGH);
                //last instr already executed, avoiding unecessary execution when i == pw_len 
                if (i < pw_len)
                  issue_srcs();
              end
            end
            else begin
              exec_instr();
              //write result from exec_instr() in registers or output
              write_back();
            end
          end //check_valid_instr
          else if (!(curr_instr.opcode == OPC_UNARY && curr_instr.src1 == FUNC_NOP)) begin
            `uvm_info("dpu_mdl", $sformatf("Invalid instruction: %p", curr_instr), UVM_HIGH)
            irq_control(err_id_illegal_instr);
          end
          else //NOP
            `uvm_info("dpu_mdl", "Executing instr NOP", UVM_HIGH)

          `uvm_info("dpu_mdl", $sformatf("overall_last: %0d | curr_last_main_idx: %0d | main_index: %0d | prog_mem_addr: %0d | end_addr: %0d", 
                                          aux_dp_cmd.overall_last, curr_last_main_idx, aux_dp_cmd.main_index, prog_mem_addr , 
                                          curr_cmd.get_end(1, aux_dp_cmd.main_index)), UVM_HIGH)

          if(aux_dp_cmd.overall_last && (curr_last_main_idx == aux_dp_cmd.main_index) && prog_mem_addr == curr_cmd.get_end(1, aux_dp_cmd.main_index) 
             && instr_q.size == 0) begin
            `uvm_info("dpu_mdl", $sformatf("Program done"), UVM_HIGH)
            cmd_run = 0;
          end
        end //dp_command_q.size
      end
    end
  endtask : exec_program


  //get the right data from IFDs according data format
  task issue_ifd_srcs(opcode_e op, operand_t source, output pw_dpu_fp_t dt);
    //number of data beats from stream to get all necessary data:
    //i32_64, i8_64 or bypass : 1 beat
    //f16_32 : 2 beats
    //f32_16 : 4 beats
    //rfs curr_instr: twice the number of beats above
    src_t src = src_t'(source);
    fp18_converted_t converted_dt;
    bit is_ifd0_peek = src inside {[pi0: pi0_f24]};
    bit is_ifd1_peek = src inside {[pi1: pi1_f24]};
    bit is_ifd0      = src inside {[i0:i0_f24]};
    bit [3:0] n_beats;
    bit [PWORD_SIZE-1:0][31:0] dt_aux;
    bit [PWORD_SIZE-1:0][7:0] dt_aux_i1;
    bit [2047:0] ad;
    bit [511:0] ad_i1;
    //special case that needs to receive double of streams in pword32 mode to make 64 pwords for mv64.
    bit mv64    = curr_instr.opcode == OPC_UNARY && curr_instr.src1 == FUNC_MV64;
    bit pword32 = curr_instr.vm;
    if (src inside {i0_i48, pi0_i48})
      n_beats = curr_instr.vm ? 1 : 2;
    else if (src inside {i0_f16, i1_f16, pi0_f16, pi1_f16})
      n_beats = curr_instr.vm ? 1 : 2;
    else if (src inside {i0_f24, i1_f24, pi0_f24, pi1_f24})
      n_beats = curr_instr.vm ? 2 : 3;
    else if (src inside {i0_f32, i1_f32, pi0_f32, pi1_f32})
      n_beats = curr_instr.vm ? 2 : 4;
    else
      n_beats = 1;

    if (mv64 && pword32) n_beats *= 2;

    `uvm_info("dpu_mdl", $sformatf("debug pw32: %b src: %0p n_beats: %0d, is_ifd0: %b ifd0_size: %0d, ifd1_size: %0d", curr_instr.vm, src.name, n_beats, 
               is_ifd0, s0_dt_stream_q.size, s1_dt_stream_q.size), UVM_HIGH)

    get_data_stream(is_ifd0 || is_ifd0_peek);
    //used in rfs instr, total of pwords and not stream data size
    stream_pword_len = (is_ifd0 || is_ifd0_peek ? s0_dt_stream_q.size() : s1_dt_stream_q.size()) / n_beats;
    if ((is_ifd0 || is_ifd0_peek) && s0_dt_stream_q.size < n_beats)
      irq_control(err_i0_termination);
    else if (!is_ifd0 && is_ifd1_peek && s1_dt_stream_q.size < n_beats)
      irq_control(err_i1_termination);
    else begin
      converted_dt = convert_input_stream(is_ifd0 || is_ifd0_peek, (is_ifd0 || is_ifd0_peek) ? s0_dt_stream_q : s1_dt_stream_q, src, pword32, mv64, n_beats);
    end

    if (is_ifd0 && !is_ifd0_peek && s0_dt_stream_q.size) begin
      repeat (n_beats) s0_dt_stream_q.delete(0);
    end
    else if (!is_ifd0 && !is_ifd1_peek && s1_dt_stream_q.size) begin
      repeat (n_beats) s1_dt_stream_q.delete(0);
    end

    `uvm_info("dpu_mdl", $sformatf("is_ifd0: %b, is_ifd0_peek: %b, is_ifd1_peek: %b, s0 stream size: %0d, s1: %0d", is_ifd0, is_ifd0_peek, is_ifd1_peek, 
                                   s0_dt_stream_q.size(), s1_dt_stream_q.size() ), UVM_HIGH)
    dt = converted_dt.packed_dt;
    `uvm_info("dpu_mdl", $sformatf("dt: %p", dt), UVM_HIGH)
  endtask

  function fp18_converted_t convert_input_stream(bit is_ifd0, bit [`SVT_AXI_MAX_TDATA_WIDTH-1:0] dt[$], src_t src_type, bit pw32, mv64, int n_beats);
    bit [2048*4-1 : 0]  dt_packed;
    bit [5:0][7:0] data_bytes;
    int pword_size;
    int byte_cnt;
    int max_pword_byte;
    int jump_byte;
    convert_type_t data_type;
    fp18_converted_t converted_dt;
    int num_data_bytes;
    int multi           = 8;
    int byte_pos        = 1;
    bit continuous_data = 1;
    bit sign            = 1;
    func_e func;
    int mask_size, mask_value;
    bit [1:0] offset_broadcast,loop_select;
  
    if (src_type inside {i0_f16, pi0_f16, i0_f24, pi0_f24, i0_f32, pi0_f32})
      continuous_data = 0;
    
    if (curr_instr.opcode == OPC_UNARY || curr_instr.opcode == OPC_MV) begin
      //func only used in opc_unary
      func       = func_e'(curr_instr.src1);
      mask_size  = curr_instr.src2;
      //mask_value only used in opc_mv
      mask_value = curr_instr.src1;
    end
    else if (curr_instr.opcode inside {[OPC_MUL : OPC_CMADD]}) begin
      offset_broadcast = curr_instr.src2[1:0];
      loop_select      = curr_instr.src2[3:2];
    end
    else
      func = func_e'(curr_instr.src2);
 
    if (!pw32 || mv64) pword_size = 64;
    else pword_size = 32;

    foreach (dt[i])
      `uvm_info("dpu_mdl", $sformatf("received stream data[%0d]: %0h", i,dt[i]), UVM_HIGH)
    foreach (dt[i]) begin
      if (src_type inside {[i0:pi0_f24]})
       dt_packed[i*2048 +: 2048] = dt[i];
      else if (src_type inside {[i1:pi1_f24]})
       dt_packed[i*512 +: 512] = dt[i];
    end
    `uvm_info("dpu_mdl", $sformatf("dt_packed: %0h", dt_packed), UVM_HIGH)

    case (src_type) inside
      i0, pi0: begin
        max_pword_byte = pw32 ? 6 : 4; 
        data_type      = pw32 ? INT_48 : INT_32; 
        sign           = dp_ctrl.i0_int_sgn;
      end  
      i1, pi1: begin
        max_pword_byte = pw32 ? 2 : 1; 
        data_type      = pw32 ? INT_16 : INT_8; 
        sign           = dp_ctrl.i1_int_sgn;
      end  
      i0_f16, pi0_f16, i0_f24, pi0_f24, i0_f32, pi0_f32: begin
        if (pw32)
          max_pword_byte = src_type inside {i0_f16, pi0_f16} ? 1 : 2;  
        else 
           max_pword_byte = src_type inside {i0_f16, pi0_f16} ? 2 : (src_type inside {i0_f24, pi0_f24} ? 3 : 4);  
        data_type = src_type inside {i0_f16, pi0_f16} ? FP_16 : (src_type inside {i0_f24, pi0_f24} ? FP_24 : FP_32); 
        multi     = pw32 ? 64 : 32;
      end  
      i1_f16, pi1_f16, i1_f24, pi1_f24, i1_f32, pi1_f32: begin
        if (pw32)
          max_pword_byte = src_type inside {i1_f16, pi1_f16} ? 1 : 2;  
        else
          max_pword_byte = src_type inside {i1_f16, pi1_f16} ? 2 : (src_type inside {i1_f24, pi1_f24} ? 3 : 4);  
        
        data_type = src_type inside {i1_f16, pi1_f16} ? FP_16 : (src_type inside {i1_f24, pi1_f24} ? FP_24 : FP_32); 
      end  
    endcase
             
    `uvm_info("dpu_mdl", $sformatf("src_type: %s, max_pword_byte: %0d, data_type: %s, multi: %0d", src_type.name, max_pword_byte, data_type.name, multi), UVM_HIGH)
    num_data_bytes = (src_type == i0 && pw32) ? pword_size * multi * 8 : pword_size * multi * max_pword_byte;
    if (src_type inside {i0_bp, pi0_bp, i1_bp, pi1_bp}) begin
      for (int i = 0; i < pword_size; i++) begin
        if (src_type inside {i0_bp, pi0_bp}) begin
          if (!pw32)
            converted_dt.packed_dt[i] = dt_packed[i * 32 +: 8];
          else
            converted_dt.packed_dt[i] = dt_packed[i * 32 +: 16];
        end 
        else begin
          if (!pw32)
            converted_dt.packed_dt[i] = dt_packed[i * 8 +: 8];
          else
            converted_dt.packed_dt[i] = dt_packed[i * 16 +: 16];
        end
        cvg_in_data.sample(src_type, curr_instr.opcode, func, converted_dt.packed_dt[i], mask_value, mask_size, offset_broadcast, loop_select, pw32);
      end
    end
    else begin 
      for (int i = 0, j = 0; i < num_data_bytes; i+=8) begin  
        int next_byte_idx;
        int jump_byte_idx;

        if (!continuous_data) begin
          if (pw32) begin
            next_byte_idx = 48;
            jump_byte_idx = 2;
          end  
          else begin
            next_byte_idx = 24;
            jump_byte_idx = 1;
          end
        end
        else if (src_type == i0 && pw32) begin
          next_byte_idx = 16;
          jump_byte_idx = 6;
        end

        data_bytes[byte_cnt++] = dt_packed[i +: 8];
        jump_byte++;
        if (jump_byte == jump_byte_idx) begin
          i += next_byte_idx;
          jump_byte = 0;
        end
        if (byte_cnt == max_pword_byte) begin
          bit [47:0] data = data_bytes;
          fp_t fp         = c_fp.convert(data, data_type, FP_18, sign);
       
          for (bit [6:0] k = 0; k < pword_size; k++)
            cvg_in_data.sample(src_type, curr_instr.opcode, func, data, mask_value, mask_size, offset_broadcast, loop_select, pw32);

          converted_dt.packed_dt[j] = fp.out_res[17:0];
          converted_dt.overflow    |= fp.overflow;
          converted_dt.underflow   |= fp.underflow;
          converted_dt.round_error |= fp.round_error;
          `uvm_info("dpu_mdl", $sformatf("dt[%0d]: %0h, converted fp18: <%0h, %0h, %0h>", j, data, fp.out_res[17], fp.out_res[16:10], fp.out_res[9:0]), UVM_HIGH)
          byte_cnt   = 0;
          data_bytes = 'h0;
          j++; 
          if (j == pword_size) break;
        end 
      end

      case (src_type) inside
        i0, pi0: begin
          if (converted_dt.underflow)
            irq_control(err_i0_uf);
          if (converted_dt.overflow)
            irq_control(err_i0_of);
          if (converted_dt.round_error)
            irq_control(err_i0_nx);
        end
        i1, pi1: begin
          if (converted_dt.underflow)
            irq_control(err_i1_uf);
          if (converted_dt.overflow)
            irq_control(err_i1_of);
          if (converted_dt.round_error)
            irq_control(err_i1_nx);
        end
      endcase
    end
    return converted_dt;
  endfunction

  //get the right data before execution
  task issue_srcs();
    bit s0_ifd0 = curr_instr.src0 inside {[i0:pi0_f24]};
    bit s1_ifd0 = curr_instr.src1 inside {[i0:pi0_f24]};
    bit s2_ifd0 = curr_instr.src2 inside {[i0:pi0_f24]};

    bit s0_ifd1 = curr_instr.src0 inside {[i1:pi1_f24]};
    bit s1_ifd1 = curr_instr.src1 inside {[i1:pi1_f24]};
    bit s2_ifd1 = curr_instr.src2 inside {[i1:pi1_f24]};

    bit s0_a = curr_instr.src0 inside {[a0:a7]};
    bit s1_a = curr_instr.src1 inside {[a0:a7]};
    bit s2_a = curr_instr.src2 inside {[a0:a7]};

    bit s1_same_s0       = curr_instr.src0 == curr_instr.src1;
    bit s2_same_s0       = curr_instr.src2 == curr_instr.src0;
    bit s2_same_s1       = curr_instr.src2 == curr_instr.src1;


    instr_src_t num_srcs = get_instr_num_srcs(curr_instr);

    if (num_srcs >= SINGLE_INSTR_SRC) begin
      bit s0_c_src = curr_instr.opcode == OPC_UNARY && curr_instr.src1 inside {[FUNC_CLMV:FUNC_CHMVCH]};
      bit s0_cl_src = s0_c_src && curr_instr.src1 inside {FUNC_CLMV, FUNC_CLMVCL, FUNC_CLMVCH};
      if (s0_ifd0 || s0_ifd1) 
        issue_ifd_srcs(curr_instr.opcode, curr_instr.src0, dt_src0);
      else if (s0_a)
        dt_src0 = a_reg[curr_instr.src0 - A_REG_OFFSET];
      else if (s0_c_src) begin
        //lower part of c reg
        if (s0_cl_src)
          dt_src0 = c_reg[0][curr_instr.src0-B_C_REG_OFFSET];
        //higher part of c reg
        else
          dt_src0 = c_reg[1][curr_instr.src0-B_C_REG_OFFSET];
      end
      else
        dt_src0 = b_reg[curr_instr.src0 - B_C_REG_OFFSET];
    end
    if (num_srcs >= DUAL_INSTR_SRC) begin
      //broadcast enabled
      if ( curr_instr.opcode inside {[OPC_MUL:OPC_CMADD]} && curr_instr.src2[0] && !(s1_ifd0 || s1_ifd1)) begin
        foreach (dt_src1[0][i])
          dt_src1[0][i] = s1_a ? a_reg[curr_instr.src1 - A_REG_OFFSET][curr_instr.src2[6:2]] : b_reg[curr_instr.src1 - B_C_REG_OFFSET][curr_instr.src2[6:2]];  
      end
      else if ( curr_instr.opcode == OPC_LUT && curr_instr.src2 inside {[FUNC_DLUT : FUNC_CHLUT]} ||
                curr_instr.opcode == OPC_RFS && curr_instr.src2 inside {[FUNC_DLUT : FUNC_CHLUT]} ) begin
        case (curr_instr.src2)
          FUNC_DLUT  : dt_src1[0] = lut_reg;
          FUNC_CLLUT : dt_src1[0] = c_reg[0][curr_instr.src1 - B_C_REG_OFFSET];
          FUNC_CHLUT : dt_src1[0] = c_reg[0][curr_instr.src1 - B_C_REG_OFFSET];
        endcase
      end
      else if (curr_instr.opcode == OPC_CMADD) begin
        dt_src1[0] = c_reg[0][curr_instr.src1 - B_C_REG_OFFSET];
        dt_src1[1] = c_reg[1][curr_instr.src1 - B_C_REG_OFFSET];
      end
      else if (s1_same_s0)
        dt_src1[0] = dt_src0;
      else if (s1_ifd0 || s1_ifd1)
        issue_ifd_srcs(curr_instr.opcode, curr_instr.src1, dt_src1[0]);
      else if (s1_a)
        dt_src1[0] = a_reg[curr_instr.src1 - A_REG_OFFSET];
      else
        dt_src1[0] = b_reg[curr_instr.src1 - B_C_REG_OFFSET];
    end

    if (num_srcs == TRIPLE_INSTR_SRC) begin
      if (s2_same_s0)
        dt_src2 = dt_src0;
      else if (s2_same_s1)
        dt_src2 = dt_src1[0];
      else if (s2_ifd0 || s2_ifd1)
        issue_ifd_srcs(curr_instr.opcode, curr_instr.src2, dt_src2);
      else if (s2_a)
        dt_src2 = a_reg[curr_instr.src2 - A_REG_OFFSET];
      else
        dt_src2 = b_reg[curr_instr.src2 - B_C_REG_OFFSET];
    end
  endtask : issue_srcs


  function void get_mask_size(int masked[2]);
    masked[0] = 0;
    masked[1] = 0;
    if (curr_instr.opcode == OPC_UNARY && curr_instr.src1 inside {[FUNC_MVCL: FUNC_SUMR]} || curr_instr.opcode == OPC_MV) begin
      int mask_size = $signed(curr_instr.src2);
      if (mask_size > 63 || mask_size < -64) `uvm_error("dpu_mdl", $sformatf("Invalid mask_size value: %0d, exp: [-64:63]", mask_size))
      else if (mask_size > 0) begin
        masked[0] = mask_size;
        masked[1] = PWORD_SIZE;
      end
      else if (mask_size < 0 )begin
        masked[0] = 0;
        masked[1] = PWORD_SIZE + mask_size; 
      end
    end
  endfunction


  //execute the IAU operations
  task automatic exec_instr();
    int masked_idx[2];
    bit masked_op;
    real r_dt0, r_dt1, r_dt2, r_res;
    int pw_size = curr_instr.vm && !(curr_instr.opcode == OPC_UNARY && curr_instr.src1 inside {[FUNC_MV64:FUNC_MVLUT64]}) ? 32 : 64;
    string dp_str = $sformatf("in0_sign: %0b , in1_sign: %0b, out_sign: %0b", dp_ctrl.i0_int_sgn, dp_ctrl.i1_int_sgn, dp_ctrl.out_int_sgn);
    
    src_t src0    = curr_instr.src0.raw;
    src_t src1    = curr_instr.src1.raw;
    src_t src2    = curr_instr.src2.raw;
    dst_t dst     = curr_instr.dst.raw;
    func_e func   = curr_instr.opcode == OPC_UNARY ? curr_instr.src1.raw : curr_instr.src2.raw;
    if (curr_instr.opcode == OPC_UNARY)
      `uvm_info("dpu_mdl", $sformatf("Executing instruction: OPC_UNARY func: %s src0: %s dst: %s vm: %b, mask_size: %0d %s",
                          func.name, src0.name, dst.name, curr_instr.vm, curr_instr.src2, dp_str), UVM_HIGH)
    else if (curr_instr.opcode == OPC_MV)
      `uvm_info("dpu_mdl", $sformatf("Executing instruction: OPC_MV mask_value_sel: %0d src0: %s dst: %s vm: %b, mask_size: %0d %s",
                          curr_instr.src1, src0.name, dst.name, curr_instr.vm, curr_instr.src2, dp_str), UVM_HIGH)
    else if (curr_instr.opcode == OPC_LUT)
      `uvm_info("dpu_mdl", $sformatf("Executing instruction: OPC_LUT func.name: %s src1: %s src0: %s dst: %s vm: %b %s",
                           func.name, src1.name, src0.name, dst.name, curr_instr.vm, dp_str), UVM_HIGH)
    else if (curr_instr.opcode == OPC_RFS)
      `uvm_info("dpu_mdl", $sformatf("Executing instruction: OPC_RFS func.name: %s src1: %s src0: %s dst: %s vm: %b %s",
                           func.name, src1.name, src0.name, dst.name, curr_instr.vm, dp_str), UVM_HIGH)
    else if (curr_instr.opcode inside {[OPC_MUL : OPC_CMADD]}) begin
      string str = curr_instr.src2[1:0] == 3 ? "broadcast en = 1" : (curr_instr.src2[1:0] == 1 ? "offset en = 1" : "offset/broadcast en = 0");
      `uvm_info("dpu_mdl", $sformatf("Executing instruction: %s src1: %s src0: %s dst: %s vm: %b, %s off/br_ctrl: %0d %s", curr_instr.opcode.name,
                           src1.name, src0.name, dst.name, curr_instr.vm, str, curr_instr.src2[3:2], dp_str), UVM_HIGH)
    end
    else
      `uvm_info("dpu_mdl", $sformatf("Executing instruction: %s src2: %s src1: %s src0: %s dst: %s vm: %b %s", curr_instr.opcode.name,
                           src2.name, src1.name, src0.name, dst.name, curr_instr.vm, dp_str), UVM_HIGH)
    
    dt_res = 0;
    //changes pwsize value if operation has mask_size
    get_mask_size(masked_idx);
    masked_op = masked_idx[0] || masked_idx[1];
    for (int i = 0; i < pw_size; i++) begin
      bit in_masked_region = masked_op && i inside {[masked_idx[0] : masked_idx[1]]}; 
      case (curr_instr.opcode) inside
        OPC_UNARY : begin
          case (curr_instr.src1) inside
            [FUNC_MVCL : FUNC_MVLUT64] : begin
              if (in_masked_region) dt_res[i] = DPU_FP_ZERO;
              else                   dt_res[i] = dt_src0[i];
            end
            FUNC_NEG : begin
              if (in_masked_region) dt_res[i] = DPU_FP_ZERO;
              else begin
                dt_src0[i].sign = ~dt_src0[i].sign;
                dt_res[i]       = dt_src0[i];
              end
            end
            [FUNC_RECIP : FUNC_SUMR] : begin
              r_dt0 = c_fp.convert_float18_to_real(dt_src0[i]);
              r_res = r_dt0;

              if      (curr_instr.src1 == FUNC_RECIP ) r_res = in_masked_region ? DPU_FP_ZERO : 1.0 / r_dt0;
              else if (curr_instr.src1 == FUNC_RSQRT ) r_res = in_masked_region ? DPU_FP_ZERO : 1.0 / $sqrt(r_dt0);
              else if (curr_instr.src1 == FUNC_SQRT  ) r_res = in_masked_region ? DPU_FP_ZERO : $sqrt(r_dt0);
              else if (curr_instr.src1 == FUNC_SIN   ) r_res = in_masked_region ? DPU_FP_ZERO : $sin(r_dt0);
              else if (curr_instr.src1 == FUNC_COS   ) r_res = in_masked_region ? DPU_FP_ZERO : $cos(r_dt0);
              else if (curr_instr.src1 == FUNC_LOG2  ) r_res = in_masked_region ? DPU_FP_ZERO : $clog2(int'(r_dt0));
              else if (curr_instr.src1 == FUNC_EXP2  ) r_res = in_masked_region ? DPU_FP_ZERO : 2**r_dt0;
              else if (curr_instr.src1 == FUNC_MAXR  ) r_res = in_masked_region ? DPU_FP_ZERO : r_dt0 > r_res ?  r_dt0 : r_res;
              else if (curr_instr.src1 == FUNC_MINR  ) r_res = in_masked_region ? DPU_FP_ZERO : r_dt0 < r_res ?  r_dt0 : r_res;
              else if (curr_instr.src1 == FUNC_SUMR  ) r_res = in_masked_region ? DPU_FP_ZERO : r_res + r_dt0;

              if (curr_instr.src1 inside {[FUNC_MAXR : FUNC_SUMR]}) begin
                dt_res[0] = c_fp.convert_real_to_float18(r_res);
                foreach (dt_res[i])
                  dt_res[i] = dt_res[0];
              end
              else
                dt_res[i] = c_fp.convert_real_to_float18(r_res);
              `uvm_info("dpu_mdl", $sformatf("debug [%0d] op: %s, r_data0: %.30f r_res: %.30f dt_res: {%0h,%0h,%0h}", i, func.name, r_dt0, r_res,
                         dt_res[0][17], dt_res[0][16:10], dt_res[0][9:0]), UVM_HIGH)
            end
          endcase
        end

        OPC_MV : begin
          //if masked, return mask_value_sel inside src1
          dt_res[i] = in_masked_region ? curr_instr.src1 : dt_src0[i];
        end

        //OPC_RFS, OPC_MADD_RFS -> treated in exec_program()
        OPC_MUL, OPC_ADD, OPC_SUB : begin
          r_dt0 = c_fp.convert_float18_to_real(dt_src0[i]);
          r_dt1 = c_fp.convert_float18_to_real(dt_src1[0][i]);

          if (curr_instr.opcode == OPC_MUL)
            r_res = r_dt0 * r_dt1;
          else if (curr_instr.opcode == OPC_ADD)
            r_res = r_dt0 + r_dt1;
          else
            r_res = r_dt0 - r_dt1;
          dt_res[i] = c_fp.convert_real_to_float18(r_res);
          `uvm_info("dpu_mdl", $sformatf("debug [%0d] op: %p, r_dt0: %.30f <%0h,%0h,%0h> r_dt1: %.30f <%0h,%0h,%0h>, r_res: %.30f / {%0h,%0h,%0h}",
                      i, curr_instr.opcode, r_dt0, dt_src0[i][17], dt_src0[i][16:10], dt_src0[i][9:0],
                      r_dt1, dt_src1[0][i][17], dt_src1[0][i][16:10], dt_src1[0][i][9:0],
                      r_res, dt_res[i][17], dt_res[i][16:10], dt_res[i][9:0]), UVM_HIGH)

        end

        OPC_MAX, OPC_MIN: begin
          r_dt0 = c_fp.convert_float18_to_real(dt_src0[i]);
          r_dt1 = c_fp.convert_float18_to_real(dt_src1[0][i]);
          if (curr_instr.opcode == OPC_MAX)
            r_res = r_dt0 > r_dt1 ? r_dt0 : r_dt1;
          else 
            r_res = r_dt0 < r_dt1 ? r_dt0 : r_dt1;
          //special case when compare srcs with 0 and -0, should return -0
          if (r_res == 0.0 && (dt_src0[i] == 'h2_0000 || dt_src1[0][i] == 'h2_0000))
            dt_res[i] = 'h2_0000;
          else
            dt_res[i] = c_fp.convert_real_to_float18(r_res);
          `uvm_info("dpu_mdl", $sformatf("debug [%0d] op %p, data 0: %0h real: %.30f | data 1: %0h real: %.30f | res real: %.30f, dt_res fp18: %0h",
              i, curr_instr.opcode, dt_src0[i], r_dt0, dt_src1[0][i], r_dt1, r_res, dt_res[i] ), UVM_HIGH)
        end

        OPC_PRELU: begin
          r_dt0 = c_fp.convert_float18_to_real(dt_src0[i]);
          r_dt1 = c_fp.convert_float18_to_real(dt_src1[0][i]);
          if (r_dt0 < 0) r_res = r_dt0 * r_dt1;
          else r_res = r_dt0;
          //special case when compare srcs with 0 and -0, should return -0
          if (r_res == 0.0 && (dt_src0[i] == 'h2_0000 || dt_src1[0][i] == 'h2_0000))
            dt_res[i] = 'h2_0000;
          else
            dt_res[i] = c_fp.convert_real_to_float18(r_res);
          `uvm_info("dpu_mdl", $sformatf("debug [%0d] op: %p, r_dt0: %.30f <%0h,%0h,%0h> r_dt1: %.30f <%0h,%0h,%0h>, r_res: %.30f / {%0h,%0h,%0h}",
                      i, curr_instr.opcode, r_dt0, dt_src0[i][17], dt_src0[i][16:10], dt_src0[i][9:0],
                      r_dt1, dt_src1[0][i][17], dt_src1[0][i][16:10], dt_src1[0][i][9:0],
                      r_res, dt_res[i][17], dt_res[i][16:10], dt_res[i][9:0]), UVM_HIGH)
        end

        OPC_MADD, OPC_CMADD: begin
          r_dt0 = c_fp.convert_float18_to_real(dt_src0[i]);
          r_dt1 = c_fp.convert_float18_to_real(dt_src1[0][i]);
          if (curr_instr.opcode == OPC_MADD)
            r_dt2 = c_fp.convert_float18_to_real(dt_src2[i]);
          else
            r_dt2 = c_fp.convert_float18_to_real(dt_src1[1][i]);
          r_res = r_dt0 * r_dt1 + r_dt2;
//        TODO: check this interruption
//          if (r_res > f18_max) irq[ERR_MADD_OP_OF] = 1;
//          else if (r_res < f18_min) irq[ERR_MADD_OP_UF] = 1;
          dt_res[i] = c_fp.convert_real_to_float18(r_res);
        end

      endcase
    end

    if (curr_instr.opcode == OPC_LUT || curr_instr.opcode == OPC_UNARY && curr_instr.src1 inside {[FUNC_LUT : FUNC_CHLUT]}) begin
      //internal dpu depacking f18x64 to f18x16x4
      //bit [15:0] [17:0] [3:0] f18_64_4_dt = dt_src1[0];
      bit [16:0] [17:0] arr_bin = dt_src1[0][15:0 ];
      bit [16:0] [17:0] arr_scl = dt_src1[0][31:16];
      bit [16:0] [17:0] arr_off = dt_src1[0][47:32];
      bit [17:0] lo_bnd         = dt_src1[0][50];
      bit [17:0] lo_off         = dt_src1[0][51];
      bit [17:0] hi_bnd         = dt_src1[0][52];
      bit [17:0] hi_off         = dt_src1[0][53];
      bit [17:0] version        = dt_src1[0][63];
      bit new_lut               = version == DPU_FP_ONE;

      //new lut, 17th bin (starts with 0),scale and offset
      arr_scl[16]  = new_lut ? dt_src1[0][48] : 0; 
      arr_off[16]  = new_lut ? dt_src1[0][49] : 0;
      if (!new_lut) arr_bin[16] = 0;

      foreach(arr_bin[i])
        `uvm_info("dpu_mdl", $sformatf("debug lut op, new_version: %0b,[%0d] arr_bin: {%0h, %0h, %0h}, scl : {%0h, %0h, %0h}, off: {%0h, %0h, %0h}", 
                     new_lut, i,
                     arr_bin[i][17], arr_bin[i][16:10], arr_bin[i][9:0],
                     arr_scl[i][17], arr_scl[i][16:10], arr_scl[i][9:0],
                     arr_off[i][17], arr_off[i][16:10], arr_off[i][9:0]), UVM_HIGH)

      for (int i = 0; i < pw_size; i++) begin
        int idx = -1;
        int bin_size = $size(arr_bin);
        for (int j = 0; j < bin_size; j++) begin
          if (new_lut) begin
            if (c_fp.convert_float18_to_real(dt_src0[i]) < c_fp.convert_float18_to_real(lo_bnd)) begin
              r_res = c_fp.convert_float18_to_real(lo_off);
              break;
            end
            else if (c_fp.convert_float18_to_real(dt_src0[i]) >= c_fp.convert_float18_to_real(hi_bnd)) begin
              r_res = c_fp.convert_float18_to_real(hi_off);
              break;
            end
            else if (c_fp.convert_float18_to_real(dt_src0[i]) < c_fp.convert_float18_to_real(arr_bin[j])) begin
              idx = j;
              //get first index that meets condition
              break;
            end
          end
          else begin
            if (c_fp.convert_float18_to_real(dt_src0[i]) < c_fp.convert_float18_to_real(arr_bin[j])) begin
              idx = j;
              //get first index that meets condition
              break;
            end
          end
        end

        if (idx >= 0) begin

          r_dt0 = c_fp.convert_float18_to_real(dt_src0[i]);
          r_dt1 = c_fp.convert_float18_to_real(arr_scl[idx]);
          r_dt2 = c_fp.convert_float18_to_real(arr_off[idx]);

          r_res = r_dt0 * r_dt1 + r_dt2;
          dt_res[i] = c_fp.convert_real_to_float18(r_res);
          `uvm_info("dpu_mdl", $sformatf("debug lut,[%0d] rdt_0: %.30f {%0h, %0h, %0h}, idx: %0d, r_dt1: %.30f {%0h, %0h, %0h} r_dt2: %.30f {%0h, %0h, %0h}, res: %.30f {%0h, %0h, %0h}",
                                         i, r_dt0, dt_src0[i][17], dt_src0[i][16:10], dt_src0[i][9:0], idx,
                                         r_dt1, arr_scl[idx][17], arr_scl[idx][16:10], arr_scl[idx][9:0],
                                         r_dt2, arr_off[idx][17], arr_off[idx][16:10], arr_off[idx][9:0],
                                         r_res, dt_res[i][17], dt_res[i][16:10], dt_res[i][9:0]), UVM_HIGH)
        end
        else begin
          if (new_lut) begin
            r_dt1 = c_fp.convert_float18_to_real(arr_scl[16]);
            r_dt2 = c_fp.convert_float18_to_real(arr_off[16]);
            r_res = r_res * r_dt1 + r_dt2;
            dt_res[i] = c_fp.convert_real_to_float18(r_res);
          end
          else
            dt_res[i] = 0;
        end
      end
    end

  endtask : exec_instr


  //write result into registers or output
  function void write_back();
    bit of,uf,nx;
    dpu_fp_t deb;
    dst_t dst = dst_t'(curr_instr.dst);
    `uvm_info("dpu_mdl", $sformatf("Writing data res %0h, to dest: %s", dt_res, dst.name), UVM_HIGH)

    if (curr_instr.opcode == OPC_UNARY && curr_instr.src1 inside {FUNC_MVCL, FUNC_MVCH, [FUNC_CLMVCL:FUNC_CHMVCH], [FUNC_MVCL64:FUNC_MVLUT64]}) begin
      case (curr_instr.src1) inside
        FUNC_MVCL, FUNC_CLMVCL, FUNC_CHMVCL: begin
          c_reg[0][curr_instr.dst-B_C_REG_OFFSET] = dt_res;
        end
        FUNC_MVCL64 :
          c_reg[0][0] = dt_res;
        FUNC_MVCH, FUNC_CHMVCH, FUNC_CLMVCH: 
          c_reg[1][curr_instr.dst-B_C_REG_OFFSET] = dt_res;
        FUNC_MVCH64 :
          c_reg[1][0] = dt_res;
        FUNC_MVLUT64 : 
          lut_reg = dt_res;
      endcase
    end
    else if (curr_instr.dst inside {[dst_a0:dst_a7]})
      a_reg[curr_instr.dst - A_REG_OFFSET] = dt_res;
    else if (curr_instr.dst inside {[dst_b_c0:dst_b_c63]})
      b_reg[curr_instr.dst - B_C_REG_OFFSET] = dt_res;
    else if (curr_instr.dst inside {[o:l_bp]}) begin
      int pwsize = curr_instr.vm ? 32 : 64;
      //convert data from 18_64 to data format defined in dst field

      //pword32 behavior
      if (curr_instr.vm && curr_instr.dst inside {o,l}) curr_instr.dst = curr_instr.dst == o ? o_i16 : l_i16;

      case (curr_instr.dst) inside
        o, l         : begin
          int8_converted_t converted_dt = c_fp.convert_pword_f18_to_int8(dt_res, dp_ctrl.out_int_sgn);
          of = converted_dt.overflow;
          uf = converted_dt.underflow;
          nx = converted_dt.round_error;

          for (bit [6:0] k = 0; k < pwsize; k++)
            cvg_out_data.sample(dst_t'(curr_instr.dst), curr_instr.opcode, curr_instr.vm, converted_dt.packed_dt[k]);
          dt_out_q.push_back(converted_dt.packed_dt);

          `uvm_info("dpu_mdl", $sformatf("Push output data int: %h", dt_out_q[$]), UVM_FULL)
        end
        o_f16, l_f16 : begin
          fp16_converted_t converted_dt = c_fp.convert_pword_f18_to_f16(dt_res, 1);
          bit [1023:0] dt = converted_dt.packed_dt;
          of = converted_dt.overflow;
          uf = converted_dt.underflow;
          nx = converted_dt.round_error;

          for (bit [6:0] k = 0; k < pwsize; k++)
            cvg_out_data.sample(dst_t'(curr_instr.dst), curr_instr.opcode, curr_instr.vm,  converted_dt.packed_dt[k]);

          for (int i = 0; i < 1024; i+=512) begin
            dt_out_q.push_back(dt[i +: 512]);
            `uvm_info("dpu_mdl", $sformatf("Push output data float16: %h", dt[i +: 512]), UVM_FULL)
          end
        end
        o_f32, l_f32 : begin
          fp32_converted_t converted_dt = c_fp.convert_pword_f18_to_f32(dt_res, 1);
          bit [2047:0] dt = converted_dt.packed_dt;
          of = converted_dt.overflow;
          uf = converted_dt.underflow;
          nx = converted_dt.round_error;

          for (bit [6:0] k = 0; k < pwsize; k++)
            cvg_out_data.sample(dst_t'(curr_instr.dst), curr_instr.opcode, curr_instr.vm,  converted_dt.packed_dt[k]);

          for (int i =0; i < 2048; i+=512) begin
            dt_out_q.push_back(dt[i +: 512]);
            `uvm_info("dpu_mdl", $sformatf("Push output data float32: %h", dt[i +: 512]), UVM_FULL)
          end
        end
        o_bp, l_bp   : begin
          //TODO confirm if rtl implements bypass like this
          if (curr_instr.vm) begin
            dt_out_q.push_back( c_fp.convert_pword_f18_to_int16_bp(dt_res));
            for (bit [6:0] k = 0; k < pwsize; k++)
              cvg_out_data.sample(dst_t'(curr_instr.dst), curr_instr.opcode, curr_instr.vm,  dt_out_q[$][k*16 +: 16]);
          end
          else begin
            dt_out_q.push_back( c_fp.convert_pword_f18_to_int8_bp(dt_res));
            for (bit [6:0] k = 0; k < pwsize; k++)
              cvg_out_data.sample(dst_t'(curr_instr.dst), curr_instr.opcode, curr_instr.vm,  dt_out_q[$][k*8 +: 8]);
          end
          `uvm_info("dpu_mdl", $sformatf("Push output data bypass: %h", dt_out_q[$]), UVM_FULL)
        end

        o_i16, l_i16 : begin
          int16_converted_t converted_dt = c_fp.convert_pword_f18_to_int16(dt_res, dp_ctrl.out_int_sgn);
          of = converted_dt.overflow;
          uf = converted_dt.underflow;
          nx = converted_dt.round_error;

          for (bit [6:0] k = 0; k < pwsize; k++)
            cvg_out_data.sample(dst_t'(curr_instr.dst), curr_instr.opcode, curr_instr.vm,  converted_dt.packed_dt[k]);
          dt_out_q.push_back(converted_dt.packed_dt);

          `uvm_info("dpu_mdl", $sformatf("Push output data int16: %h", dt_out_q[$]), UVM_FULL)

        end

        o_f24, l_f24: begin
          fp24_converted_t converted_dt = c_fp.convert_pword_f18_to_f24(dt_res, 1);
          bit [1535:0] dt = converted_dt.packed_dt;
          of = converted_dt.overflow;
          uf = converted_dt.underflow;
          nx = converted_dt.round_error;

          for (bit [6:0] k = 0; k < pwsize; k++)
            cvg_out_data.sample(dst_t'(curr_instr.dst), curr_instr.opcode, curr_instr.vm,  converted_dt.packed_dt[k]);

          for (int i = 0; i < 1536; i+=512) begin
            dt_out_q.push_back(dt[i +: 512]);
            `uvm_info("dpu_mdl", $sformatf("Push output data float24: %h", dt[i +: 512]), UVM_FULL)
          end
        end
      endcase

      //push last output
      if (curr_instr.dst inside {[l:l_f24]}) begin
        data_out_item = new();
        data_out_item.tdata = new[dt_out_q.size()];
        foreach (dt_out_q[i]) begin
          data_out_item.tdata[i] = dt_out_q[i];
        end
        dt_out_q.delete();
        `uvm_info("dpu_mdl", $sformatf("Push-last output data stream, tdata size: %0d", data_out_item.tdata.size()), UVM_HIGH)
        foreach (data_out_item.tdata[i]) `uvm_info("dpu_mdl", $sformatf("dt_out[%0d] : %0h", i, data_out_item.tdata[i]), UVM_FULL);
        ap_stream_out.write(data_out_item);
      end
    end

    if (of)      irq_control(err_o_of);
    else if (uf) irq_control(err_o_uf);
    else if (nx) irq_control(err_o_nx);
  endfunction


  //upon a instruction data request, if no data available in queue
  //wait for a new data stream to continue executing
  task get_data_stream(bit is_ifd0);

    if (!is_ifd0 && s1_dt_stream_q.size == 0) begin
      `uvm_info("dpu_mdl", $sformatf("Waiting Input Data from IFD1"),UVM_HIGH)
      taf_mon_s1_data.get(s1_data_item);
      s1_dt_stream_q = s1_data_item.tdata;
    end
    else if (is_ifd0 && s0_dt_stream_q.size == 0) begin
      `uvm_info("dpu_mdl", $sformatf("Waiting Input Data from IFD0"),UVM_HIGH)
      taf_mon_s0_data.get(s0_data_item);
      s0_dt_stream_q = s0_data_item.tdata;
    end
  endtask



// *********************************************
// *********************************************
// Token related functions
// *********************************************

  //function to add to tok_cons_q queue the token new token information
  function void tok_cons_add_to_queue(dpu_cmd_header_t p_header);
    token_agent_seq_item l_tok_item;

    l_tok_item = token_agent_seq_item::type_id::create("l_tok_item", this);

    //check into the data if the consumer token bit is active or not
    if(p_header.token_cons==1) begin
      l_tok_item.m_type_enm = TOK_CONS_MON;
    end
    else begin
      l_tok_item.m_type_enm = TOK_NOT_VALID;
    end
    //push the new token to the queue
    tok_cons_q.push_back(l_tok_item);
  endfunction : tok_cons_add_to_queue

  //function to add to tok_prod_q queue the token new token information
  function void tok_prod_add_to_queue(dpu_cmd_header_t p_header);
   token_agent_seq_item l_tok_item;

    l_tok_item = token_agent_seq_item::type_id::create("l_tok_item", this);

    //check into the data if the producer token bit is active or not
    if(p_header.token_prod==1) begin
      l_tok_item.m_type_enm = TOK_PROD_MON;
    end
    else begin
      l_tok_item.m_type_enm = TOK_NOT_VALID;
    end
    //push the new token to the queue
    tok_prod_q.push_back(l_tok_item);
  endfunction : tok_prod_add_to_queue

  //function to remove from tok_cons_q queue the token and send to the scoreboard if it is a valid token
  function void tok_cons_remove_from_queue();
    token_agent_seq_item l_tok_item;
    if(tok_cons_q.size() > 0) begin
      l_tok_item = tok_cons_q.pop_front();
      if(l_tok_item.m_type_enm != TOK_NOT_VALID) begin
        //send to the scoreboard
        ap_tok_out.write(l_tok_item);
      end
    end
  endfunction : tok_cons_remove_from_queue

  //function to remove from tok_prod_q queue the token and send to the scoreboard if it is a valid token
  function void tok_prod_remove_from_queue();
    token_agent_seq_item l_tok_item;
    if(tok_prod_q.size() > 0) begin
      l_tok_item = tok_prod_q.pop_front();
      if(l_tok_item.m_type_enm != TOK_NOT_VALID) begin
        //send to the scoreboard
        ap_tok_out.write(l_tok_item);
      end
    end
  endfunction : tok_prod_remove_from_queue

endclass
`endif
