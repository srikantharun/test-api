Name,Type,Req_id,Description,Measure,Test,Coverpoints if applicable,notes
Bring up,UVM,DPU_SANITY," Verify the compile , elab and connectivity of  IOs with simple reset
 1. compile /elab clean 
 2. reset (dpu_cfg_axi_s  interface , dpu_token_if, dpu_ifd1_axis_s, dpu_iau_axis_s, dpu_odr_axis_m??)",test.percent_pass,dpu_sanity_test,reset transitions : code coverage for rstn,
Register Access Layer,UVM,DPU_REGISTER," Verify read writes with resets and toggles
RC, RO , W1C, RW - check with resets
Check err response for wrong address ",test.percent_pass,dpu_register_test,code coverage of csrs,
Register Access Layer,UVM,DPU_RAL_BURST,Run register access on DPU CSR's exclusively with bursts,test.percent_pass,dpu_register_test,need recheck ,
Register Access Layer,UVM,DPU_RAL_NOT_AVAIL,Run register access on DPU CSR's region that is not available (no registers available on those addresses) and receive response NOT_OKAY,Group,dpu_register_test,cp_bresp : coverppoint ,
Command,UVM,DPU_CMD,Write the command to FIFO using different burst length. Randomization should be able to send a command in several axi transactions,Group,multiple tests,cvg_dpu_cmd,
Command,UVM,DPU_CMD_BURST,Write more than one command to FIFO in the same burst.,Group,,cvg_dpu_axi_cg,
Command,UVM,DPU_CMD_FULL,Write commands to the CMD FIFO until a command is dropped and then execute the commands that are on the FIFO,Group,dpu_cmd_fifo_overflow_test dpu_cmd_cg,"overflow, num_of_cmds_on_fifo",
Command ,UVM,DPU_CMD_TYPE,Write and execute all types of commands,Group ,multiple tests,"cp_header_cmd_format,cr_looponly_loop_cmd,cr_full_loop_cmd,cr_full_init_cmd",
Command,UVM,DPU_LOOP,"First N-1 interations loop without the last flag
Last instruction writing to output stream is set as l
- should not have multiple lasts",Group,multiple tests,"cp_loop_len, cp_loop_iter, cp_start_addr, cr_looponly_loop_cmd",
Command,UVM,DPU_CMD_TYPE_BURST,Write more than one command to FIFO in the same burst with different layouts,Group,,cvg_dpu_axi_cg,
Program - Instruction,UVM,DPU_MV," Verify that data from reg src (a,b) is moved to dst (b)
 - Verify that data from stream src (ifd0,ifd1) moved to dst (b)
- use range that fits fp18 for inputs for the intial tests
- int8/int32 -> int8/int32
- stream output in fp32 to eliminate precision loss
. Check data input is same at output",Group,dpu_mv_test,"   cp_src0: coverpoint 
    cp_src1: coverpoint 
    cp_src2: coverpoint
    cp_dst: coverpoint
    cp_rfs: coverpoint 
    cp_op: coverpoint 
    cp_i0_int_sgn: coverpoint 
    cp_i1_int_sgn: coverpoint i
    cp_out_int_sgn: coverpoint
    cr_op_i0_i1_signed : cross
    cr_op_out_signed : cross 
    cr_single_source_instructions: cross 
    cr_dual_source_instructions: cross 
    // Define cross coverage for triple source instructions
    cr_triple_source_instructions: cross cp_op, cp_src0, cp_src1, cp_src2, cp_dst
    cr_instructions_rfs_on: cross

all src values ,a,b, i0,1, odr values,opcode
- on the streams cover all data types ",
Program - Instruction,UVM,DPU_MV_STREAM_RFS," - RFS is only set on bypass
- Verify that the rfs flag is set and the instruction is repeated until the input stream terminates with TLAST.
- i0-> o , i1->l (low priority)",Group,dpu_mv_stream_rfs_test,,
Program - Instruction,UVM,DPU_MVC," Verify that paired data from src i0,11 is moved to the paired dst c
check the values of src and dst before and after the instruction is executed.
Check that the paired data from src is moved to the paired dst using cehckers to check the values of src and dst before and after the instruction is executed.
check that the instruction is repeated with value of the rfs flag set and that the input stream terminates with TLAST",Group,dpu_mvc_test,,
Program - Instruction,UVM,DPU_MVC_STREAM_RFS,"load 2 beats of fp32
- if there is not enough data before tlast , there would be an interrupt (irq) <potential new interrupt>
- Verify that the rfs flag is set and the instruction is repeated until the input stream terminates with TLAST.
 check that the instruction is repeated with value of the rfs flag set and that the input stream terminates with TLAST",Group,dpu_mvc_stream_rfs_test,,
Program - Instruction,UVM,DPU_MADD," Verify that the product of src0 and src1 is added to src2 and stored in dst b
Check the dst has a sum of srcs
*dst = f18(src0*src1)+src2						",Group,dpu_madd_test,,
Program - Instruction,UVM,DPU_MADDC," Verify that the product of src0 and the first part of the paired src1 is added to the second part of the paired src1 and stored in dst o,l,a,b
*dst = f18(src0*src1[0])+src1[1]",Group,dpu_maddc_test,,
Program - Instruction,UVM,DPU_MUL," Verify that the product of src0 and src1 is stored in dst.
can have an overflow - randomize for ouput to fit fp18
- select one operand randomly, calculate other operand such that the dst does not overflow
- can have an underflow (interrupt will be raised)
- randomly genrate mantissa and exponent independently
*dst = src0*src1",Group,dpu_mul_test,,
Program - Instruction,UVM,DPU_ADD," Verify that the sum of src0 and src1 is stored in dst.
*dst = src0+src1",Group,dpu_add_test,,
Program - Instruction,UVM,DPU_SUB," Verify that src0 is subtracted from src1 and the result is stored in dst.
cannot have an overflow if inputs are not overflown
*dst = src0-src1
check dst cannot have an overflow if input s are not overflown",Group,dpu_sub_test,,
Program - Instruction,UVM,DPU_NEGATION," Verify that the contents of src are negated and stored in dst.
signed floating point
 Check the negation computation is done correctly by comparing the values of src and dst before and after the instruction is executed.",Group,dpu_negation_test,,
Program - Instruction,UVM,DPU_MAX,"Verify that the maximum value of src0 and src1 is stored in dst for instruction max.
elementwise 64 comparison
*dst = max(src0,src1)",Group,dpu_max_test,,
Program - Instruction,UVM,DPU_MIN," Verify that the minimum value of src0 and src1 is stored in dst for instruction min.
*dst = min(src0,src1)",Group,dpu_min_test,,
Program - Instruction,UVM,DPU_MAX_REDUCTION,"Verify that the maximum value of src is stored in dst for instruction maximum-reduction.
max value element from source is broadcasted to all elements in dst
dst[:] ? max(src[0], src[1], ..., src[63])
biggest element will be streamed 64 times",Group,dpu_max_reduction_test,,
Program - Instruction,UVM,DPU_MIN_REDUCTION,"Verify that the minimum value of src is stored in dst for instruction minimum-reduction.
min value element from source is broadcasted to all elements in dst
dst[:] ? min(src[0], src[1], ..., src[63])",Group,dpu_min_reduction_test,,
Program - Instruction,UVM,DPU_ADD_REDUCTION,"Verify that the sum of the values in src is stored in dst for instruction sum-reduction.
-reduce the exponent to 6 ",Group,dpu_add_reduction_test,,
Program - Instruction,UVM,DPU_PRELU,"Verify that the contents of src are passed through the rectified linear unit (ReLU) activation function and stored in dst.
If each element is smallee than zero - multiply with the other operand",Group,dpu_prelu_test,,
Program - Instruction,UVM,DPU_LUT,"Verify that the contents of src are used as an index to look up a value in a pre-defined lookup table and the result is stored in dst.
- add test with more bins - > LUT chaining
- multiple LUT + add instruction 
- scale and offset to be chosen with respect with respect to the bin. then multiply with scale and add offset, result is stored element by element
-generate bins , scale and offset randomly independently, then sort bins in ascending order before writng in the operand
-the scale should not be such that it overflows, use the same logic as in the mul",Group,dpu_lut_test,,
Program - Instruction,UVM,DPU_LUT_CHAIN,"add test with more bins - > LUT chaining
- multiple LUT + add instruction 
- generate 32 bits randomly , add first 16 in one lut and next 16 for next lut instruction - use the result or both lut operations and add the dest , this can happen to n number of lut instructions",Group,dpu_lut_chain_test,checked specific test,
Program - Instruction,UVM,DPU_RESET,"Verify pipelines are flushed 
- cfg is master reset
-axis stream resets are assumed to be same 
- should not be a case where axis are reset but axi interface is not reset
-should not have any x- prop at the output",Group,dpu_reset_test,cross reset with all above ,
Program - Instruction,UVM,DPU_IRQ_OVF,"Fix operands such that resultant f18 is larger than f18 max value
check for all instructions which can produce an overflow",Group,dpu_irq_test,"Only covered with tests, also code coverage covers it",
Program - Instruction,UVM,DPU_IRQ,"Check the other interrupts-
ERR_ACT_STREAM_IN	Indicates that an input stream is still active after the execution of a command, i.e., no TLAST from the current input stream has been received yet.
ERR_ACT_STREAM_OUT	Indicates that an output stream is still active after the execution of a command, i.e., no TLAST for the current output stream has been pushed yet.
ERR_ILLEGAL_FORMAT	Indicates that the cmd_format field in command descriptor header is unknown.
ERR_EMPTY_PROGRAM	Indicates that the total length of all program sections is zero, i.e., either their number of iterations or their length are zero.
ERR_INIT_SEGFAULT	Indicates that the init section of the program would attempt to read outside the program memory.
ERR_LOOP_SEGFAULT	Indicates that the loop section of the program would attempt to read outside the program memory.
ERR_I0_TERMINATION	Indicates that a multi-beat operation on input stream 0 (i0-f16 or i0-f32) was interrupted with TLAST.
ERR_I1_TERMINATION	Indicates that a multi-beat operation on input stream 1 (i1-f16 or i1-f32) was interrupted with TLAST.
ERR_ID_ILLEGAL_INSTR	Indicates that an illegal instruction was decoded.
ERR_I0_OF	Indicates that a conversion to FP18 on input stream 0 overflowed.
ERR_I0_UF	Indicates that a conversion to FP18 on input stream 0 underflowed.
ERR_I0_NX	Indicates that a conversion to FP18 on input stream 0 incurred a rounding error.
ERR_I1_OF	Indicates that a conversion to FP18 on input stream 1 overflowed.
ERR_I1_UF	Indicates that a conversion to FP18 on input stream 1 underflowed.
ERR_I1_NX	Indicates that a conversion to FP18 on input stream 1 incurred a rounding error.
ERR_MADD_OP_OF	Indicates that a FP overlow happend in the multiply-add data path.
ERR_MADD_OP_UF	Indicates that a FP underflow happend in the multiply-add data path.
ERR_MADD_OP_NX	Indicates that a FP rounding error was incurred in the multiply-add data path.
ERR_SUMR_OP_OF	Indicates that a FP overlow happend in the sum-reduction data path.
ERR_SUMR_OP_NX	Indicates that a FP rounding error was incurred in the sum-reduction data path.
ERR_WB_ILLEGAL_DST	Indicates that an operation arriving for write-back carried an illegal destination.
ERR_B_CONTENTION	Indicates that the two-port SRAM in b storage tried to write and read the same address concurrently. - 
CMDBLK_CMD_DROPPED	The command block FIFO had to drop at least one command because the FIFO was already full.
SWDP_CMD_DROPPED	The SWDP command FIFO had to drop at least one command because the FIFO was already full.
streaming interrupts",Group,dpu_irq_test,"err_act_stream_out, illegal inst - not covered
Only covered with tests, also code coverage covers it",
Program - Instruction,UVM,DPU_EXHAUSTIVE,"Randomly generate all intructions with all random input 
-src randomized
-sequence of instructions of randomized
-use reduced of depth of a and b (eg. 1, 2, 3)
-idea is - should be to use the same resources, for example use the previous instructions dest as source",Group,dpu_all_inst_exhaustive_test,has the same coverpoints as above,
FiFo,UVM,DPU_SW_FIFO,"Test the storage of instructions in the I_sw_dpcmd_fifo block and verify it behaves as expected in debug mode.
- list of intructions are executed one by one independent of cmd fifo
- can have overflow",Group,dpu_sw_fifo_test,,
Program,UVM,DPU_PRG_ACCESS,write and read to entire instruction memory (max_allowed >= burst length >= 1),Group,dpu_random_test,"dpu_random test , code coverage",
Program,UVM,DPU_PRG_ACCESS_NOT_ALLOWED,write/read to/from positions that are greater than INSTR_MEM_DEPTH,Group ,dpu_random_test,"dpu_random test , code coverage",
Program,UVM,DPU_PRG_ACCESS_MISALIGNED,write/read to/from positions that have start address misaligned. Example: address=h00C_8001 or address = h00C_8004,Group ,,cp_bresp : coverppoint ,
Concurrency,UVM,DPU_CMD_PRG_CONCURRENCY_CMD,Write next command (or commands) while executing a program,test.percent_pass,dpu_concurrency_test,,
Concurrency,UVM,DPU_CMD_PRG_CONCURRENCY_PRG,Write next program (or programs) while executing a program,test.percent_pass,dpu_concurrency_test,,
Token,UVM,TOKEN_CONS,verify that DUT waits for token consumer valid to go high when DUT is consuming,Group,all tests that use tokens,cvg_dpu_tok,
Token,UVM,TOKEN_PROD,verify that DUT waits for token producer valid to go high when DUT producer is ready,Group,all tests that use tokens,cvg_dpu_tok,
Token,UVM,TOKEN_PROD_AFTER_DONE,verify that DUT only sets token_prod_valid output to high after finishing the current program ,Group,all tests that use tokens,cvg_dpu_tok,
AXIS Out,UVM,AXIS_OUT_BACKPRESSURE,verify that the DUT allows backpressure on AXIS out using tready,Group,dpu_*test dpu_axisout_cg,cvg_dpu_axis_in_cg,
AXIS In,UVM,AXIS_IN_TVALID_DELAY,verify that the DUT allows tvalid to be low while tready is high,Group,dpu_*test dpu_axisin_cg,cvg_dpu_axis_out_cg,
Observation,UVM,DPU_OBS,check the observation signals,TBD,TBD,TBD,
Stream Peek,UVM,DPU_STREAM_PEEK,Stream peek support (Not yet defined),TBD,TBD,TBD,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
