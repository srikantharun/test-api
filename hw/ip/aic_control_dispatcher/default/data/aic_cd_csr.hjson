{ name: "aic_cd_csr",
  clocking: [{clock: "clk_i", reset: "rst_ni"}],
  bus_interfaces: [
    { protocol: "tlul", direction: "device" }
  ],
  regwidth: "64",
  addrcap: "0x10000",
  axi_intf: True
  param_list : [
    {name:"NUM_DESTINATIONS", type:"int unsigned", default: "17"},
    {name:"NUM_PATCH_MODE_ENTRIES", type:"int unsigned", default: "8"},
    {name:"NUM_PATCH_TABLE_ENTRIES", type:"int unsigned", default: "16"},
    {name:"AXI_AW", type:"int", default:"40"},
    {name:"AXI_IDW", type:"int", default:"7"},
    {name:"AXI_LENW", type:"int", default:"8"}
  ]
  registers: [
    { name: "COMMAND_CONTROL",
      desc: "Control register of the command FIFO.",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        { bits: "0",
          name: "EXEC_EN",
          desc: '''
                While `EXEC_EN` is high, the block processes commands, that are pushed into the Command FIFO.
                ''',
          resval: 0x0
        }
        { bits: "1",
          name: "PTR_RST",
          desc: '''
                Synchronous active-high reset of the SW `DPcmd` FIFO's input word pointer.
                Set and unset `PTR_RST` to reset `SWDP_STATUS.IN_WORD_PTR` to 0. Only use this for error recovery.
                ''',
          resval: 0x0
        }
        { bits: "32",
          name: "DBG_SW_IRQ",
          desc: '''
                `DBG_SW_IRQ` is a level-triggered interrupt request.
                Set `DBG_SW_IRQ` to high to trigger the debug SW interrupt.
                Interrupt handler must set `DBG_SW_IRQ` to low again.
                '''
          resval: 0x0
        }
      ]
    },
    { name: "CTRL_DATA_BASE_ADDR",
      desc: "This base address is added to any read and write transaction generated by the aic_cd (in addition to the global ai_core base address)",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [{bits: "39:0", resval: "0x4000000"}],
    },
    { name: "COMMAND_STATUS",
      desc: "Status register of the command FIFO.",
      swaccess: "ro",
      hwaccess: "hwo",
      hwext : True
      fields: [
        { bits: "7:0",
          name: "IN_WORD_PTR",
          desc: '''
                The input word pointer is used to construct the input data for the command FIFO and
                points to the next 64bit word of the input data to be received by the next AXI transaction.
                '''
        }
        { bits: "15:8",
          name: "FIFO_CNT",
          desc: '''Fill counter of the command FIFO.'''
        }
      ]
    },
    { name: "STATUS_BUSY",
      desc: '''
            Busy flags for the different subunits
            ''',
      swaccess: "ro",
      hwaccess: "hwo",
      hwext: True
      fields:[
        { bits: "0",
          name: "INSTR_REQUEST",
          desc: "The instruction request unit is busy."
        }
        { bits: "1",
          name: "INSTR_AXI_READ",
          desc: "The instruction axi read unit is busy."
        }
        { bits: "2",
          name: "INSTR_VALIDATE",
          desc: "The instruction validation unit is busy."
        }
        { bits: "3",
          name: "EXECUTE",
          desc: "The execute unit is busy."
        }
        { bits: "4",
          name: "COPY_READ_REQUEST",
          desc: "The copy read request unit is busy."
        }
        { bits: "5",
          name: "COPY_AXI_READ",
          desc: "The copy axi read unit is busy."
        }
        { bits: "6",
          name: "COPY_ADDRESS_PATCHING",
          desc: "The copy address patching is busy."
        }
        { bits: "7",
          name: "COPY_FILL_COUNTERS",
          desc: "The copy fill counters are busy."
        }
        { bits: "8",
          name: "COPY_AXI_WRITE_REQUEST",
          desc: "The copy axi write request is busy."
        }
        { bits: "9",
          name: "TOKEN",
          desc: "The token unit is busy."
        }
        { bits: "10",
          name: "TIMESTAMP",
          desc: "The timestamp handshake is busy."
        }
      ]
    },
    { name: "HW_CAPABILITY_PARAMS",
      desc: "Hardware capability register for the instance.",
      swaccess: "ro",
      hwaccess: "hwo",
      hwext : True
      fields: [
        { bits: "7:0",
          name: "NUM_DESTINATIONS",
          desc: '''The number of destinations the unit interacts with.'''
        }
        { bits: "15:8",
          name: "NUM_PATCH_MODE_ENTRIES",
          desc: '''The number of Patch Mode entries.'''
        }
        { bits: "23:16",
          name: "NUM_PATCH_TABLE_ENTRIES",
          desc: '''The number of Patch Table entries.'''
        }
        { bits: "31:24",
          name: "NUM_LOCAL_TOKENS",
          desc: '''The number of local tokens.'''
        }
        { bits: "39:32",
          name: "NUM_GLOBAL_TOKENS",
          desc: '''The number of global tokens.'''
        }
      ]
    },
    { name: "HW_CAPABILITY_FIFOS",
      desc: "Hardware capability register for the instance.",
      swaccess: "ro",
      hwaccess: "hwo",
      hwext : True
      fields: [
        { bits: "7:0",
          name: "COMMAND_FIFO_DEPTH",
          desc: '''Depth of the command FIFO in the CMD block.'''
        }
        { bits: "15:8",
          name: "INSTRUCTION_BUFFER_DEPTH",
          desc: '''Depth of the instruction FIFO in the instruction fetch unit.'''
        }
        { bits: "23:16",
          name: "COPY_BUFFER_DEPTH",
          desc: '''Depth of the copy FIFO between read and write copy units.'''
        }
        { bits: "31:24",
          name: "FILL_COUTNER_DEPTH",
          desc: '''Depth of an individual FIFO beloning to a fill counter. One fifo per `NUM_DESTINATIONS`.'''
        }
      ]
    },
    { skipto: "0x100" }
    { multireg: {
        name: "PATCH_MODE",
        desc: "Describes the word indices and address widths for the patching feature",
        count: "NUM_PATCH_MODE_ENTRIES",
        cname: "PATCH_MODE"
        swaccess: "rw",
        hwaccess: "hro",
        fields: [
          { bits: "3:0",
            name: "WORD_INDEX_0",
            desc: '''Word index of the address field of patch 0.'''
          }
          { bits: "7:4",
            name: "ADDR_WIDTH_0",
            desc: '''Byte width of the the address field of patch 0.'''
          }
          { bits: "11:8",
            name: "WORD_INDEX_1",
            desc: '''Word index of the address field of patch 1.'''
          }
          { bits: "15:12",
            name: "ADDR_WIDTH_1",
            desc: '''Byte width of the the address field of patch 1.'''
          }
        ]
      }
    },
    { skipto: "0x200" }
    { multireg: {
        name: "PATCH_TABLE",
        desc: "Describes the word indices and address widths for the patching feature",
        count: "NUM_PATCH_TABLE_ENTRIES",
        cname: "PATCH_TABLE"
        swaccess: "rw",
        hwaccess: "hro",
        fields: [
          { bits: "39:0",
            name: "BASE_ADDRESS",
            desc: '''Base address to be added to a copied command.'''
          }
        ]
      }
    },
    { skipto: "0x300" }
    { multireg: {
        name: "DST_ADDR_COMMAND",
        desc: "The address map describing the base addresses of all the command blocks.",
        count: "NUM_DESTINATIONS",
        cname: "DST_ADDR_COMMAND",
        swaccess: "rw",
        hwaccess: "hro",
        fields: [{bits: "39:0"}]
      }
    },
    { skipto: "0x400" }
    { multireg: {
        name: "DST_ADDR_PROGRAM",
        desc: "The address map describing the base addresses of all the program memories.",
        count: "NUM_DESTINATIONS",
        cname: "DST_ADDR_PROGRAM",
        swaccess: "rw",
        hwaccess: "hro",
        fields: [{bits: "39:0"}]
      }
    },
    { skipto: "0x500" }
    { multireg: {
        name: "DST_CMDBLOCK_PARAMS",
        desc: '''Describe the comdblock command FIFO parameterization.

              Used to pessimistically estimate the current fill state of the fifo.
              Disable the fill counter per destination by setting either value to 0.
              ''',
        count: "NUM_DESTINATIONS",
        cname: "DST_CMDBLOCK_PARAMS",
        swaccess: "rw",
        hwaccess: "hro",
        fields: [
          { bits: "4:0",
            name: "NUM_FIFO_LINES",
            desc: "The number of lines (depth) the FIFO is parameterized with.",
          },
          { bits: "15:8",
            name: "BYTES_PER_LINE",
            desc: "The number of bytes which can be safed on a FIFO line."
          },
        ],
      }
    },
    { skipto: "0x600" }
    { multireg: {
        name: "STATUS_FILL_COUNTER",
        desc: "The address map describing the base addresses of all the program memories.",
        count: "NUM_DESTINATIONS",
        cname: "STATUS_FILL_COUNTER",
        swaccess: "ro",
        hwaccess: "hwo",
        hwext: True
        fields: [
          { bits: "7:0"
            name: "COUNT"
            desc: '''
                  Current number of lines of a command block fifo the AIC_CD assumes to be in use at the destination.
                  '''
          },
          { bits: "8"
            name: "WOULD_STALL"
            desc: '''
                  The counter is at capacity and would stall a command targeting this destination.
                  '''
          },
          { bits: "9"
            name: "IS_STALLED"
            desc: '''
                  The fill counters currently are blocking a command to be written.
                  (This is replicated for all destinations).
                  '''
          },
        ]
      }
    },
    { skipto: "0xF00" }
    {
      name: "IRQ_EN",
      desc: "Interupt enable register",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        /////////////////////////
        // Done Task List Flag //
        /////////////////////////
        { bits: "0",
          name: "TASK_LIST_DONE",
          desc: '''
                Enable IRQ flagging of the started task list has been completed.
                '''
          resval: 0x1
        }
        //////////////////////////////////////////
        // Errors from the AIC_CD Command Block //
        //////////////////////////////////////////
        { bits: "1",
          name: "COMMAND_DROPPED",
          desc: '''
                Enable IRQ flagging of command FIFO command dropping.
                '''
          resval: 0x1
        }
        { bits: "2",
          name: "COMMAND_EMPTY_TASK_LIST",
          desc: '''
                Enable IRQ flagging of the commands task list length was 0 and the command is dropped.
                '''
          resval: 0x1
        }
        ////////////////////////////////////////////
        // Errors from the Insturction Validation //
        ////////////////////////////////////////////
        { bits: "3",
          name: "INSTR_AXI_RESP_SLVERR",
          desc: '''
                Enable IRQ flagging of instruction had a SVLERR response.
                '''
          resval: 0x1
        }
        { bits: "4",
          name: "INSTR_AXI_RESP_DECERR",
          desc: '''
                Enable IRQ flagging of instruction had a DECERR response.
                '''
          resval: 0x1
        }
        { bits: "5",
          name: "INSTR_DST_ID_MAPPING",
          desc: '''
                Enable IRQ flagging of the destination ID mapping of an instruction is invalid.
                '''
          resval: 0x1
        }
        { bits: "6",
          name: "INSTR_PATCH_MODE_MAPPING",
          desc: '''
                Enable IRQ flagging of the patch mode mapping of an instruction does not exists.
                '''
          resval: 0x1
        }
        { bits: "7",
          name: "INSTR_PATCH_ID_0_MAPPING",
          desc: '''
                Enable IRQ flagging of the pacth id 0 mapping of an instruction does not exists.
                '''
          resval: 0x1
        }
        { bits: "8",
          name: "INSTR_PATCH_ID_1_MAPPING",
          desc: '''
                Enable IRQ flagging of the pacth id 1 mapping of an instruction does not exists.
                '''
          resval: 0x1
        }
        { bits: "9",
          name: "INSTR_TOKEN_ILLEGAL_OPCODE",
          desc: '''
                Enable IRQ flagging of a token instruction has an illegal sub-opcode.
                '''
          resval: 0x1
        }
        { bits: "10",
          name: "INSTR_TOKEN_LOCAL_MAP_EMPTY",
          desc: '''
                Enable IRQ flagging of the mapped portion of a local token instruction is empty.
                '''
          resval: 0x1
        }
        { bits: "11",
          name: "INSTR_TOKEN_GLOBAL_MAP_EMPTY",
          desc: '''
                Enable IRQ flagging of the mapped portion of a global token instruction is empty.
                '''
          resval: 0x1
        }
        { bits: "12",
          name: "INSTR_TOKEN_LOCAL_MAPPING",
          desc: '''
                Enable IRQ flagging of the unmapped portion of a local token instruction contains data.
                '''
          resval: 0x1
        }
        { bits: "13",
          name: "INSTR_TOKEN_GLOBAL_MAPPING",
          desc: '''
                Enable IRQ flagging of the unmapped portion of a global token instruction contains data.
                '''
        }
        ///////////////////////////////
        // Errors from the Copy Unit //
        ///////////////////////////////
        { bits: "14",
          name: "COPY_DATA_MISALIGNED",
          desc: '''
                Enable IRQ flagging of a copy command has the data not byte aligned. The Copy operation was dropped!
                '''
          resval: 0x1
        }
        { bits: "15",
          name: "COPY_FILL_COUNTER_DONE_POP",
          desc: '''
                Enable IRQ flagging of fill counter got a done pulse without tracking anything.
                '''
          resval: 0x1
        }
        { bits: "16",
          name: "COPY_FILL_COUNTER_OVERFLOW",
          desc: '''
                Enable IRQ flagging of a fill counter over or underflowed.
                '''
          resval: 0x1
        }
        { bits: "17",
          name: "COPY_AXI_READ_RESP_SLVERR",
          desc: '''
                Enable IRQ flagging of copy read operation had a SVLERR response.
                '''
          resval: 0x1
        }
        { bits: "18",
          name: "COPY_AXI_READ_RESP_DECERR",
          desc: '''
                Enable IRQ flagging of copy read operation had a DECERR response.
                '''
          resval: 0x1
        }
        { bits: "19",
          name: "COPY_AXI_WRITE_RESP_SLVERR",
          desc: '''
                Enable IRQ flagging of copy write operation had a SVLERR response.
                '''
          resval: 0x1
        }
        { bits: "20",
          name: "COPY_AXI_WRITE_RESP_DECERR",
          desc: '''
                Enable IRQ flagging of copy write operation had a DECERR response.
                '''
          resval: 0x1
        }
        //////////////////////////
        // Debug Software Error //
        //////////////////////////
        { bits: "32",
          name: "DBG_SW_INTERRUPT",
          desc: '''
                Enable IRQ flagging of the debug SW interrupt.
                '''
        }
      ]
    },
    {
      name: "IRQ_STATUS",
      desc: "Interrupt status register",
      swaccess: "rw1c",
      hwaccess: "hrw"
      fields: [
        /////////////////////////
        // Done Task List Flag //
        /////////////////////////
        { bits: "0",
          name: "TASK_LIST_DONE",
          desc: '''
                The started task list has been completed.
                '''
          resval: 0x1
        }
        //////////////////////////////////////////
        // Errors from the AIC_CD Command Block //
        //////////////////////////////////////////
        { bits: "1",
          name: "COMMAND_DROPPED",
          desc: '''
                The command FIFO had to drop at least one command because the FIFO was already full.
                '''
        }
        { bits: "2",
          name: "COMMAND_EMPTY_TASK_LIST",
          desc: '''
                The commands task list length was 0 and the command is dropped.
                '''
          resval: 0x1
        }
        ////////////////////////////////////////////
        // Errors from the Insturction Validation //
        ////////////////////////////////////////////
        { bits: "3",
          name: "INSTR_AXI_RESP_SLVERR",
          desc: '''
                Instruction had a SVLERR response.
                '''
          resval: 0x1
        }
        { bits: "4",
          name: "INSTR_AXI_RESP_DECERR",
          desc: '''
                Instruction had a DECERR response.
                '''
          resval: 0x1
        }
        { bits: "5",
          name: "INSTR_DST_ID_MAPPING",
          desc: '''
                The destination ID mapping of an instruction is invalid.
                '''
          resval: 0x1
        }
        { bits: "6",
          name: "INSTR_PATCH_MODE_MAPPING",
          desc: '''
                The patch mode mapping of an instruction does not exists.
                '''
          resval: 0x1
        }
        { bits: "7",
          name: "INSTR_PATCH_ID_0_MAPPING",
          desc: '''
                The pacth id 0 mapping of an instruction does not exists.
                '''
          resval: 0x1
        }
        { bits: "8",
          name: "INSTR_PATCH_ID_1_MAPPING",
          desc: '''
                The pacth id 1 mapping of an instruction does not exists.
                '''
          resval: 0x1
        }
        { bits: "9",
          name: "INSTR_TOKEN_ILLEGAL_OPCODE",
          desc: '''
                A token instruction has an illegal sub-opcode.
                '''
          resval: 0x1
        }
        { bits: "10",
          name: "INSTR_TOKEN_LOCAL_MAP_EMPTY",
          desc: '''
                The mapped portion of a local token instruction is empty.
                '''
          resval: 0x1
        }
        { bits: "11",
          name: "INSTR_TOKEN_GLOBAL_MAP_EMPTY",
          desc: '''
                The mapped portion of a global token instruction is empty.
                '''
          resval: 0x1
        }
        { bits: "12",
          name: "INSTR_TOKEN_LOCAL_MAPPING",
          desc: '''
                The unmapped portion of a local token instruction contains data.
                '''
          resval: 0x1
        }
        { bits: "13",
          name: "INSTR_TOKEN_GLOBAL_MAPPING",
          desc: '''
                The unmapped portion of a global token instruction contains data.
                '''
        }
        ///////////////////////////////
        // Errors from the Copy Unit //
        ///////////////////////////////
        { bits: "14",
          name: "COPY_DATA_MISALIGNED",
          desc: '''
                A copy command has the data not byte aligned. The Copy operation was dropped!
                '''
          resval: 0x1
        }
        { bits: "15",
          name: "COPY_FILL_COUNTER_DONE_POP",
          desc: '''
                A fill counter got a done pulse without tracking anything.
                '''
          resval: 0x1
        }
        { bits: "16",
          name: "COPY_FILL_COUNTER_OVERFLOW",
          desc: '''
                A fill counter over or underflowed.
                '''
          resval: 0x1
        }
        { bits: "17",
          name: "COPY_AXI_READ_RESP_SLVERR",
          desc: '''
                A copy read operation had a SVLERR response.
                '''
          resval: 0x1
        }
        { bits: "18",
          name: "COPY_AXI_READ_RESP_DECERR",
          desc: '''
                A copy read operation had a DECERR response.
                '''
          resval: 0x1
        }
        { bits: "19",
          name: "COPY_AXI_WRITE_RESP_SLVERR",
          desc: '''
                A copy write operation had a SVLERR response.
                '''
          resval: 0x1
        }
        { bits: "20",
          name: "COPY_AXI_WRITE_RESP_DECERR",
          desc: '''
                A copy write operation had a DECERR response.
                '''
          resval: 0x1
        }
        //////////////////////////
        // Debug Software Error //
        //////////////////////////
        { bits: "32",
          name: "DBG_SW_INTERRUPT",
          desc: '''
                SW triggered the debug interrupt by setting the `DP_CTRL.DBG_SW_IRQ` to high.
                '''
        }
      ]
    },
    {
      name: "ERROR_CAUSE",
      desc: "Debug info about the raised error from an IRQ",
      swaccess: "rw0c",
      hwaccess: "hrw",
      fields: [
        { bits: "15:0",
          name: "INSTRUCTION_INDEX",
          desc: '''
                The index of the transaction which triggered the error.
                Only will latch a new walue when cleared by SW.
                '''
        },
      ],
    },
  ]
}
