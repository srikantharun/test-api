// AI CORE DWPU hdl top
//-//`define AXI_VIP
`define AXI_VIP_CONN_M
`define AXI_VIP_CONN_S
`define AXI_VIP_CONN_CFG

`define DUT dut


module hdl_top #(
  /// The number of local tokens
  parameter int unsigned NumLocalTokens = 17,  //TODO: grab these from the RTL ACD package 
  /// The number of global tokens
  parameter int unsigned NumGlobalTokens  =  7,
  parameter int unsigned NumDestinations = 17,
  parameter int unsigned AxiManAddrWidth = aic_cd_defaults_pkg::AXI_M_ADDR_WIDTH );
  // Time unit and precision
  timeunit 1ns; timeprecision 1ps;
   
  // Packages import
  import uvm_pkg::*;
  `include "uvm_macros.svh"
  import svt_uvm_pkg::*;
  import svt_axi_uvm_pkg::*;
  import aic_common_pkg::*;
  import aic_cd_defaults_pkg::*;
  import ai_core_cd_test_pkg::*;

  //include bind files
  //`include "axi4pc/bind_ai_core_dwpu.svh"

  realtime CLK_PERIOD = 1.25ns;  // 800MHz --> 1.25ns

  logic i_clk;
  logic i_rst_n;

  logic clk_en;
  int  acd_freq_mhz = 800;
  time acd_tol_ps   = 10;
   
   //////////////////////
  // Subordinate Port //
  //////////////////////
  axi_s_aw_t i_axi_s_aw;
  logic      i_axi_s_aw_valid;
  logic      o_axi_s_aw_ready;
  axi_s_w_t  i_axi_s_w;
  logic      i_axi_s_w_valid;
  logic      o_axi_s_w_ready;
  axi_s_b_t  o_axi_s_b;
  logic      o_axi_s_b_valid;
  logic      i_axi_s_b_ready;
  axi_s_ar_t i_axi_s_ar;
  logic      i_axi_s_ar_valid;
  logic      o_axi_s_ar_ready;
  axi_s_r_t  o_axi_s_r;
  logic      o_axi_s_r_valid;
  logic      i_axi_s_r_ready;

  //////////////////
  // Manager port //
  //////////////////
  axi_m_aw_t o_axi_m_aw;
  logic      o_axi_m_aw_valid;
  logic      i_axi_m_aw_ready;
  axi_m_w_t  o_axi_m_w;
  logic      o_axi_m_w_valid;
  logic      i_axi_m_w_ready;
  axi_m_b_t  i_axi_m_b;
  logic      i_axi_m_b_valid;
  logic      o_axi_m_b_ready;
  axi_m_ar_t o_axi_m_ar;
  logic      o_axi_m_ar_valid;
  logic      i_axi_m_ar_ready;
  axi_m_r_t  i_axi_m_r;
  logic      i_axi_m_r_valid;
  logic      o_axi_m_r_ready;

  
  ///////////////////////
  // Local Token Lines //
  /////// ////////////////
  logic [NumLocalTokens-1:0] o_token_local_prod_valid;
  logic [NumLocalTokens-1:0] i_token_local_prod_ready;

  logic [NumLocalTokens-1:0] i_token_local_cons_valid;
  logic [NumLocalTokens-1:0] o_token_local_cons_ready;

  ////////////////////////
  // Global Token Lines //
  ////////////////////////
  logic [NumGlobalTokens-1:0] o_token_global_prod_valid;
  logic [NumGlobalTokens-1:0] i_token_global_prod_ready;

  logic [NumGlobalTokens-1:0] i_token_global_cons_valid;
  logic [NumGlobalTokens-1:0] o_token_global_cons_ready;

  ///////////////
  // Timestamp //
  ///////////////
  /// The id of the timestamp
  aic_cd_pkg::timestamp_trigger_id_t o_timestamp_id;
  /// The pulse that the timestamp is active
  logic                              o_timestamp_active_pulse;

  ////////////////////////////////////////////////
  // Syncronization lines from the destinations //
  ////////////////////////////////////////////////
  /// A destination as completed a command, these cause the fill counters to decrement
  logic [NumDestinations-1:0] i_destination_cmd_done;

  ///////////////////
  // Configuration //
  ///////////////////
  /// Global base address added to any transaction generated by the manager port
  ///
  /// This should match the base address of the respective AI core
  logic [AxiManAddrWidth-1:0] i_aic_base_addr;

  ///////////////
  // Interrupt //
  ///////////////
  /// An interrupt is raised
  logic o_irq;  
        
  /////////////////////////////
  // Memory Sideband Signals //
  /////////////////////////////
  /// Memory sideband input signals (tie to `'0` if `BufferUsesMacro == 1'b0`)
  axe_tcl_sram_pkg::impl_inp_t i_instr_ram_impl;
  /// Memory sideband signals
  axe_tcl_sram_pkg::impl_oup_t o_instr_ram_impl;
  /// Memory sideband input signals (tie to `'0` if `BufferUsesMacro == 1'b0`)
  axe_tcl_sram_pkg::impl_inp_t  i_copy_ram_impl;
  /// Memory sideband signals
  axe_tcl_sram_pkg::impl_oup_t  o_copy_ram_impl;
   

  // =============================================================================================================
  // Instantiate DWPU agent interface
  // =============================================================================================================
  ai_core_cd_if aic_cd_if(i_clk);
  ai_core_cd_tms_if aic_cd_tms_if(i_clk);
  ai_core_cd_done_if aic_cd_done_if(i_clk);

   // VIP Interface instance representing the AXI system
  svt_axi_if axi_if ();
  assign axi_if.common_aclk = i_clk;
  // TB Interface instance to provide access to the reset signal
  axi_reset_if axi_reset_if ();
  assign axi_reset_if.clk = i_clk;

  // =============================================================================================================
  // Assign the reset pin from the reset interface to the reset pins from the VIP interface.
  // =============================================================================================================
//-//`ifdef AXI_VIP
  assign axi_if.master_if[0].aresetn  = axi_reset_if.reset;
//-//  assign axi_if.master_if[1].aresetn  = axi_reset_if.reset;
  assign axi_if.slave_if[0].aresetn   = axi_reset_if.reset;
  assign i_rst_n                      = axi_reset_if.reset;
  assign aic_cd_if.reset_n_i          = axi_reset_if.reset;

  assign aic_cd_tms_if.timestamp_id            = o_timestamp_id;
  assign aic_cd_tms_if.timestamp_active_pulse  = o_timestamp_active_pulse;
//-//`endif
//-//

  // AXIS:
//-// // AXI LT interface
//-//`ifdef AXI_VIP_CONN_M
  ///////////////////////////
  //Manager Agent connection
  assign i_axi_s_aw_valid = axi_if.master_if[0].awvalid;
  assign i_axi_s_aw.addr  = axi_if.master_if[0].awaddr;
  assign i_axi_s_aw.id    = axi_if.master_if[0].awid;
  assign i_axi_s_aw.len   = axi_if.master_if[0].awlen;
  assign i_axi_s_aw.size  = axi_if.master_if[0].awsize;
  assign i_axi_s_aw.burst = axi_if.master_if[0].awburst;
  assign i_axi_s_aw.lock  = axi_if.master_if[0].awlock;
  assign i_axi_s_aw.cache = axi_if.master_if[0].awcache;
  assign i_axi_s_aw.prot  = axi_if.master_if[0].awprot;


  assign axi_if.master_if[0].awready = o_axi_s_aw_ready;

  assign i_axi_s_w_valid  = axi_if.master_if[0].wvalid;
  assign i_axi_s_w.last   = axi_if.master_if[0].wlast;
  assign i_axi_s_w.data   = axi_if.master_if[0].wdata;
  assign i_axi_s_w.strb   = axi_if.master_if[0].wstrb;

  assign axi_if.master_if[0].wready = o_axi_s_w_ready;

  assign axi_if.master_if[0].bvalid = o_axi_s_b_valid;
  assign axi_if.master_if[0].bid    = o_axi_s_b.id;
  assign axi_if.master_if[0].bresp  = o_axi_s_b.resp;

  assign i_axi_s_b_ready  = axi_if.master_if[0].bready;

  assign i_axi_s_ar_valid = axi_if.master_if[0].arvalid;
  assign i_axi_s_ar.addr  = axi_if.master_if[0].araddr;
  assign i_axi_s_ar.id    = axi_if.master_if[0].arid;
  assign i_axi_s_ar.len   = axi_if.master_if[0].arlen;
  assign i_axi_s_ar.size  = axi_if.master_if[0].arsize;
  assign i_axi_s_ar.burst = axi_if.master_if[0].arburst;
  assign i_axi_s_ar.lock  = axi_if.master_if[0].arlock;
  assign i_axi_s_ar.cache = axi_if.master_if[0].arcache;
  assign i_axi_s_ar.prot  = axi_if.master_if[0].arprot;

  assign axi_if.master_if[0].arready = o_axi_s_ar_ready;

  assign axi_if.master_if[0].rvalid = o_axi_s_r_valid;
  assign axi_if.master_if[0].rlast  = o_axi_s_r.last;
  assign axi_if.master_if[0].rid    = o_axi_s_r.id;
  assign axi_if.master_if[0].rdata  = o_axi_s_r.data;
  assign axi_if.master_if[0].rresp  = o_axi_s_r.resp;

  assign i_axi_s_r_ready  = axi_if.master_if[0].rready;

  //////////////////////////////
  //Subordinate Agent connection
  assign axi_if.slave_if[0].awvalid = o_axi_m_aw_valid;  
  assign axi_if.slave_if[0].awaddr  = o_axi_m_aw.addr ;   
  assign axi_if.slave_if[0].awid    = o_axi_m_aw.id   ; 
  assign axi_if.slave_if[0].awlen   = o_axi_m_aw.len  ; 
  assign axi_if.slave_if[0].awsize  = o_axi_m_aw.size ; 
  assign axi_if.slave_if[0].awburst = o_axi_m_aw.burst;  
  assign axi_if.slave_if[0].awlock  = o_axi_m_aw.lock;
  assign axi_if.slave_if[0].awcache = o_axi_m_aw.cache;
  assign axi_if.slave_if[0].awprot  = o_axi_m_aw.prot;


  assign i_axi_m_aw_ready = axi_if.slave_if[0].awready;

  assign axi_if.slave_if[0].wvalid = o_axi_m_w_valid;
  assign axi_if.slave_if[0].wlast  = o_axi_m_w.last;
  assign axi_if.slave_if[0].wdata  = o_axi_m_w.data;
  assign axi_if.slave_if[0].wstrb  = o_axi_m_w.strb;

  assign i_axi_m_w_ready = axi_if.slave_if[0].wready;

  assign i_axi_m_b_valid = axi_if.slave_if[0].bvalid;
  assign i_axi_m_b.id    = axi_if.slave_if[0].bid   ;
  assign i_axi_m_b.resp  = axi_if.slave_if[0].bresp ;

  assign axi_if.slave_if[0].bready = o_axi_m_b_ready;

  assign axi_if.slave_if[0].arvalid = o_axi_m_ar_valid;
  assign axi_if.slave_if[0].araddr  = o_axi_m_ar.addr ;
  assign axi_if.slave_if[0].arid    = o_axi_m_ar.id   ;
  assign axi_if.slave_if[0].arlen   = o_axi_m_ar.len  ;
  assign axi_if.slave_if[0].arsize  = o_axi_m_ar.size ;
  assign axi_if.slave_if[0].arburst = o_axi_m_ar.burst;
  assign axi_if.slave_if[0].arlock  = o_axi_m_ar.lock;
  assign axi_if.slave_if[0].arcache = o_axi_m_ar.cache;
  assign axi_if.slave_if[0].arprot  = o_axi_m_ar.prot;

  assign i_axi_m_ar_ready = axi_if.slave_if[0].arready;

  assign i_axi_m_r_valid = axi_if.slave_if[0].rvalid;
  assign i_axi_m_r.last  = axi_if.slave_if[0].rlast ;
  assign i_axi_m_r.id    = axi_if.slave_if[0].rid   ;
  assign i_axi_m_r.data  = axi_if.slave_if[0].rdata ;
  assign i_axi_m_r.resp  = axi_if.slave_if[0].rresp ;

  assign axi_if.slave_if[0].rready = o_axi_m_r_ready;


`define token_agent_instantiate_interface(tkn_type, agent_num) \
  token_agent_if ``tkn_type``_tok_agt_``agent_num``_if(i_clk);

`define token_agent_connect_interface(tkn_type, agent_num) \
  assign ``tkn_type``_tok_agt_``agent_num``_if.reset_n       = axi_reset_if.reset; \
  assign ``tkn_type``_tok_agt_``agent_num``_if.tok_cons_rdy  = o_token_``tkn_type``_cons_ready[``agent_num``]; \
  assign i_token_``tkn_type``_cons_valid[``agent_num``] = ``tkn_type``_tok_agt_``agent_num``_if.tok_cons_vld; \
  assign i_token_``tkn_type``_prod_ready[``agent_num``] = ``tkn_type``_tok_agt_``agent_num``_if.tok_prod_rdy; \
  assign ``tkn_type``_tok_agt_``agent_num``_if.tok_prod_vld  = o_token_``tkn_type``_prod_valid[``agent_num``];

`define token_agent_set_interface(tkn_type, agent_num) \
    initial begin \
    //  import uvm_pkg::uvm_config_db; \
      import uvm_pkg::*; \
      `uvm_info("HDL_TOP_MY_DEBUG",$sformatf("uvm_test_top.env.%0s_tok_agt[%0d]", "``tkn_type``", ``agent_num``), UVM_NONE) \
      uvm_config_db#(virtual token_agent_if)::set(null, $sformatf("uvm_test_top.env.%0s_tok_agt[%0d]", "``tkn_type``", ``agent_num``), "vif", ``tkn_type``_tok_agt_``agent_num``_if); \
    end
    //uvm_config_db#(virtual token_agent_if)::set(null, $sformatf("uvm_test_top.env.%0s_tok_agt[%0d]",``tkn_type``,``agent_num``), "vif", ``tkn_type``_tok_agt_``agent_num``_if);

`define token_agent_connect(tkn_type, agent_num) \
  `token_agent_instantiate_interface(tkn_type, agent_num) \
  `token_agent_connect_interface(tkn_type, agent_num)  \
  `token_agent_set_interface(tkn_type, agent_num)


  //genvar agt_num
  generate
    ////local
    for (genvar agt_num=0; agt_num < NumLocalTokens; agt_num++) begin
      `token_agent_connect(local, agt_num)
     end
    ////global
    for (genvar agt_num=0; agt_num < NumGlobalTokens; agt_num++) begin
      `token_agent_connect(global, agt_num)
     end
  endgenerate


//Token Local Manager Agents connection
token_agent_if tok_agt_if (i_clk);
  assign tok_agt_if.reset_n       = axi_reset_if.reset;
  assign tok_agt_if.tok_cons_rdy  = o_token_local_cons_ready[0];
  //assign i_token_local_cons_valid[0] = tok_agt_if.tok_cons_vld;
  
  //assign i_token_local_prod_ready[0] = tok_agt_if.tok_prod_rdy;
  assign tok_agt_if.tok_prod_vld  = o_token_local_prod_valid[0];


//Base address 
assign i_aic_base_addr = 'd0; //ToDO: connect this bus to the AIC CD agent  - will be set just once per test and should be 4k aligned 

//Synchronization
//assign i_destination_cmd_done = 'd0;  //ToDO: connect this bus to the AIC CD agent - sequence is mandatory for this interface since we have irq for fill counter underflow / or actually done without command 
assign i_destination_cmd_done = aic_cd_done_if.done_o;


//Sideband signals 
//  // Miscellaneous Samsung 5nm memory signals that should be passed to
//  // the synopsys memory wrapper via the impl_i port and impl_in_t type.
//assign i_instr_ram_impl   = 'd0;  //ToDO: what should we connect this bus to ?
assign i_instr_ram_impl.mcs   = 'd0;  //ToDO: what should we connect this bus to ?   //These are hardcoded on the memory mapper 
assign i_instr_ram_impl.mcsw  = 'd0;  //ToDO: what should we connect this bus to ?   //These are hardcoded on the memory mapper
assign i_instr_ram_impl.ret   = 'd0;  //ToDO: what should we connect this bus to ?   //
assign i_instr_ram_impl.pde   = 'd0;  //ToDO: what should we connect this bus to ?
assign i_instr_ram_impl.se    = 'd0;  //ToDO: what should we connect this bus to ?
assign i_instr_ram_impl.adme  = 'd0;  //ToDO: what should we connect this bus to ?
//assign i_copy_ram_impl.  = 'd0;  //ToDO: what should we connect this bus to ?
assign i_copy_ram_impl.mcs   = 'd0;  //ToDO: what should we connect this bus to ?
assign i_copy_ram_impl.mcsw  = 'd0;  //ToDO: what should we connect this bus to ?
assign i_copy_ram_impl.ret   = 'd0;  //ToDO: what should we connect this bus to ?
assign i_copy_ram_impl.pde   = 'd0;  //ToDO: what should we connect this bus to ?
assign i_copy_ram_impl.se    = 'd0;  //ToDO: what should we connect this bus to ?
assign i_copy_ram_impl.adme  = 'd0;  //ToDO: what should we connect this bus to ?

assign aic_cd_if.irq_o = o_irq;

  // =============================================================================================================
  // Instantiate test harness/DUT
  // =============================================================================================================
  `ifndef NO_DUT
  aic_cd #(
    .AxiEndpointAddrStart   ('{aic_addr_map_pkg::AIC_CFG_ACD_CSR_ST_ADDR,  aic_addr_map_pkg::AIC_CFG_ACD_CMD_ST_ADDR}),
    .AxiEndpointAddrEnd     ('{aic_addr_map_pkg::AIC_CFG_ACD_CSR_END_ADDR, aic_addr_map_pkg::AIC_CFG_ACD_CMD_END_ADDR})
  ) dut (.*);
  `endif

  // =============================================================================================================
  // Reset and clock generation
  // =============================================================================================================
   axe_clk_generator u_axe_clk_generator(
                                            .i_enable(clk_en),
                                            .o_clk(i_clk)
                                          );

   axe_clk_assert u_axe_clk_assert(.clk(i_clk),
				.rst_n(i_rst_n),
				.freq_mhz(acd_freq_mhz),
				.tol_ps  (acd_tol_ps)
				);

  // Generate the clock
  initial begin
    u_axe_clk_generator.set_clock(.freq_mhz(acd_freq_mhz), .duty(50));
    clk_en = 1'b1;
  end


  // =============================================================================================================
  // Configuration database settings
  // =============================================================================================================
  initial begin
    import uvm_pkg::uvm_config_db;
    `ifdef AXI_VIP
    // Set the reset interface on the virtual sequencer
    uvm_config_db#(virtual axi_reset_if.axi_reset_modport)::set(uvm_root::get(), "uvm_test_top.env.sequencer", "reset_mp", axi_reset_if.axi_reset_modport);

    // =============================================================================================================
    // Provide the AXI SV interface to the AXI System ENV. This step establishes the connection between the AXI
    // System ENV and the DUT through the AXI interface.
    // =============================================================================================================
    uvm_config_db#(svt_axi_vif)::set(uvm_root::get(), "uvm_test_top.env.m_axi_system_env", "vif", axi_if);
    uvm_config_db#(virtual ai_core_cd_if)::set(null, "uvm_test_top.env.aic_cd_agt", "vif", aic_cd_if);
    uvm_config_db#(virtual ai_core_cd_tms_if)::set(null, "uvm_test_top.env.*", "tms_vif", aic_cd_tms_if);
    uvm_config_db#(virtual ai_core_cd_done_if)::set(null, "uvm_test_top.env.*", "done_vif", aic_cd_done_if);
    
    //Thse are set `token_agent_set_interface macro
    //uvm_config_db#(virtual token_agent_if)::set(null, "uvm_test_top.env.local_tok_agt", "vif", tok_agt_if);
    //uvm_config_db#(virtual token_agent_if)::set(null, "uvm_test_top.env.local_tok_agt[0]", "vif", local_tok_agt_0_if);
    `endif
  end

  //disable all assertions until first reset happens
  //RTL assertions are returning false errors before initial reset
  initial begin
    $timeformat(-9, 3, " ns", 10);
    $assertoff(0,dut);  //TODO: [code was copied over from the DWPU] try to leave assertions on durin initial reset phase and see if the RTL can handle it
    @(negedge i_rst_n);
    #1; //this is necessary because the reset sequence can drive the reset after #0ps, which leads to a race condition that is triggered by Axi4PC module due to sequence of events on simulator.
    $asserton(0,dut);
  end

  initial begin
    run_test();
  end
endmodule : hdl_top
