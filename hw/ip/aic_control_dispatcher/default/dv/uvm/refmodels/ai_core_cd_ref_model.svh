`ifndef AI_CORE_CD_REF_MODEL_SV
`define AI_CORE_CD_REF_MODEL_SV


`uvm_analysis_imp_decl (_DP_CMD)

class ai_core_cd_ref_model extends uvm_component;
  `uvm_component_utils(ai_core_cd_ref_model)

  typedef bit[64-1:0] bit64_t;

  ai_core_cd_ref_model_cfg m_cfg;

  // AI Core DWPU RAL Model
  aic_cd_csr_reg_block regmodel;
  ai_core_cd_mem_manager mem_manager_p;

  int local_tokens[];
  int global_tokens[];

  //bit[31:0] base_addr = DWPU_CSR_ST_ADDR;
  //token_agent_seq_item  tok_cons_q [$];
  //token_agent_seq_item  tok_prod_q [$];

  semaphore fill_counter[];
  semaphore irq_active;  //is used to stall cmd execution flow when irq becomes active
  int endpoint_stored_cmd_len_daq[][$]; //used to track cmd lengths sent to each endp so we can decrement fill counter on done signal

  bit irq_en[string];
  bit irq_status[string];

  //uvm_analysis_port#(token_agent_seq_item) ap_tok_out;
  
  //uvm_tlm_analysis_fifo#(token_agent_seq_item) taf_mon_tok;
  //uvm_tlm_analysis_fifo#(token_agent_seq_item) taf_mdl_tok;

  uvm_analysis_port#(token_agent_seq_item) local_token_exp_ap[];
  uvm_analysis_port#(token_agent_seq_item) global_token_exp_ap[];




  /** Variable to inform if the input data stream Watchdog was triggered (watchdog do not exist on design, is to help on the test control) */

  
  //verbosity options
  uvm_verbosity tok_dbg_verbosity = UVM_DEBUG;
  typedef uvm_enum_wrapper#(uvm_verbosity) verbosity_wrapper;

  function new(string name ="", uvm_component parent = null);
    super.new(name,parent);
    //analysis_imp_dp_commands = new("analysis_imp_dp_commands", this);
    
  endfunction

  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);

    if (!uvm_config_db#(ai_core_cd_ref_model_cfg)::get(this, "", "m_cfg", m_cfg))
      `uvm_fatal("REF_MODEL_BUILD_PHASE", "Unable to find environment configuration object in the uvm_config_db");

    //output data generated by ref_model

    //input data fifos
    //taf_mon_tok = new("taf_mon_tok", this);

    //get reference model config
    
    local_tokens = new[m_cfg.local_token_line_num];
    global_tokens = new[m_cfg.global_token_line_num];
    `uvm_info("REF_MODEL",$sformatf("local_tokens @SOT: %0p",local_tokens),UVM_LOW)
    `uvm_info("REF_MODEL",$sformatf("global_tokens @SOT: %0p",global_tokens),UVM_LOW)

    local_token_exp_ap = new[m_cfg.local_token_line_num];
    foreach (local_token_exp_ap[i])
      local_token_exp_ap[i] = new($sformatf("local_token_exp_ap[%0d]",i),this);
      
    global_token_exp_ap = new[m_cfg.global_token_line_num];
    foreach (global_token_exp_ap[i])
      global_token_exp_ap[i] = new($sformatf("global_token_exp_ap[%0d]",i),this);
       
    fill_counter = new[m_cfg.fill_counter_num];
    foreach (fill_counter[i])
      fill_counter[i] = new(0);

    irq_active = new(1); //just one irq is enought to stall cmd execution

    endpoint_stored_cmd_len_daq = new[m_cfg.fill_counter_num];

    // DP command Model
    //dp_cmd_model = ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_model#(aic_dp_cmd_gen_pkg::dummy_dp_command_t)::type_id::create("dp_cmd_model", this);
    //ap_to_dp_cmd_model = new("ap_to_dp_cmd_model",this);
  endfunction : build_phase
  
  virtual function void connect_phase(uvm_phase phase);
    super.connect_phase(phase);
    uvm_config_db#(uvm_verbosity)::get(this, "", "tok_dbg_verbosity", tok_dbg_verbosity);
    
    // Connect this analysis port to model analysis export
    //this.ap_to_dp_cmd_model.connect(dp_cmd_model.analysis_export);

    // Connect Scoreboards
    //dp_cmd_model.command_ap.connect(this.analysis_imp_dp_commands);
  endfunction : connect_phase

  virtual task run_phase(uvm_phase phase);
    token_agent_seq_item tok_mon_item;
    
    super.run_phase(phase);
    
    //forever begin
    //  taf_mon_tok.get(tok_mon_item);
    //  `uvm_info("AICD REF MODEL", $sformatf("Received Token item: \n%s", tok_mon_item.sprint()), UVM_LOW)
    //end

  endtask : run_phase


  function void reset();
    `uvm_info("ai_cd_model", "Resetting model", UVM_HIGH)
    
    //tok_cons_q.delete();
    //tok_prod_q.delete();

    //reset regmodel
    //regmodel.reset();
  endfunction


  virtual function void check_phase(uvm_phase phase);
    if (m_cfg.tkn_consume_produce_parity_en == 1) begin
      check_token_number_eot();
    end
  endfunction : check_phase

  function void check_token_number_eot();
    foreach (local_tokens[i]) begin
      if (local_tokens[i] != 0) begin
        `uvm_error("REF_MODEL",$sformatf("LOCAL Token[%0d]=%0d @EOT",i,local_tokens[i]))
      end
    end
    foreach (global_tokens[i]) begin
      if (global_tokens[i] != 0) begin
        `uvm_error("REF_MODEL",$sformatf("GLOBAL Token[%0d]=%0d @EOT",i,global_tokens[i]))
      end
    end
  endfunction : check_token_number_eot


  function mirror_irq_en();
    bit [64-1:0] data_from_reg;
    /** update variables that come from the register configuration */
    //update IRQ_EN
    data_from_reg = regmodel.irq_en.get();

    `uvm_info("aicd_irq_handler", $sformatf("get_irq_en : Data value from IRQ_EN: 0x%0x", data_from_reg), UVM_LOW)
    update_irq_en(data_from_reg);

    foreach (irq_en[str]) begin
      `uvm_info("aicd_irq_handler", $sformatf("get_irq_en : irq_en[%s]: 0x%0d", str, irq_en[str]), UVM_LOW)
    end
  endfunction : mirror_irq_en


  function bit get_irq_en(string p_irq_name);
    bit [64-1:0] data_from_reg;
    /** update variables that come from the register configuration */
    //update IRQ_EN
    data_from_reg = regmodel.irq_en.get();

    `uvm_info("aicd_irq_handler", $sformatf("get_irq_en : Data value from IRQ_EN: 0x%0x", data_from_reg), UVM_HIGH)
    update_irq_en(data_from_reg);

    foreach (irq_en[str]) begin
      `uvm_info("aicd_irq_handler", $sformatf("get_irq_en : irq_en[%s]: 0x%0d", str, irq_en[str]), UVM_HIGH)
    end

    return irq_en[p_irq_name];
  endfunction : get_irq_en
  

  function bit set_irq_en(bit [64-1:0] a_data);
    regmodel.irq_en.set(.value(a_data));
    `uvm_info("aicd_irq_handler", $sformatf("set_irq_en : Data value from IRQ_EN: 0x%0x", a_data), UVM_HIGH)
    update_irq_en(a_data);

    foreach (irq_en[str]) begin
      `uvm_info("aicd_irq_handler", $sformatf("set_irq_en : irq_en[%s]: 0x%0d", str, irq_en[str]), UVM_HIGH)
    end
  endfunction : set_irq_en

  
  function void update_irq_en(bit [64-1:0] a_data);
    irq_en["TASK_LIST_DONE"]                = a_data[0];
    irq_en["COMMAND_DROPPED"]               = a_data[1];
    irq_en["COMMAND_EMPTY_TASK_LIST"]       = a_data[2];
    irq_en["INSTR_AXI_RESP_SLVERR"]         = a_data[3];
    irq_en["INSTR_AXI_RESP_DECERR"]         = a_data[4];
    irq_en["INSTR_DST_ID_MAPPING"]          = a_data[5];
    irq_en["INSTR_PATCH_MODE_MAPPING"]      = a_data[6];
    irq_en["INSTR_PATCH_ID_0_MAPPING"]      = a_data[7];
    irq_en["INSTR_PATCH_ID_1_MAPPING"]      = a_data[8];
    irq_en["INSTR_TOKEN_ILLEGAL_OPCODE"]    = a_data[9];
    irq_en["INSTR_TOKEN_LOCAL_MAP_EMPTY"]   = a_data[10];
    irq_en["INSTR_TOKEN_GLOBAL_MAP_EMPTY"]  = a_data[11];
    irq_en["INSTR_TOKEN_LOCAL_MAPPING"]     = a_data[12];
    irq_en["INSTR_TOKEN_GLOBAL_MAPPING"]    = a_data[13];
    irq_en["COPY_DATA_MISALIGNED"]          = a_data[14];
    irq_en["COPY_FILL_COUNTER_DONE_POP"]    = a_data[15];
    irq_en["COPY_FILL_COUNTER_OVERFLOW"]    = a_data[16];
    irq_en["COPY_AXI_READ_RESP_SLVERR"]     = a_data[17];
    irq_en["COPY_AXI_READ_RESP_DECERR"]     = a_data[18];
    irq_en["COPY_AXI_WRITE_RESP_SLVERR"]    = a_data[19];
    irq_en["COPY_AXI_WRITE_RESP_DECERR"]    = a_data[20];
    irq_en["DBG_SW_INTERRUPT"]              = a_data[32];
  endfunction : update_irq_en


  function bit64_t get_pred_irq_status();
    bit [64-1:0] a_data;
    a_data[0]  = irq_status["TASK_LIST_DONE"]               ;
    a_data[1]  = irq_status["COMMAND_DROPPED"]              ;
    a_data[2]  = irq_status["COMMAND_EMPTY_TASK_LIST"]      ;
    a_data[3]  = irq_status["INSTR_AXI_RESP_SLVERR"]        ;
    a_data[4]  = irq_status["INSTR_AXI_RESP_DECERR"]        ;
    a_data[5]  = irq_status["INSTR_DST_ID_MAPPING"]         ;
    a_data[6]  = irq_status["INSTR_PATCH_MODE_MAPPING"]     ;
    a_data[7]  = irq_status["INSTR_PATCH_ID_0_MAPPING"]     ;
    a_data[8]  = irq_status["INSTR_PATCH_ID_1_MAPPING"]     ;
    a_data[9]  = irq_status["INSTR_TOKEN_ILLEGAL_OPCODE"]   ;
    a_data[10] = irq_status["INSTR_TOKEN_LOCAL_MAP_EMPTY"]  ;
    a_data[11] = irq_status["INSTR_TOKEN_GLOBAL_MAP_EMPTY"] ;
    a_data[12] = irq_status["INSTR_TOKEN_LOCAL_MAPPING"]    ;
    a_data[13] = irq_status["INSTR_TOKEN_GLOBAL_MAPPING"]   ;
    a_data[14] = irq_status["COPY_DATA_MISALIGNED"]         ;
    a_data[15] = irq_status["COPY_FILL_COUNTER_DONE_POP"]   ;
    a_data[16] = irq_status["COPY_FILL_COUNTER_OVERFLOW"]   ;
    a_data[17] = irq_status["COPY_AXI_READ_RESP_SLVERR"]    ;
    a_data[18] = irq_status["COPY_AXI_READ_RESP_DECERR"]    ;
    a_data[19] = irq_status["COPY_AXI_WRITE_RESP_SLVERR"]   ;
    a_data[20] = irq_status["COPY_AXI_WRITE_RESP_DECERR"]   ;
    a_data[32] = irq_status["DBG_SW_INTERRUPT"]             ;

    return a_data;
  endfunction : get_pred_irq_status


  task compare_irq_status();
    uvm_status_e status;
    bit [64-1:0] data_from_reg;
    bit [64-1:0] data_from_model;

    regmodel.irq_status.read(status, data_from_reg);
    data_from_model = get_pred_irq_status();

    if (data_from_reg != data_from_model) begin
      `uvm_error("aicd_irq_handler", $sformatf("IRQ SATUS MISMATCH data_from_reg = %0h  |  data_from_model =  %0h ", data_from_reg, data_from_model))
    end
  endtask : compare_irq_status


  task mirror_irq_status();
    uvm_status_e status;
    bit [64-1:0] data_from_reg;
    /** update variables that come from the register configuration */
    //update IRQ_STATUS
    //regmodel.irq_status.read(status, data_from_reg);
    data_from_reg = regmodel.irq_status.get();
    // fields
    irq_status["TASK_LIST_DONE"]                = data_from_reg[0];
    irq_status["COMMAND_DROPPED"]               = data_from_reg[1];
    irq_status["COMMAND_EMPTY_TASK_LIST"]       = data_from_reg[2];
    irq_status["INSTR_AXI_RESP_SLVERR"]         = data_from_reg[3];
    irq_status["INSTR_AXI_RESP_DECERR"]         = data_from_reg[4];
    irq_status["INSTR_DST_ID_MAPPING"]          = data_from_reg[5];
    irq_status["INSTR_PATCH_MODE_MAPPING"]      = data_from_reg[6];
    irq_status["INSTR_PATCH_ID_0_MAPPING"]      = data_from_reg[7];
    irq_status["INSTR_PATCH_ID_1_MAPPING"]      = data_from_reg[8];
    irq_status["INSTR_TOKEN_ILLEGAL_OPCODE"]    = data_from_reg[9];
    irq_status["INSTR_TOKEN_LOCAL_MAP_EMPTY"]   = data_from_reg[10];
    irq_status["INSTR_TOKEN_GLOBAL_MAP_EMPTY"]  = data_from_reg[11];
    irq_status["INSTR_TOKEN_LOCAL_MAPPING"]     = data_from_reg[12];
    irq_status["INSTR_TOKEN_GLOBAL_MAPPING"]    = data_from_reg[13];
    irq_status["COPY_DATA_MISALIGNED"]          = data_from_reg[14];
    irq_status["COPY_FILL_COUNTER_DONE_POP"]    = data_from_reg[15];
    irq_status["COPY_FILL_COUNTER_OVERFLOW"]    = data_from_reg[16];
    irq_status["COPY_AXI_READ_RESP_SLVERR"]     = data_from_reg[17];
    irq_status["COPY_AXI_READ_RESP_DECERR"]     = data_from_reg[18];
    irq_status["COPY_AXI_WRITE_RESP_SLVERR"]    = data_from_reg[19];
    irq_status["COPY_AXI_WRITE_RESP_DECERR"]    = data_from_reg[20];
    irq_status["DBG_SW_INTERRUPT"]              = data_from_reg[32];
  endtask : mirror_irq_status



  function void set_irq_status(string p_irq_name);
  //task trigger_irq(string p_irq_name);
    irq_status[p_irq_name] = 1;

    `uvm_info("aicd_irq_handler", $sformatf("set_irq_status : irq_status[%s]: 0x1", p_irq_name), UVM_LOW)

    //start irq handler if irq enabled
    if (irq_en[p_irq_name]) begin
      fork begin
        fork begin 
          handle_irq(p_irq_name);
        end join_none
      end join 
    end 

  //endtask :  trigger_irq
  endfunction :  set_irq_status


  virtual task halt_acd_execution();
    irq_active.get(1);
    `uvm_info("aicd_irq_handler", $sformatf("Grabbed irq_active semaphore"), UVM_LOW)
  endtask : halt_acd_execution

  virtual task resume_acd_execution();
    irq_active.put(1);
    `uvm_info("aicd_irq_handler", $sformatf("Released irq_active semaphore"), UVM_LOW)
  endtask : resume_acd_execution


  //TODO: finish IRQ Handler implementation
  task handle_irq(string p_irq_name);
    uvm_status_e status;
    bit [64-1:0] data_from_model;
    //string gate_exec_except_irqs[] = '{"TASK_LIST_DONE"};

    `uvm_info("aicd_irq_handler", $sformatf("Initiating IRQ handler : irq_status[%s]", p_irq_name), UVM_LOW)

    `uvm_info("aicd_irq_handler", $sformatf("Waiting to grab irq_active semaphore"), UVM_LOW)
    //if (! p_irq_name inside {gate_exec_except_irqs}) begin
    //if (! p_irq_name inside {'{gate_exec_except_irqs}}) begin
    //if (! p_irq_name inside {"TASK_LIST_DONE"}) begin
    if (p_irq_name != "TASK_LIST_DONE") begin
      halt_acd_execution();
    end

    //if compare_status_reg_on_irq then compare_irq_status();
    //compare_irq_status();

    //wait for irq to be asserted 

    //wait random delay
    #10us; //ToDO: add random delay

    //clear irq by reg write 
    data_from_model = get_pred_irq_status();
    regmodel.irq_status.write(status, data_from_model);
    `uvm_info("aicd_irq_handler", $sformatf("Wrote irq_status reg to reset IRQ"), UVM_LOW)

    //wait for irq to be de-asserted
    //wait irq_if
    
    //let cmd execution resume flow
    //if (! p_irq_name inside {gate_exec_except_irqs}) begin
    //if (! p_irq_name inside {'{gate_exec_except_irqs}}) begin
    //if (! p_irq_name inside {"TASK_LIST_DONE"}) begin
    if (p_irq_name != "TASK_LIST_DONE") begin
      resume_acd_execution();
    end 


  endtask : handle_irq



endclass
`endif
