`ifndef IAU_REF_MODEL_SV
`define IAU_REF_MODEL_SV

`uvm_analysis_imp_decl (_DP_CMD)
class iau_ref_model extends uvm_component;
  `uvm_component_utils(iau_ref_model)

  svt_axi_transaction cfg_item;
  svt_axi_transaction data_item;
  svt_axi_transaction data_out_item;
  iau_seq_item iau_item;
  iau_seq_item iau_out_item;
  token_agent_seq_item  tok_cons_q [$];
  token_agent_seq_item  tok_prod_q [$];

  //declare queue to save the DP commands that will be received from ai_core_dp_cmd_gen_model
  ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_command#(aic_dp_cmd_gen_pkg::dummy_dp_command_t)   dp_command_q[$];
  ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_model#(aic_dp_cmd_gen_pkg::dummy_dp_command_t)     dp_cmd_model;

//declare analysis port that will be connected to ai_core_dp_cmd_gen_model to send the commands to be used by the model
  uvm_analysis_port#(ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_cmdb) ap_to_dp_cmd_model;
  //declare analysis port that will be connected to ai_core_dp_cmd_gen_model to receive DP commands generated by the model
  uvm_analysis_imp_DP_CMD#(ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_command#(aic_dp_cmd_gen_pkg::dummy_dp_command_t), iau_ref_model) analysis_imp_dp_commands;


  uvm_tlm_analysis_fifo#(iau_seq_item) taf_mon_iau;
  uvm_tlm_analysis_fifo#(svt_axi_transaction) taf_mon_cfg;
  uvm_tlm_analysis_fifo#(svt_axi_transaction) taf_mon_data;
  uvm_analysis_port#(token_agent_seq_item) ap_tok_out;

  uvm_analysis_port#(svt_axi_transaction) ap_stream_out;
  uvm_analysis_port#(iau_seq_item) ap_iau_out;

  IAU_RAL regmodel;
  bit exec_en;
  bit header_received;
  bit cmd_run;
  bit signed_op = 1;
  bit sat_op;
  bit ignore_segfault = 1;
  bit dbg_sw_irq; 
  bit push_no_tlast;
  bit has_push_tlast;
  bit irq_sent;
  bit ptr_rst;

  bit [`SVT_AXI_MAX_TDATA_WIDTH-1:0] in_dt_stream_q[$];
  bit [PWORD_SIZE-1:0][OUT_WORD_DW-1:0] in_dt_sign_ext, dt_src0, dt_src1;
  bit [PWORD_SIZE-1:0][OUT_WORD_DW-1:0] dt_out_q[$];
  bit [OUT_WORD_DW:0] sum;
  bit [PWORD_SIZE-1:0][OUT_WORD_DW-1:0] acc_reg [ACC_REG_SIZE];
  iau_common_pkg::iau_dp_cmd_t prog_mem [int];

  iau_cmd_header_t curr_header;
  iau_cmd_header_t header_q [$];
  
  iau_cmd_tr curr_cmd;
  iau_cmd_tr cmd_q[$];

  iau_common_pkg::iau_dp_cmd_t curr_instr;

  
  bit irq_en[irq_t] = '{
    ERR_ACT_STREAM_IN          : 0,
    ERR_ACT_STREAM_OUT         : 0,
    ERR_EARLY_TLAST_STREAM_IN  : 0,
    ERR_EARLY_TLAST_STREAM_OUT : 0,
    ERR_PRG_SEGFAULT           : 0,
    ERR_PRG_LEN_ZERO           : 0,
    ERR_LOOP_ITER_ZERO         : 0,
    ERR_ILLEGAL_RFS_INSTR      : 0,
    CMDBLK_CMD_DROPPED         : 0,
    DBG_SW_INTERRUPT           : 0
  };

  bit irq[irq_t] = '{
    ERR_ACT_STREAM_IN          : 0,
    ERR_ACT_STREAM_OUT         : 0,
    ERR_EARLY_TLAST_STREAM_IN  : 0,
    ERR_EARLY_TLAST_STREAM_OUT : 0,
    ERR_PRG_SEGFAULT           : 0,
    ERR_PRG_LEN_ZERO           : 0,
    ERR_LOOP_ITER_ZERO         : 0,
    ERR_ILLEGAL_RFS_INSTR      : 0,
    CMDBLK_CMD_DROPPED         : 0,
    DBG_SW_INTERRUPT           : 0
  };


  bit [CMD_MEM_WIDTH-1:0] aux_cmd;
  int cmd_num_rows;
  int cmd_cnt;

  function new(string name ="", uvm_component parent = null);
    super.new(name,parent);
    analysis_imp_dp_commands = new("analysis_imp_dp_commands", this);
  endfunction

  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);

    //output data generated by ref_model
    ap_stream_out = new("ap_stream_out",this);
    ap_iau_out    = new("ap_iau_out",this);
    ap_tok_out    = new("ap_tok_out",this);
    iau_item      = new("iau_item");
    cfg_item      = new("cfg_item");
    data_item     = new("data_item");

    //input data fifos
    taf_mon_cfg  = new("taf_mon_cfg", this);
    taf_mon_data = new("taf_mon_data", this);
    taf_mon_iau  = new("taf_mon_iau", this);

    // DP command Model
    dp_cmd_model = ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_model#(aic_dp_cmd_gen_pkg::dummy_dp_command_t)::type_id::create("dp_cmd_model", this);
    ap_to_dp_cmd_model = new("ap_to_dp_cmd_model",this);
  endfunction : build_phase

  virtual function void connect_phase(uvm_phase phase);
    super.connect_phase(phase);
    // Connect this analysis port to model analysis export
    this.ap_to_dp_cmd_model.connect(dp_cmd_model.analysis_export);
    // Connect Scoreboards
    dp_cmd_model.command_ap.connect(this.analysis_imp_dp_commands);
  endfunction : connect_phase


  virtual task run_phase(uvm_phase phase);
    super.run_phase(phase);
    reset();
    forever begin
      fork
        forever begin
          svt_axi_transaction item = new;
          taf_mon_cfg.get(item);
          cfg_item.do_copy(item);
          `uvm_info(get_name, $sformatf("got item: %s", cfg_item.sprint()), UVM_LOW)
          //cfg_item.addr = cfg_item.addr[15:0];
          if (cfg_item.xact_type == svt_axi_transaction::WRITE) begin
            if (cfg_item.addr inside {[IAU_DPCMD_ADDR_ST: IAU_DPCMD_ADDR_END]}) begin
              foreach (cfg_item.data[i]) begin
                int num_valid_writes = $countones(cfg_item.wstrb[i]) / 2;
                for (int j = 0; j < num_valid_writes; j++) begin
                  decode_addr(cfg_item.addr, cfg_item.data[i][(j*16)+:16]);
                  if (cfg_item.burst_type != svt_axi_transaction::FIXED)
                    cfg_item.addr+=2;
                end
              end //foreach data
            end //if addr
            else begin
              foreach (cfg_item.data[i]) begin
                decode_addr(cfg_item.addr, cfg_item.data[i]);
                if (cfg_item.burst_type != svt_axi_transaction::FIXED)
                  cfg_item.addr+=8;
              end
            end
          end // if write
        end //forever
        forever exec_cmd();
        forever exec_program();
        forever begin
          taf_mon_iau.get(iau_item);
          if (!iau_item.reset_an_i) begin
            reset();
            break;
          end
        end
      join_any
      disable fork;
    end
  endtask : run_phase

  virtual function void write_DP_CMD(ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_command#(aic_dp_cmd_gen_pkg::dummy_dp_command_t) t);
    dp_command_q.push_back(t);
    `uvm_info("iau_mdl", $sformatf("Received a DP command: %s", t.sprint()), UVM_HIGH)
  endfunction

  function void reset();
    `uvm_info("iau_mdl", "Resetting model", UVM_HIGH)
    exec_en         = 0;
    header_received = 0;
    cmd_run         = 0;
    signed_op       = 1;
    sat_op          = 0;
    ignore_segfault = 1;
    dbg_sw_irq      = 0;
    in_dt_sign_ext  = 0;
    dt_src0         = 0;
    dt_src1         = 0;
    sum             = 0;
    curr_instr      = 0;
    push_no_tlast   = 0;
    has_push_tlast  = 0;
    irq_sent        = 0;
    ptr_rst         = 0;
    cmd_num_rows    = 0;
    header_q.delete();
    cmd_q.delete();
    in_dt_stream_q.delete();
    dt_out_q.delete();
    tok_cons_q.delete();
    tok_prod_q.delete();
    foreach (acc_reg[i])
      acc_reg[i] = 0;

    foreach(irq_en[i]) begin
      irq_en[i] = 0;
      irq[i]    = 0;
    end
    taf_mon_data.flush();
  endfunction

  task send_irq_item();
    iau_out_item = new();
    iau_out_item.irq_o = 1;
    `uvm_info("iau_mdl", $sformatf("sending item w/ irq: %p", irq), UVM_FULL)
    ap_iau_out.write(iau_out_item);
  endtask

  task decode_addr(bit [27:0] addr, bit_dw_t data);
    `uvm_info("iau_mdl", $sformatf("Decoding addr: %0h, data: %0h", addr, data), UVM_HIGH)
    //iau_csr
    if (addr == regmodel.cmdblk_ctrl.get_address()) begin
      exec_en = data[0];
      //ptr_rst = data[1];
      `uvm_info("iau_mdl", $sformatf("exec_en: %b", exec_en), UVM_HIGH)
    end else if (addr == regmodel.dp_ctrl.get_address()) begin
      signed_op       = data[SIGNED_OP];
      sat_op          = data[SAT_OP];
      ignore_segfault = data[IGNORE_SEGFAULT];
      dbg_sw_irq      = data[DBG_SW_IRQ]; 
      if (dbg_sw_irq && irq_en[DBG_SW_INTERRUPT] && !irq[DBG_SW_INTERRUPT]) begin
        `uvm_info("iau_mdl", "[IRQ] DBG_SW_INTERRUPT: wrote dp_ctrl.dbg_sw_irq = 1, generating interruption", UVM_HIGH)
          irq[DBG_SW_INTERRUPT] = 1;
          send_irq_item();
      end
      `uvm_info("iau_mdl", $sformatf("CFG signed: %b, saturated: %b ignore_segfault: %b", signed_op, sat_op, ignore_segfault), UVM_HIGH)
    end else if (addr == 'h10) begin
      foreach(irq_en[i]) irq_en[i] = data[i];
      `uvm_info("iau_mdl", $sformatf("irq_en: %p", irq_en), UVM_HIGH)
    end else if (addr == 'h18) begin
      //irq_status, write 1 to clear
      foreach(irq[i]) irq[i] = data[i] ? 0 : irq[i];


      //clear dbg_sw_interrupt but dbg_sw_irq still in 1, regenerate the irq
      if (dbg_sw_irq && irq_en[DBG_SW_INTERRUPT] && !irq[DBG_SW_INTERRUPT]) begin
        `uvm_info("iau_mdl", "[IRQ] DBG_SW_INTERRUPT: wrote dp_ctrl.dbg_sw_irq = 1, generating interruption", UVM_HIGH)
        irq[DBG_SW_INTERRUPT] = 1;
        send_irq_item();
      end

      `uvm_info("iau_mdl", $sformatf("irq_status: %p", irq), UVM_HIGH)

    end else if (addr inside {[IAU_DPCMD_ADDR_ST : IAU_DPCMD_ADDR_END]}) begin
      //cmdgen
      addr = (addr - IAU_DPCMD_ADDR_ST) >> 1;
      prog_mem[addr] = data;
      `uvm_info("iau_mdl", $sformatf("prog mem[%0h]: %p", addr, prog_mem[addr]), UVM_HIGH)
    end else if (addr inside {[IAU_CMD_BLOCK_ADDR_ST:IAU_CMD_BLOCK_ADDR_END]}) begin
      //HEADER + COMMAND
      if (header_received) begin
        decode_cmd(data);
      end else begin
        header_received = 1;
        decode_header(data);
      end
    end
  endtask : decode_addr

  function void decode_header (bit_dw_t p_data);
    /** push back header information to header_q and tok_prod/cons_q */
    header_q.push_back(iau_cmd_header_t'(p_data));
    tok_cons_add_to_queue(p_data);
    tok_prod_add_to_queue(p_data);

    /** update cmd_num_rows variable depending on the format type */
    cmd_num_rows = get_cmd_num_rows(header_q[$].format);
 
    if(header_q[$].format == aic_dp_cmd_gen_pkg::Bypass) begin
      iau_cmd_tr empty_cmd = iau_cmd_tr::type_id::create("empty_cmd");
      // since the bypass command is only the header, means that the next command will start again with the header. So reset header_received variable.
      header_received = 0;
      //update cmd with all zeros and push it back to cmd_q
      cmd_q.push_back(iau_cmd_tr'(empty_cmd));
    end
  endfunction : decode_header

  task decode_cmd (bit_dw_t p_data);
    aux_cmd[AXI_DW * cmd_cnt++ +: AXI_DW] = p_data;

    if (cmd_cnt == cmd_num_rows) begin
      iau_cmd_tr     cmd_to_model = iau_cmd_tr::type_id::create("cmd_to_model");
      cmd_to_model = get_full_cmd_from_alternative_cmd(aux_cmd, header_q[$].format);

      cmd_q.push_back(iau_cmd_tr'(cmd_to_model));
      cmd_cnt = 0;
      header_received = 0;
      `uvm_info("iau_mdl", $sformatf("cmd: %s", cmd_to_model.sprint()), UVM_HIGH)
    end
    if (cmd_q.size() > aic_common_pkg::AIC_GEN_CMDB_CMD_FIFO_DEPTH) begin
      `uvm_info("iau_mdl", "[IRQ] CMDBLK_CMD_DROPPED: Cmdblk fifo full, dropping command", UVM_LOW)
      `uvm_info("iau_mdl", $sformatf("cmd dropped: %p, cmd: %p", header_q[$], cmd_q[$]), UVM_HIGH)
      void'(header_q.pop_back);
      void'(cmd_q.pop_back);
      if (irq_en[CMDBLK_CMD_DROPPED] && !irq[CMDBLK_CMD_DROPPED]) begin
        irq[CMDBLK_CMD_DROPPED] = 1;
        send_irq_item(); 
      end
    end
  endtask : decode_cmd


  //get the exec_en from csr and the cmd from cmdblock fifo
  //and enable execution of standard or bypass mode
  task exec_cmd();
    wait (!cmd_run && cmd_q.size() && header_q.size() == cmd_q.size());
    if (exec_en) begin
      `uvm_info("iau_mdl", $sformatf("popping header/cmd size: %0d / %0d, header: %p, cmd: %p", 
                  header_q.size, cmd_q.size, header_q[0], cmd_q[0]), UVM_HIGH)

      curr_header = header_q.pop_front();
      curr_cmd    = cmd_q.pop_front();


      `uvm_info("iau_mdl", $sformatf("Cmd execution, cmd: %0s", curr_header.format.name()), UVM_HIGH)
      if ( curr_header.format == aic_dp_cmd_gen_pkg::Bypass)
        cmd_run = 1;
      else begin
        /*
        if (curr_cmd.loop_iter == 0) begin
          `uvm_info("iau_mdl", "[IRQ] ERR_LOOP_ITER_ZERO: Invalid Program, iteration == 0", UVM_LOW)
          irq[ERR_LOOP_ITER_ZERO] = 1;
        end
        else if (curr_cmd.loop_len == 0) begin
          `uvm_info("iau_mdl", "[IRQ] ERR_PRG_LEN_ZERO: Invalid Program, length == 0", UVM_LOW)
          irq[ERR_PRG_LEN_ZERO] = 1;
        end
        else if (curr_cmd.loop_start + curr_cmd.loop_len > PROG_MEM_DEPTH) begin
          `uvm_info("iau_mdl", "[IRQ] ERR_PRG_SEGFAULT: Invalid Program, trying to access program outside program memory", UVM_LOW)
          irq[ERR_PRG_SEGFAULT] = 1;
          `uvm_info("iau_mdl", $sformatf("[IRQ] ERR_PRG_SEGFAULT: ignore_segfault: %b, %0s!", ignore_segfault, ignore_segfault ? "cmd will be executed" : "program aborted"), UVM_LOW)
          if (ignore_segfault) cmd_run = 1;
        end

        if ( irq[ERR_LOOP_ITER_ZERO] && irq_en[ERR_LOOP_ITER_ZERO]  ||
             irq[ERR_PRG_LEN_ZERO]   && irq_en[ERR_PRG_LEN_ZERO]    ||
             irq[ERR_PRG_SEGFAULT]   && irq_en[ERR_PRG_SEGFAULT] ) begin 
          send_irq_item();
        end
        else */
          cmd_run = 1;
      end
      //remove consumer token from queue and send it to the scoreboard
      tok_cons_remove_from_queue();
    end
  endtask : exec_cmd

  //upon a instruction data request, if no data available in queue
  //wait for a new data stream to continue executing
  task get_data_stream(bit req_data);
    if (in_dt_stream_q.size == 0 && req_data) begin
      `uvm_info("iau_mdl", $sformatf("Waiting Input Data"),UVM_HIGH)
      taf_mon_data.get(data_item);
      in_dt_stream_q = data_item.tdata;
    end
  endtask

  //receives the command loop parameters and instructions
  //and execute them
  task exec_program();
    int curr_last_main_idx;
    wait (cmd_run == 1);
    ap_to_dp_cmd_model.write(ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_cmdb'(curr_cmd));
    if(curr_header.format != aic_dp_cmd_gen_pkg::Bypass) begin
      if(curr_cmd.format inside {[aic_dp_cmd_gen_pkg::LoopsM1N0:aic_dp_cmd_gen_pkg::LoopsM1N2]}) begin
        curr_last_main_idx = 0;
      end
      else if(curr_cmd.format inside {[aic_dp_cmd_gen_pkg::LoopsM2N0:aic_dp_cmd_gen_pkg::LoopsM2N2]}) begin
        curr_last_main_idx = 1;
      end
      else if(curr_cmd.format inside {[aic_dp_cmd_gen_pkg::LoopsM3N0:aic_dp_cmd_gen_pkg::LoopsM3N2]}) begin
        curr_last_main_idx = 2;
      end
      while (cmd_run) begin
        //check the size of the dp_command_q that is filled by the model output
        if(dp_command_q.size()) begin
          ai_core_dp_cmd_gen_uvm_pkg::ai_core_dp_cmd_gen_command#(aic_dp_cmd_gen_pkg::dummy_dp_command_t) aux_dp_cmd;
          bit [63:0] prog_mem_addr;

          //load DP command which will have the address on "data" field
          aux_dp_cmd = dp_command_q.pop_front();
          prog_mem_addr = aux_dp_cmd.data;
          `uvm_info("iau_mdl", $sformatf("exec_program address %0d", prog_mem_addr), UVM_HIGH)

          curr_instr = prog_mem[prog_mem_addr];
          
          //from Section 5.1 of IAU SPEC
          //prevents that only last instr w/ dst = PUSH-LAST in the LAST LOOP is executed in the entire program
          //just push otherwise
          if (curr_instr.dst[3] && curr_instr.dst[0] && !(aux_dp_cmd.last)) begin
            `uvm_info("iau_mdl", $sformatf("Instr w/ push-last dst and not last loop: downgrade to push dst"), UVM_HIGH)
            curr_instr.dst[0] = 0;
          end

          //not NOP
          if (curr_instr.opcode > 0) begin
            //get data stream if current instruction source = pop
            bit pop_data = curr_instr.src0[3] || curr_instr.opcode > OP_MV && curr_instr.src1[3];
            
            //IRQ: pop is executed after an input stream has received 
/*            if (loop_iter > 0 && pop_data && in_dt_stream_q.size == 0 && !irq[ERR_EARLY_TLAST_STREAM_IN] && !irq_sent) begin
                `uvm_info("iau_mdl", $sformatf("[IRQ] ERR_EARLY_TLAST_STREAM_IN: pop executed after input stream has been fully consumed"), UVM_LOW)
              irq[ERR_EARLY_TLAST_STREAM_IN] = 1;
              irq_sent = 1;
              send_irq_item();
            end
*/
            get_data_stream(pop_data);
            //rfs set: execute same istr with whole input stream
            if (curr_instr.rfs) begin
              //rfs instr with no pop : generate irq
              if (!pop_data && irq_en[ERR_ILLEGAL_RFS_INSTR]) begin
                `uvm_info("iau_mdl", $sformatf("[IRQ] ERR_ILLEGAL_RFS_INSTR: rfs instr with no pop"), UVM_LOW)
                irq[ERR_ILLEGAL_RFS_INSTR] = 1;
              end
              else begin
                while (in_dt_stream_q.size()) begin
                  if (curr_instr.dst[3]) begin
                    if (in_dt_stream_q.size() != 1) begin
                      //from Section 3.2 of IAU SPEC
                      //the input TLAST signal is always fowarded to output
                      `uvm_info("iau_mdl", $sformatf("Instr w/ rfs & push-last dst: foward TLAST of input (which is 0) "), UVM_HIGH)
                      curr_instr.dst[0] = 0;
                    end else
                      curr_instr.dst[0] = 1;
                  end
                  exec_icode(in_dt_stream_q.pop_front());
                end
              end
            end
            else
              exec_icode(pop_data ? in_dt_stream_q.pop_front() : 0);

            if (curr_instr.dst[3]) begin
              push_no_tlast = curr_instr.dst[0] ? 0 : 1;
              //IRQ: push is executed after output stream has benn fully produced
              if (curr_instr.dst[0] && !curr_instr.rfs && has_push_tlast && irq_en[ERR_EARLY_TLAST_STREAM_OUT]) begin
                `uvm_info("iau_mdl", $sformatf("[IRQ] ERR_EARLY_TLAST_STREAM_OUT: push executed after out stream has been fully produced"), UVM_LOW)
                irq[ERR_EARLY_TLAST_STREAM_OUT] = 1;
              end
              has_push_tlast = curr_instr.dst[0];
            end
          end //end_if_op_1
          else
            `uvm_info("iau_mdl", $sformatf("Executing OP_NOP"), UVM_HIGH)

          `uvm_info("iau_mdl", $sformatf("overall_last: %0d | curr_last_main_idx: %0d | main_index: %0d | prog_mem_addr: %0d | end_addr: %0d", aux_dp_cmd.overall_last, curr_last_main_idx, aux_dp_cmd.main_index, prog_mem_addr, curr_cmd.get_end(1, aux_dp_cmd.main_index)), UVM_HIGH)
          if(aux_dp_cmd.overall_last && (curr_last_main_idx == aux_dp_cmd.main_index) && prog_mem_addr == curr_cmd.get_end(1, aux_dp_cmd.main_index)) begin
            `uvm_info("iau_mdl", $sformatf("Program done"), UVM_HIGH)
            cmd_run = 0;
          end
          has_push_tlast = 0;
        end
      end 
    end 
    else begin
      `uvm_info("iau_mdl", $sformatf("Executing bypass cmd, input data forwarded to output"), UVM_HIGH)
      `uvm_info("iau_mdl", $sformatf("Waiting Input Data"),UVM_HIGH)
      taf_mon_data.get(data_item);
      `uvm_info("iau_mdl", $sformatf("Got data: %p", data_item.sprint),UVM_HIGH)
      data_out_item = new();
      //IAU Documentation, section 3.2
      //bypass is implemented with a mv with rfs=1
      //but in ref mdl, just forward the input data to ouput
      data_out_item.tdata = new[data_item.tdata.size()];
      foreach (data_item.tdata[i]) begin
        stream_to_word_and_sign_ext(data_item.tdata[i]);
        data_out_item.tdata[i] = in_dt_sign_ext;
      end
      ap_stream_out.write(data_out_item);
    end

    if ((push_no_tlast || in_dt_stream_q.size()  || irq[ERR_EARLY_TLAST_STREAM_OUT] || irq[ERR_ILLEGAL_RFS_INSTR]) && !(irq[ERR_PRG_SEGFAULT] && ignore_segfault) ) begin
      //program ended & last push to output does not assert TLAST : output irq
      if (push_no_tlast)
        `uvm_info("iau_mdl", $sformatf("[IRQ] ERR_ACT_STREAM_OUT: Invalid Program, unfinished output stream"), UVM_LOW)

      // not all inputs consumed : input irq
      else if (in_dt_stream_q.size())
        `uvm_info("iau_mdl", $sformatf("[IRQ] ERR_ACT_STREAM_IN: Invalid Program, not all inputs consumed"), UVM_LOW)

      if ( (irq_en[ERR_ACT_STREAM_IN] || irq_en[ERR_ACT_STREAM_OUT] || 
          irq_en[ERR_EARLY_TLAST_STREAM_OUT] || irq_en[ERR_ILLEGAL_RFS_INSTR]) && !irq_sent ) begin
        irq_sent = 1;
        send_irq_item(); 
      end
    end

    //command done, wait for next cmd
    cmd_run = 0;
    `uvm_info("iau_mdl", $sformatf("Program done"), UVM_HIGH)
    //remove producer token from queue and send it to the scoreboard
    tok_prod_remove_from_queue();
  endtask : exec_program

  //convert stream to pixel data and sign extend it from in_dt_width to out_dt_width
  function void stream_to_word_and_sign_ext(bit [AXIS_IW-1:0] dt);
//    `uvm_info("iau_mdl", $sformatf("dt: %0h",dt), UVM_HIGH)
    for (int i = 0; i < PWORD_SIZE; i ++ ) begin
      if (signed_op)
        in_dt_sign_ext[i] = signed'(dt[IN_WORD_DW*i +: IN_WORD_DW]);
      else
        in_dt_sign_ext[i] = dt[IN_WORD_DW*i +: IN_WORD_DW];
      //if (i < 2) `uvm_info("iau_mdl", $sformatf("dt[%0d]: %0h ,in_dt_sign_ext[%0d]: %0h, %b",IN_WORD_DW*i, signed'(dt[IN_WORD_DW*i +: IN_WORD_DW]),i,in_dt_sign_ext[i], in_dt_sign_ext[i]), UVM_HIGH)
    end
  endfunction

  //execute the IAU operations
  task exec_icode(bit [AXIS_IW-1:0] dt_stream);
    `uvm_info("iau_mdl", $sformatf("Executing instruction: %p",curr_instr ), UVM_HIGH)
    //src[3] == 1: get input data
    //mv only uses src0 || add and max uses both
    if (curr_instr.src0[3] || curr_instr.src1[3])
      stream_to_word_and_sign_ext(dt_stream);

    //data from input stream or internal regs
    dt_src0 = curr_instr.src0[3] ? in_dt_sign_ext : acc_reg[curr_instr.src0];
    dt_src1 = curr_instr.src1[3] ? in_dt_sign_ext : acc_reg[curr_instr.src1];

//    `uvm_info("iau_mdl", $sformatf("reg[0]: %0d", acc_reg[0][0]), UVM_HIGH)
//    `uvm_info("iau_mdl", $sformatf("reg[1]: %0d", acc_reg[0][1]), UVM_HIGH)
    case (curr_instr.opcode)
      //OP_MV: executed in the if statement after endcase line
      OP_ADD: begin
        foreach (dt_src0[i]) begin
          if (signed_op) begin
            //sum has 33b to hold carry bit
            sum = signed'(dt_src0[i]) + signed'(dt_src1[i]);
//            if (i < 2)
//              `uvm_info("iau_mdl", $sformatf("a: %0d b : %0d, sum[%0d]: %0d", dt_src0[i], dt_src1[i], i, sum), UVM_HIGH)
            if (sat_op)
              dt_src0[i] = (signed'(sum) > ADD_MAX_POS_VAL) ? ADD_MAX_POS_VAL  : ( (signed'(sum) < ADD_MAX_NEG_VAL) ? ADD_MAX_NEG_VAL : sum );
            else
              //overflow: ignore msb (carry) bit
              dt_src0[i] = sum;
          end else begin
            sum = dt_src0[i] + dt_src1[i];
            dt_src0[i] = (sat_op && sum > ADD_MAX_UNSIGNED_VAL) ? ADD_MAX_UNSIGNED_VAL : sum;
          end
        end
      end
      OP_MAX: begin
        foreach (dt_src0[i]) begin
          if (signed_op) 
            dt_src0[i] = signed'(dt_src0[i]) > signed'(dt_src1[i]) ? dt_src0[i] : dt_src1[i];
          else
            dt_src0[i] = dt_src0[i] > dt_src1[i] ? dt_src0[i] : dt_src1[i];
        end
      end
      OP_MIN: begin
        foreach (dt_src0[i]) begin
          if (signed_op) 
            dt_src0[i] = signed'(dt_src0[i]) < signed'(dt_src1[i]) ? dt_src0[i] : dt_src1[i];
          else
            dt_src0[i] = dt_src0[i] < dt_src1[i] ? dt_src0[i] : dt_src1[i];
        end
      end

    endcase

    //store result into acc regs
    if (!curr_instr.dst[3]) begin
      acc_reg[curr_instr.dst] = dt_src0;
      `uvm_info("iau_mdl", $sformatf("Write result acc_reg[%0d], d[0]: %0h, d[1]: %0h ",curr_instr.dst,
                acc_reg[curr_instr.dst][0], acc_reg[curr_instr.dst][1]), UVM_FULL)
    end
    //push to output stream
    else begin
      dt_out_q.push_back(dt_src0);
    
      //push LAST output
      if (curr_instr.dst[0]) begin
        data_out_item = new();
        data_out_item.tdata = new[dt_out_q.size()];
        foreach(dt_out_q[i])
          data_out_item.tdata[i] = dt_out_q[i];
        dt_out_q.delete();
        `uvm_info("iau_mdl", $sformatf("Push-last output data stream, tdata size: %0d", data_out_item.tdata.size()), UVM_HIGH)
        foreach (data_out_item.tdata[i]) `uvm_info("iau_mdl", $sformatf("%h", data_out_item.tdata[i]), UVM_FULL);
        ap_stream_out.write(data_out_item);
      end
    end
  endtask : exec_icode


  //function to add to tok_cons_q queue the token new token information
  function void tok_cons_add_to_queue(iau_cmd_header_t p_header);
    token_agent_seq_item l_tok_item;

    l_tok_item = token_agent_seq_item::type_id::create("l_tok_item", this);

    //check into the data if the consumer token bit is active or not
    if(p_header.token_cons==1) begin
      l_tok_item.m_type_enm = TOK_CONS_MON;
    end
    else begin
      l_tok_item.m_type_enm = TOK_NOT_VALID;
    end
    //push the new token to the queue
    tok_cons_q.push_back(l_tok_item);
  endfunction : tok_cons_add_to_queue

  //function to add to tok_prod_q queue the token new token information
  function void tok_prod_add_to_queue(iau_cmd_header_t p_header);
    token_agent_seq_item l_tok_item;

    l_tok_item = token_agent_seq_item::type_id::create("l_tok_item", this);

    //check into the data if the producer token bit is active or not
    if(p_header.token_prod==1) begin
      l_tok_item.m_type_enm = TOK_PROD_MON;
    end
    else begin
      l_tok_item.m_type_enm = TOK_NOT_VALID;
    end
    //push the new token to the queue
    tok_prod_q.push_back(l_tok_item);
  endfunction : tok_prod_add_to_queue

  //function to remove from tok_cons_q queue the token and send to the scoreboard if it is a valid token
  function void tok_cons_remove_from_queue();
    token_agent_seq_item l_tok_item;
    if(tok_cons_q.size() > 0) begin
      l_tok_item = tok_cons_q.pop_front();
      if(l_tok_item.m_type_enm != TOK_NOT_VALID) begin
        //send to the scoreboard
        ap_tok_out.write(l_tok_item);
      end
    end
  endfunction : tok_cons_remove_from_queue

  //function to remove from tok_prod_q queue the token and send to the scoreboard if it is a valid token
  function void tok_prod_remove_from_queue();
    token_agent_seq_item l_tok_item;
    if(tok_prod_q.size() > 0) begin
      l_tok_item = tok_prod_q.pop_front();
      if(l_tok_item.m_type_enm != TOK_NOT_VALID) begin
        //send to the scoreboard
        ap_tok_out.write(l_tok_item);
      end
    end
  endfunction : tok_prod_remove_from_queue




endclass
`endif
