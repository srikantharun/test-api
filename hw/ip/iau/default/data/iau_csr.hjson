// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
{ name: "iau_csr",
  clocking: [{clock: "clk_i", reset: "rst_ni"}],
  bus_interfaces: [
    { protocol: "tlul", direction: "device" }
  ],
  regwidth: "64",
  addrcap: "0x10000",
  axi_intf: True
  param_list : [
    {name:"AXI_AW", type:"int", default:"28"},
    {name:"AXI_IDW", type:"int", default:"9"},
    {name:"AXI_LENW", type:"int", default:"8"}
  ]
  registers: [
    { name: "CMDBLK_CTRL",
      desc: "Control register of the CMD Block.",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
            bits: "0",
            name: "EXEC_EN",
            desc: '''
                  While `EXEC_EN` is high, the block processes commands, that are pushed into the command FIFO.
                  ''',
            resval: 0x0
        }
        {
            bits: "1",
            name: "PTR_RST",
            desc: '''
                  Synchronous active-high reset of the command FIFO's input word pointer.
                  Set and unset `PTR_RST` to reset `CMDBLK_STATUS.IN_WORD_PTR` to 0. Only use this for error recovery.
                  ''',
            resval: 0x0
        }
      ]
    },
    { name: "CMDBLK_STATUS",
      desc: "Status register of the CMD Block.",
      swaccess: "ro",
      hwaccess: "hwo",
      hwext : True
      fields: [
        {
            bits: "1:0",
            name: "STATE",
            desc: '''
                  0: `IDLE` Command FIFO and fill buffer are both empty.
                  1: `FILL` Command FIFO is empty, but there is at least a header in the fill buffer
                  2: `READY` Command FIFO contains at least one item
                  3: `EXECUTE` Outstanding commands is at least 1
                  '''
        }
        {
            bits: "2",
            name: "WAIT_TOKEN",
            desc: '''
                  `WAIT_TOKEN` is high iff a command is waiting at the output buffer of the command FIFO for a token to arrive.
                  '''
        }
        {
            bits: "15:8",
            name: "IN_WORD_PTR",
            desc: '''
                  The input word pointer is used to construct the input data for the command FIFO and
                  points to the next 64bit word of the input data to be received by the next AXI transaction.
                  '''
        }
        {
            bits: "23:16",
            name: "FIFO_CNT",
            desc: '''Fill counter of the command FIFO.'''
        }
        {
            bits: "31:24",
            name: "OUTST_CMDS",
            desc: '''
                  Number of outstanding commands.
                  A command is outstanding iff it has been popped from the command FIFO and sent for execution,
                  but the datapath has not yet signaled that its execution has been done.
                  '''
        }
        {
            bits: "47:32",
            name: "PENDING_TOKENS",
            desc: '''
                  Signals which consume tokens are pending.
                  '''
        }
      ]
    },
    {
      name: "IRQ_EN",
      desc: "Interrupt enable register",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        { bits: "0",
          name: "ERR_ACT_STREAM_IN",
          desc: '''
                Enable IRQ to be raised, if an input stream is still active after the execution of a command.
                '''
        }
        { bits: "1",
          name: "ERR_ACT_STREAM_OUT",
          desc: '''
                Enable IRQ to be raised, if an output stream is still active after the execution of a command.
                '''
        }
        { bits: "2",
          name: "ERR_EARLY_TLAST_STREAM_IN",
          desc: '''
                Enable IRQ to be raised, if a pop is executed even though the input stream has finished.
                '''
        }
        { bits: "3",
          name: "ERR_EARLY_TLAST_STREAM_OUT",
          desc: '''
                Enable IRQ to be raised, if a push is executed even though the output stream has finished.
                '''
        }
        { bits: "4",
          name: "ERR_PRG_SEGFAULT",
          desc: '''
                Enable IRQ to be raised, if a program would attempt to read outside the program memory.
                '''
        }
        { bits: "5",
          name: "ERR_PRG_LEN_ZERO",
          desc: '''
                Enable IRQ to be raised, if a program has an illegal length of zero.
                '''
        }
        { bits: "6",
          name: "ERR_LOOP_ITER_ZERO",
          desc: '''
                Enable IRQ to be raised, if a program has an illegal iterations of zero.
                '''
        }
        { bits: "7",
          name: "ERR_ILLEGAL_RFS_INSTR",
          desc: '''
                Enable IRQ to be raised, if a program has a RFS instruction without pseudo input stream register p0 set and thus without popping from the input stream.
                '''
        }
        { bits: "8",
          name: "CMDBLK_CMD_DROPPED",
          desc: '''
                Enable IRQ flagging of command block FIFO command dropping.
                '''
          resval: 0x1
        }
        { bits: "32",
          name: "DBG_SW_INTERRUPT",
          desc: '''
                Enable IRQ to be raised, if the debug SW interrupt has been triggered.
                '''
        }
      ]
    },
    {
      name: "IRQ_STATUS",
      desc: "Interrupt status register",
      swaccess: "rw1c",
      hwaccess: "hrw"
      fields: [
        { bits: "0",
          name: "ERR_ACT_STREAM_IN",
          desc: '''
                Indicates that an input stream is still active after the execution of a command,
                i.e. no `TLAST` from the current input stream has been received yet.
                '''
        }
        { bits: "1",
          name: "ERR_ACT_STREAM_OUT",
          desc: '''
                Indicates that an output stream is still active after the execution of a command,
                i.e. no `TLAST` for the current output stream has been pushed yet.
                '''
        }
        { bits: "2",
          name: "ERR_EARLY_TLAST_STREAM_IN",
          desc: '''
                Indicates that a pop is executed even though the input stream has finished.
                '''
        }
        { bits: "3",
          name: "ERR_EARLY_TLAST_STREAM_OUT",
          desc: '''
                Indicates that a push is executed even though the output stream has finished.
                '''
        }
        { bits: "4",
          name: "ERR_PRG_SEGFAULT",
          desc: '''
                Indicates that the program would attempt to read outside the program memory,
                i.e. `loop_start + loop_len > prg_mem_size`.
                '''
        }
        { bits: "5",
          name: "ERR_PRG_LEN_ZERO",
          desc: '''
                Indicates that the program has an illegal length of zero, i.e. `loop_len == 0`.
                '''
        }
        { bits: "6",
          name: "ERR_LOOP_ITER_ZERO",
          desc: '''
                Indicates that the program has an illegal iteration count of zero, i.e. `loop_iter == 0`.
                '''
        }
        { bits: "7",
          name: "ERR_ILLEGAL_RFS_INSTR",
          desc: '''
                Indicate that a program has a RFS instruction without pseudo input stream register p0 set and thus without popping from the input stream.
                '''
        }
        { bits: "8",
          name: "CMDBLK_CMD_DROPPED",
          desc: '''
                The command block FIFO had to drop at least one command because the FIFO was already full.
                '''
        }
        { bits: "32",
          name: "DBG_SW_INTERRUPT",
          desc: '''
                Indicates that SW triggered the debug interrupt by setting the `DP_CTRL.DBG_SW_IRQ` to high.
                '''
        }
      ]
    },
    { name: "DP_CTRL",
      desc: "Control register of the datapath.",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
            bits: "0",
            name: "SIGNED_OP",
            desc: '''
                  If `SIGNED_OP == 1'b0`, operands are treated as unsigned.
                  If `SIGNED_OP == 1'b1`, operands are treated as two's complement signed (default).
                  ''',
            resval: 0x1
        }
        {
            bits: "1",
            name: "SAT_OP",
            desc: '''
                  If `SAT_OP == 1'b0`, adders overflow (default).
                  If `SAT_OP == 1'b1`, adders saturate.
                  ''',
            resval: 0x0
        }
        {
            bits: "2",
            name: "IGNORE_SEGFAULT",
            desc: '''
                  If `IGNORE_SEGFAULT == 1'b0`, `DPcmdgen` block aborts execution of programs with segfaults.
                  If `IGNORE_SEGFAULT == 1'b1`, `DPcmdgen` block ignores segfaults (default).

                  ''',
            resval: 0x1
        }
        {
            bits: "32",
            name: "DBG_SW_IRQ",
            desc: '''
                  `DBG_SW_IRQ` is a level-triggered interrupt request.
                  Set `DBG_SW_IRQ` to high to trigger the debug SW interrupt.
                  Interrupt handler must set `DBG_SW_IRQ` to low again.
                  '''
            resval: 0x0
        }
      ]
    },
    { name: "DP_STATUS",
      desc: "Datapath status observarion register.",
      swaccess: "ro",
      hwaccess: "hwo",
      hwext : True
      fields: [
        {
            bits: "0",
            name: "IN0_VLD",
            desc: '''Valid signal of the input AXIS stream after input FIFO / buffer (if present).'''
        }
        {
            bits: "1",
            name: "IN0_RDY",
            desc: '''Ready signal of the input AXIS stream after input FIFO / buffer (if present).'''
        }
        {
            bits: "2",
            name: "IN0_LST",
            desc: '''Last signal of the input AXIS stream after input FIFO / buffer (if present).'''
        }
        {
            bits: "3",
            name: "IN0_STL",
            desc: '''Indicates a stall on the input AXIS stream after input FIFO / buffer (if present).'''
        }
        // {
        //     bits: "4",
        //     name: "IN1_VLD",
        //     desc: '''Valid signal of the second input AXIS stream after input FIFO / buffer (if present).'''
        // }
        // {
        //     bits: "5",
        //     name: "IN1_RDY",
        //     desc: '''Ready signal of the second input AXIS stream after input FIFO / buffer (if present).'''
        // }
        // {
        //     bits: "6",
        //     name: "IN1_LST",
        //     desc: '''Last signal of the second input AXIS stream after input FIFO / buffer (if present).'''
        // }
        // {
        //     bits: "7",
        //     name: "IN1_STL",
        //     desc: '''Indicates a stall on the second input AXIS stream after input FIFO / buffer (if present).'''
        // }
        {
            bits: "8",
            name: "OUT_VLD",
            desc: '''Valid signal of the output AXIS stream before output FIFO / buffer (if present).'''
        }
        {
            bits: "9",
            name: "OUT_RDY",
            desc: '''Ready signal of the output AXIS stream before output FIFO / buffer (if present).'''
        }
        {
            bits: "10",
            name: "OUT_LST",
            desc: '''Last signal of the output AXIS stream before output FIFO / buffer (if present).'''
        }
        {
            bits: "11",
            name: "OUT_STL",
            desc: '''Indicates a stall on the output AXIS stream before output FIFO / buffer (if present).'''
        }
        {
            bits: "16",
            name: "DPCMD0_VLD",
            desc: '''Valid signal of the execution `DPcmd` AXIS stream after command FIFO / buffer (if present).'''
        }
        {
            bits: "17",
            name: "DPCMD0_RDY",
            desc: '''Ready signal of the execution `DPcmd` AXIS stream after command FIFO / buffer (if present).'''
        }
        {
            bits: "18",
            name: "DPCMD0_LST",
            desc: '''Last signal of the execution `DPcmd` AXIS stream after command FIFO / buffer (if present).'''
        }
        {
            bits: "19",
            name: "DPCMD0_STL",
            desc: '''Indicates a stall on the execution `DPcmd` AXIS stream after command FIFO / buffer (if present).'''
        }
        // {
        //     bits: "20",
        //     name: "DPCMD1_VLD",
        //     desc: '''Valid signal of the programming `DPcmd` AXIS stream after command FIFO / buffer (if present).'''
        // }
        // {
        //     bits: "21",
        //     name: "DPCMD1_RDY",
        //     desc: '''Ready signal of the programming `DPcmd` AXIS stream after command FIFO / buffer (if present).'''
        // }
        // {
        //     bits: "22",
        //     name: "DPCMD1_LST",
        //     desc: '''Last signal of the programming `DPcmd` AXIS stream after command FIFO / buffer (if present).'''
        // }
        // {
        //     bits: "23",
        //     name: "DPCMD1_STL",
        //     desc: '''Indicates a stall on the programming `DPcmd` AXIS stream after command FIFO / buffer (if present).'''
        // }
        {
            bits: "34:32",
            name: "CURRENT_OP",
            desc: '''Currently decoded operation.'''
        }
        {
            bits: "35",
            name: "OP_FLAG_RFS",
            desc: '''The 'rfs' flag of the current instruction.'''
        }
        {
            bits: "36",
            name: "INSTR_STALLED",
            desc: '''A value of 1 indicates that the datapath stalled.'''
        }
      ]
    },
    { name: "DBG_OBSERVE",
      desc: "Observation register.",
      swaccess: "ro",
      hwaccess: "hwo",
      hwext : True
      fields: [
        {
            bits: "0",
            name: "IN0_VLD",
            desc: '''Valid signal of the input AXIS stream.'''
        }
        {
            bits: "1",
            name: "IN0_RDY",
            desc: '''Ready signal of the input AXIS stream.'''
        }
        {
            bits: "2",
            name: "IN0_LST",
            desc: '''Last signal of the input AXIS stream.'''
        }
        // {
        //     bits: "4",
        //     name: "IN1_VLD",
        //     desc: '''Valid signal of the second input AXIS stream.'''
        // }
        // {
        //     bits: "5",
        //     name: "IN1_RDY",
        //     desc: '''Ready signal of the second input AXIS stream.'''
        // }
        // {
        //     bits: "6",
        //     name: "IN1_LST",
        //     desc: '''Last signal of the second input AXIS stream.'''
        // }
        {
            bits: "8",
            name: "OUT_VLD",
            desc: '''Valid signal of the output AXIS stream.'''
        }
        {
            bits: "9",
            name: "OUT_RDY",
            desc: '''Ready signal of the output AXIS stream.'''
        }
        {
            bits: "10",
            name: "OUT_LST",
            desc: '''Last signal of the output AXIS stream.'''
        }
        {
            bits: "16",
            name: "DPCMD0_VLD",
            desc: '''Valid signal of the execution `DPcmd` AXIS stream after multiplexer.'''
        }
        {
            bits: "17",
            name: "DPCMD0_RDY",
            desc: '''Ready signal of the execution `DPcmd` AXIS stream after multiplexer.'''
        }
        {
            bits: "18",
            name: "DPCMD0_LST",
            desc: '''Last signal of the execution `DPcmd` AXIS stream after multiplexer.'''
        }
        // {
        //     bits: "20",
        //     name: "DPCMD1_VLD",
        //     desc: '''Valid signal of the programming `DPcmd` AXIS stream after multiplexer.'''
        // }
        // {
        //     bits: "21",
        //     name: "DPCMD1_RDY",
        //     desc: '''Ready signal of the programming `DPcmd` AXIS stream after multiplexer.'''
        // }
        // {
        //     bits: "22",
        //     name: "DPCMD1_LST",
        //     desc: '''Last signal of the programming `DPcmd` AXIS stream after multiplexer.'''
        // }
      ]
    },
    { name: "CMDGEN_STATUS",
      desc: "DP command generator observation register.",
      swaccess: "ro",
      hwaccess: "hwo",
      hwext : True
      fields: [
        {
            bits: "31:0",
            name: "ITERATION_CNT",
            desc: '''Iteration counter of the currently executed loop.'''
        }
        {
            bits: "47:32",
            name: "PROGRAM_CNT",
            desc: '''Current program counter (instruction memory pointer) value.'''
        }
        {
            bits: "50:48",
            name: "FSM_STATE",
            desc: '''Command generator FSM state.'''
        }
      ]
    },
    { name: "DBG_SCRATCH",
      desc: "Scratch register only accessible through SW for debugging purposes.",
      swaccess: "rw",
      hwaccess: "none"
      fields: [
        {
            bits: "63:0",
            name: "SCRATCH",
            desc: '''Scratch register field.''',
            resval: 0x0
        }
      ]
    },
    { name: "DBG_ID",
      desc: "Block identification register.",
      swaccess: "ro",
      hwaccess: "hwo",
      hwext : True
      fields: [
        {
            bits: "7:0",
            name: "BLOCK_ID",
            desc: '''Unique identifier of an `AI Core` block. Note, that the same blocks in each `AI Core` instance share the same `BLOCK_ID`.'''
        }
        {
            bits: "15:8",
            name: "AI_CORE_ID",
            desc: '''`AI_CORE_ID` aka `CID` is a unique identifier of the `AI Core` instance.'''
        }
        {
            bits: "23:16",
            name: "HW_REVISION",
            desc: '''Major hardware revision number.'''
        }
      ]
    },
    { name: "HW_CAPABILITY",
      desc: "Hardware capability register for the instance.",
      swaccess: "ro",
      hwaccess: "hwo",
      hwext : True
      fields: [
        {
            bits: "7:0",
            name: "CMD_FIFO_DEPTH",
            desc: '''Depth of the command FIFO in the CMD block.'''
        }
        {
             bits: "31:16",
             name: "INSTR_MEM_DEPTH",
             desc: '''Depth of the instruction memory in the `DPcmdgen` block, measured in number of instructions.'''
        }
        // {
        //      bits: "32",
        //      name: "STATIC_CMD_PRESENT",
        //      desc: '''If set to high, the static part of the command block is present.'''
        // }
        // {
        //     bits: "33",
        //     name: "VTRSP_PRESENT",
        //     desc: '''If set to high, the VTRSP block is present in the instance'''
        // }
      ]
    }
  ]
}
