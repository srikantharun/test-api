/**
 * Abstract:
 * axi_basic_sequence is used by test to provide initiator
 * scenario information to the Master agent present in the System Env.
 * This class defines a sequence in which a AXI WRITE followed by a AXI READ
 * sequence is generated by assigning values to the transactions rather than
 * randomization, and then transmitted using `uvm_send.
 *
 * Execution phase: main_phase
 * Sequencer: Master agent sequencer
 */

`ifndef GUARD_AXI_BASIC_SEQUENCE_SV
`define GUARD_AXI_BASIC_SEQUENCE_SV

class axi_basic_sequence extends svt_axi_master_base_sequence;

    // typedef
    typedef logic [`SVT_AXI_MAX_DATA_WIDTH/8-1:0]   axi_wstrb_t;

    // General utils and config
    rand int unsigned                               sequence_length;
    rand int unsigned                               wburst_length[];
    rand int unsigned                               rburst_length[];
    rand int unsigned                               max_burst_length[];
    int unsigned                                    tmp_wburst_length;
    int unsigned                                    tmp_rburst_length;
    svt_axi_transaction                             tmp_rsp;
    int                                             checks = 0;
    uvm_status_e                                    status;
    virtual clk_if                                  u_axe_clk_if;
    bit                                             enable_checks = 1;

    // Delays, types and sizes
    rand svt_axi_transaction::burst_type_enum       burst_type[];
    rand svt_axi_transaction::burst_size_enum       burst_size[];
    rand svt_axi_transaction::burst_type_enum       tmp_burst_type;
    rand svt_axi_transaction::burst_size_enum       tmp_burst_size;


    // delays
    int unsigned                                    max_delay_between_wr_rd = 3;
    int unsigned                                    min_delay_between_wr_rd = 0;
    int unsigned                                    max_addr_valid_delay = 3;
    int unsigned                                    min_addr_valid_delay = 0;
    int unsigned                                    max_wvalid_delay = 3;
    int unsigned                                    min_wvalid_delay = 0;
    // backpressure delays
    int unsigned                                    max_bready_delay = 3;
    int unsigned                                    min_bready_delay = 0;
    int unsigned                                    max_rready_delay = 3;
    int unsigned                                    min_rready_delay = 0;

    // ID related stuff
    rand logic [`SVT_AXI_MAX_ID_WIDTH-1:0]          rid [];
    rand logic [`SVT_AXI_MAX_ID_WIDTH-1:0]          wid [];
    rand logic [`SVT_AXI_MAX_ID_WIDTH-1:0]          tmp_id;
    logic [`SVT_AXI_MAX_ID_WIDTH-1:0]               max_id = 0;
    logic [`SVT_AXI_MAX_ID_WIDTH-1:0]               min_id = 0;

    // SPM config coming from script randomization
    spm_config_t                                    spm_config;

    // Address stuff
    bit                                             unique_addr;
    bit                                             unique_random_address = 0;
    bit                                             unaligned_address = 0;
    bit                                             strided_address;
    logic [`SVT_AXI_MAX_ADDR_WIDTH-1:0]             starting_address = 0;
    longint                                         stride_addr = 1;
    rand logic [`SVT_AXI_MAX_ADDR_WIDTH-1:0]        addr_array [];
    rand logic [`SVT_AXI_MAX_ADDR_WIDTH-1:0]        tmp_addr;
    bit                                             allow_partials = 0;
    bit                                             custom_burst_type = 0;
    bit                                             custom_burst_length = 0;
    bit                                             full_wstrb = 1;


    //allocation
    logic [`SVT_AXI_MAX_ADDR_WIDTH-1:0]             max_addr = 0;
    logic [`SVT_AXI_MAX_ADDR_WIDTH-1:0]             min_addr = 0;
    axe_uvm_memory_range                            spm_memory_range;


    // Constrain the sequence length to a reasonable value
    constraint reasonable_sequence_length {
        sequence_length < 130;
        sequence_length > 0;
        addr_array.size() == sequence_length;
        wid.size() == sequence_length;
        rid.size() == sequence_length;
        burst_size.size() == sequence_length;
        wburst_length.size() == sequence_length;
        rburst_length.size() == sequence_length;
        max_burst_length.size() == sequence_length;
        burst_type.size() == sequence_length;


        solve sequence_length before addr_array;
        solve sequence_length before wid;
        solve sequence_length before rid;
        solve sequence_length before burst_size;
        solve sequence_length before wburst_length;
        solve sequence_length before rburst_length;
        solve sequence_length before burst_type;
        solve sequence_length before burst_type;

    }



    /** UVM Object Utility macro */
    `uvm_object_utils_begin(axi_basic_sequence)
        `uvm_field_array_int(rid, UVM_ALL_ON)
        `uvm_field_array_int(wid, UVM_ALL_ON)
    `uvm_object_utils_end


    /** Class Constructor */
    function new(string name="axi_basic_sequence");
        super.new(name);
    endfunction

    virtual task body();
        svt_configuration get_cfg;
        bit status;

        `uvm_info("body", "Entered ...", UVM_LOW)

        super.body();

        // Obtain a handle to the port configuration
        p_sequencer.get_cfg(get_cfg);

        if(get_cfg == null)
             `uvm_fatal("body", "Unable to get config for the transaction")
        if (!$cast(cfg, get_cfg)) begin
            `uvm_fatal("body", "Unable to $cast the configuration to a svt_axi_port_configuration class")
        end

        if(!uvm_config_db #(spm_config_t)::get(uvm_root::get(), "", "spm_config", spm_config))
                `uvm_fatal(get_full_name(), "no spm config found");

        if(!uvm_config_db #(virtual clk_if)::get(uvm_root::get(), "", "u_axe_clk_if", u_axe_clk_if))
                `uvm_fatal(get_full_name(), "no clk if found");

        checks = 0;

        // memory range stuff
        if(spm_memory_range) begin
            max_addr = spm_memory_range.top;
            min_addr = spm_memory_range.base;
        end else begin
            if(max_addr == 0)
                max_addr = spm_config.spm_mem_size_kb*1024 - 1;
        end

        if(max_id == 0)
            max_id = 2**spm_config.spm_axi_id_width - 1;

        `uvm_info(get_full_name(), $sformatf("min_addr = %0d, max_addr = %0d", min_addr, max_addr), UVM_MEDIUM)

        // randomize burst type
        if(!custom_burst_type) begin
            foreach(burst_type[i]) begin
                std::randomize (tmp_burst_type) with{
                    tmp_burst_type inside {
                        svt_axi_transaction::FIXED,
                        svt_axi_transaction::INCR,
                        svt_axi_transaction::WRAP
                    };
                };
                burst_type[i] = tmp_burst_type;
                `uvm_info(get_full_name(), $sformatf("burst_type[%0d] = %0d", i, burst_type[i]), UVM_MEDIUM)
            end
        end


        // randomize burst length
        // wstrb based on burst size
        if(!custom_burst_length) begin
            foreach(wburst_length[i]) begin
                if(burst_type[i] == svt_axi_transaction::FIXED) begin
                    std::randomize (tmp_wburst_length) with {
                        tmp_wburst_length inside {[1:16]};
                    };
                    std::randomize (tmp_rburst_length) with {
                        tmp_rburst_length inside {[1:16]};
                    };
                end else if(burst_type[i] == svt_axi_transaction::INCR) begin
                    std::randomize (tmp_wburst_length) with {
                        tmp_wburst_length inside {[1:256]};
                    };
                    std::randomize (tmp_rburst_length) with {
                        tmp_rburst_length inside {[1:256]};
                    };
                end else if(burst_type[i] == svt_axi_transaction::WRAP) begin
                    std::randomize (tmp_wburst_length) with {
                        tmp_wburst_length inside {2,4,8,16};
                    };
                    std::randomize (tmp_rburst_length) with {
                        tmp_rburst_length inside {2,4,8,16};
                    };
                end
                wburst_length[i] = tmp_wburst_length;
                rburst_length[i] = tmp_rburst_length;
            end
        end

        // calc max burst_length for addr safery calculation
        foreach(max_burst_length[i]) begin
            max_burst_length[i] = wburst_length[i];
            if(rburst_length[i] > max_burst_length[i])
                max_burst_length[i] = rburst_length[i];
        end

        // addrs randomization
        // strided
        if(strided_address) begin
            foreach(addr_array[i]) begin
                if(i == 0) begin
                    addr_array[i] = starting_address;
                end else begin
                    //check out of boundary memory
                    // starting_address + stride_addr*i ---- is the next starting addr
                    // max_addr - 1 - (8*max_burst_length)  ---- is the max addr allowed in spm considering the max_burst_length and adding 1 because counting from 0
                    addr_array[i] = (starting_address + stride_addr*i) > max_addr + 1 - (8*max_burst_length[i]) ? max_addr - (8*max_burst_length[i]): (starting_address + stride_addr*i);
                    if(addr_array[i] % 4096 + (8*max_burst_length[i]) > 4096) begin
                        max_burst_length[i] = 1;
                        rburst_length[i] = 1;
                        wburst_length[i] = 1;
                    end
                end

                `uvm_info(get_full_name(), $sformatf("addr_array[%0d] = %0d", i, addr_array[i]), UVM_MEDIUM)
            end
        end

        // random unique
        else if(unique_random_address) begin
            foreach(addr_array[i]) begin
                unique_addr = 0;
                while (!unique_addr) begin
                    std::randomize (tmp_addr) with {
                        tmp_addr >= min_addr;
                        tmp_addr <= (max_addr - (8*max_burst_length[i]));
                        tmp_addr%8 == 0; //only line aligned
                        tmp_addr % 4096 + (8*max_burst_length[i]) <= 4096;
                    };

                    // Check if the address is unique
                    unique_addr = 1;
                    foreach (addr_array[j]) begin
                        if (addr_array[j] == tmp_addr) begin
                            unique_addr = 0;
                            break;
                        end
                    end
                end
                addr_array[i] = tmp_addr;
                `uvm_info(get_full_name(), $sformatf("addr_array[%0d] = %0d", i, addr_array[i]), UVM_MEDIUM)
            end
        end
        // random unaligned
        else if(unaligned_address) begin
            // wrap only supports aligned address
            foreach(addr_array[i]) begin
                if(burst_type[i] == svt_axi_transaction::WRAP) begin
                    std::randomize (tmp_addr) with {
                        tmp_addr >= min_addr;
                        tmp_addr <= (max_addr - (8*max_burst_length[i]));
                        tmp_addr%8 == 0; //only line aligned
                        tmp_addr % 4096 + (8*max_burst_length[i]) <= 4096;
                    };
                end else begin
                    std::randomize (tmp_addr) with {
                        tmp_addr >= min_addr;
                        tmp_addr <= (max_addr - (8*max_burst_length[i]));
                        tmp_addr % 4096 + (8*max_burst_length[i]) <= 4096;
                    };
                end
                addr_array[i] = tmp_addr;
                `uvm_info(get_full_name(), $sformatf("addr_array[%0d] = %0d", i, addr_array[i]), UVM_MEDIUM)
            end

        end
        // random aligned
        else begin
            foreach(addr_array[i]) begin
                std::randomize (tmp_addr) with {
                    tmp_addr >= min_addr;
                    tmp_addr <= (max_addr - (8*max_burst_length[i]));
                    tmp_addr%8 == 0; //only line aligned
                    tmp_addr % 4096 + (8*max_burst_length[i]) <= 4096;
                };
                addr_array[i] = tmp_addr;
                `uvm_info(get_full_name(), $sformatf("addr_array[%0d] = %0d", i, addr_array[i]), UVM_MEDIUM)
            end
        end


        // ID randomization
        foreach(wid[i]) begin
            std::randomize (tmp_id) with {
                tmp_id >= min_id;
                tmp_id <= max_id;
            };
            wid[i] = tmp_id;
            `uvm_info(get_full_name(), $sformatf("wid[%0d] = %0d", i, wid[i]), UVM_MEDIUM)
        end
        foreach(rid[i]) begin
            std::randomize (tmp_id) with {
                tmp_id >= min_id;
                tmp_id <= max_id;
            };
            rid[i] = tmp_id;
            `uvm_info(get_full_name(), $sformatf("rid[%0d] = %0d", i, rid[i]), UVM_MEDIUM)
        end


        // Burst size
        if(allow_partials == 1) begin
            foreach(burst_size[i]) begin
                std::randomize (tmp_burst_size) with {
                    tmp_burst_size inside {
                        svt_axi_transaction::BURST_SIZE_8BIT,
                        svt_axi_transaction::BURST_SIZE_16BIT,
                        svt_axi_transaction::BURST_SIZE_32BIT,
                        svt_axi_transaction::BURST_SIZE_64BIT
                    };
                };
                burst_size[i] = tmp_burst_size;
                `uvm_info(get_full_name(), $sformatf("burst_size[%0d] = %0d", i, burst_size[i]), UVM_MEDIUM)
            end
        end else begin
            foreach(burst_size[i]) begin
                burst_size[i] = svt_axi_transaction::BURST_SIZE_64BIT;
            end
        end




        `uvm_info(get_full_name(), $sformatf("wburst_length = %0d, rburst_length = %0d, sequence_length = %0d", wburst_length.size(), rburst_length.size(), sequence_length), UVM_MEDIUM)
        `uvm_info(get_full_name(), $sformatf("starting_address = %0d, stride_addr = %0d, strided_address = %0d", starting_address, stride_addr, strided_address), UVM_MEDIUM)


    endtask: body

    function axi_wstrb_t calc_wstrb(svt_axi_transaction::burst_size_enum _burst_size);
            axi_wstrb_t tmp_wstrb;
            // wstrb based on burst size
            if(_burst_size == svt_axi_transaction::BURST_SIZE_64BIT) begin
                if(full_wstrb) begin
                    tmp_wstrb = 8'b1111_1111;
                end else begin
                    std::randomize (tmp_wstrb) with {
                        $countones(tmp_wstrb) <= 8;
                    };
                end

            end else if(_burst_size == svt_axi_transaction::BURST_SIZE_32BIT) begin
                if(full_wstrb) begin
                    tmp_wstrb = 8'b0000_1111;
                end else begin
                    std::randomize (tmp_wstrb) with {
                        $countones(tmp_wstrb[3:0]) <= 4;
                    };
                    tmp_wstrb = {4'b0000, tmp_wstrb[3:0]};
                end

            end else if(_burst_size == svt_axi_transaction::BURST_SIZE_16BIT) begin
                if(full_wstrb) begin
                    tmp_wstrb = 8'b0000_0011;
                end else begin
                    std::randomize (tmp_wstrb) with {
                            $countones(tmp_wstrb[1:0]) <= 2;
                    };
                    tmp_wstrb = {6'b000000, tmp_wstrb[1:0]};
                end

            end else if(_burst_size == svt_axi_transaction::BURST_SIZE_8BIT) begin
                tmp_wstrb = 8'b0000_0001;

            end

            `uvm_info(get_full_name(), $sformatf("wstrb = %0d on burst_size = %0s", tmp_wstrb, _burst_size.name()), UVM_MEDIUM)
            return tmp_wstrb;
        endfunction

    function int calc_delay(int _max_delay, int _min_delay);
            int delay;

            std::randomize(delay) with {
                delay <= _max_delay;
                delay >= _min_delay;
            };

            return delay;

        endfunction

endclass: axi_basic_sequence

`endif // GUARD_AXI_BASIC_SEQUENCE_SV
