// (C) Copyright 2024 Axelera AI B.V.
// All Rights Reserved
// *** Axelera AI Confidential ***
//
// Owner: Kevin Luciani <kevin.luciani@axelera.ai>

/// Generates AHB transactions upon i_req && o_ready.
/// Once the transaction request is observed, o_ready will go low until the
/// transaction is over. Results (o_rdata, o_error) are available as soon
/// as o_ready goes back high and are kept stable until the next request.
///
/// !!! note
///
///     - HREADY towards subordinate and manager is generated by the "Read data and response multiplexor"
///       depending on the selected subordinate. Each subordinate generates one HREADYOUT which is send to
///       the multiplexor.
///     - HSEL toards subordinate is generated by the external address decoder.
///

module axe_ahb_manager
  import axe_ahb_pkg::*;
#(
  /// Width definition for AHB address bus
  parameter int  unsigned HAW               = 5           ,
  /// Width definition for AHB data bus
  parameter int  unsigned HDW               = 32           ,
  /// AHB address type
  parameter type          haddr_t       = logic [HAW -1:0] ,
  /// AHB data type
  parameter type          hdata_t       = logic [HDW -1:0]
)(
  /// Clock, positive edge triggered
  input  wire                 i_clk                 ,
  /// Asynchronous reset, active low
  input  wire                 i_rst_n               ,
  ///////////////////////////
  // AHB manager interface //
  ///////////////////////////
  output haddr_t              o_ahb_m_haddr         ,
  output logic                o_ahb_m_hwrite        ,
  output hdata_t              o_ahb_m_hwdata        ,
  output htrans_e             o_ahb_m_htrans        ,
  output hburst_e             o_ahb_m_hburst        ,
  output hsize_e              o_ahb_m_hsize         ,
  input  hdata_t              i_ahb_m_hrdata        ,
  input  logic                i_ahb_m_hready        ,
  input  logic                i_ahb_m_hresp         ,
  //////////////////////
  // I/f to requestor //
  //////////////////////
  input  logic                i_valid               ,
  input  logic                i_wr                  ,
  input  haddr_t              i_addr                ,
  input  hdata_t              i_wdata               ,
  output hdata_t              o_rdata               ,
  output logic                o_error               ,
  /// When 1, this signal indicates that the module can accept a new request via i_valid
  output logic                o_ready
);

// ----------------------------------------------------------------------------
// Types
// ----------------------------------------------------------------------------
// AHB state type
typedef enum { AHB_IDLE, AHB_ADDR, AHB_DATA, AHB_ERROR } ahb_state_e;

// ----------------------------------------------------------------------------
// signal declarations
// ----------------------------------------------------------------------------
ahb_state_e state_q;
ahb_state_e state_d;
haddr_t     ahb_m_haddr_d;
logic       ahb_m_hwrite_d;
hdata_t     ahb_m_hwdata_d;
htrans_e    ahb_m_htrans_d;
hdata_t     rdata_d;
logic       error_d;
logic       ready_d;

haddr_t     ahb_m_haddr_q;
logic       ahb_m_hwrite_q;
hdata_t     ahb_m_hwdata_q;
htrans_e    ahb_m_htrans_q;
hdata_t     rdata_q;
logic       error_q;
logic       ready_q;

// ----------------------------------------------------------------------------
// RTL
// ----------------------------------------------------------------------------

// Only WORD accesses, no BURST.
always_comb begin
  o_ahb_m_hsize  = WORD;
  o_ahb_m_hburst = SINGLE;
end

// AHB manager state machine
always_comb begin
  state_d = state_q;

  ahb_m_haddr_d   = ahb_m_haddr_q;
  ahb_m_hwrite_d  = ahb_m_hwrite_q;
  ahb_m_hwdata_d  = ahb_m_hwdata_q;
  ahb_m_htrans_d  = ahb_m_htrans_q;
  rdata_d         = rdata_q;
  error_d         = error_q;
  ready_d         = ready_q;

  unique case(state_q)
    AHB_IDLE: begin
      ready_d = 1'b0;
      if (i_valid && !ready_q) begin
        state_d = AHB_ADDR;
        error_d = 1'b0;
        ahb_m_haddr_d  = i_addr;
        ahb_m_hwrite_d = i_wr;
        ahb_m_hwdata_d = i_wdata;
        ahb_m_htrans_d = NONSEQ;
      end
    end
    AHB_ADDR: begin
      state_d = AHB_DATA;
      ahb_m_htrans_d = IDLE;
    end
    AHB_DATA: begin
      if (i_ahb_m_hresp) begin
        state_d = AHB_ERROR;
      end else if (i_ahb_m_hready) begin
        // End of a successful transaction
        state_d = AHB_IDLE;
        ready_d = 1'b1;
        error_d = 1'b0;
        if (!ahb_m_hwrite_q) begin
          rdata_d = i_ahb_m_hrdata;
        end
      end
    end
    AHB_ERROR: begin
      if (i_ahb_m_hready) begin
        state_d = AHB_IDLE;
        ready_d = 1'b1;
        error_d = 1'b1;
      end
    end
    default: state_d = AHB_IDLE;
  endcase
end

always_ff @ (posedge i_clk or negedge i_rst_n) begin
  if (!i_rst_n) begin
    state_q         <= AHB_IDLE;
    ahb_m_haddr_q   <= haddr_t'(0);
    ahb_m_hwrite_q  <= 1'b0;
    ahb_m_hwdata_q  <= hdata_t'(0);
    ahb_m_htrans_q  <= IDLE;
    rdata_q         <= hdata_t'(0);
    error_q         <= 1'b0;
    ready_q         <= 1'b0;
  end else begin
    state_q         <= state_d;
    ahb_m_haddr_q   <= ahb_m_haddr_d;
    ahb_m_hwrite_q  <= ahb_m_hwrite_d;
    ahb_m_hwdata_q  <= ahb_m_hwdata_d;
    ahb_m_htrans_q  <= ahb_m_htrans_d;
    rdata_q         <= rdata_d;
    error_q         <= error_d;
    ready_q         <= ready_d;
  end
end

always_comb o_ahb_m_haddr   = ahb_m_haddr_q;
always_comb o_ahb_m_hwrite  = ahb_m_hwrite_q;
always_comb o_ahb_m_hwdata  = ahb_m_hwdata_q;
always_comb o_ahb_m_htrans  = ahb_m_htrans_q;
always_comb o_rdata         = rdata_q;
always_comb o_error         = error_q;
always_comb o_ready         = ready_q;

endmodule
