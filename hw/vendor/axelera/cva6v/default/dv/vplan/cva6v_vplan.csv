Name,Type,Req_id,Prioirity,Description,Measure,Testcase,Covergroup if applicable,From CVA6 Vplan
fencei fetching,FENCEI.Fetching,CVA6V_008,4,Instruction data for the next PC must be fetched after the fence.i instruction has executed (because only then can data-side stores have completed and caches have been updated). Check that after a fence.i instruction retires then instr-side obi fetches the next instruction to be executed.,Assertion (uvma_cvxif_assert adaptation),,,Yes
fencei stores visible scenario 1,FENCEI.StoresVisible,CVA6V_008,4,"After a fence.i instruction has been executed, all preceding store instructions shall have their effects visible to the instruction fetch of the instructions that are to be executed after the fence.i instruction. Do a fencei, but right before the fencei do a store to the instruction following the fencei, then see that the newly stored value is executed instead of the old instruction (e.g. change addi to use a different immediate).",Directed Test pref. in UVM,,,Yes
fencei stores visible scenario 2,FENCEI.StoresVisible,CVA6V_008,4,"After a fence.i instruction has been executed, all preceding store instructions shall have their effects visible to the instruction fetch of the instructions that are to be executed after the fence.i instruction. Do a fencei followed by any instruction, but let the environment detect when the fencei is being executed and change the memory holding the next instruction, then see that the old instruction is not executed.",Directed Test pref. in UVM,,,Yes
fencei stores visible scenario 3,FENCEI.StoresVisible,CVA6V_008,4,"After a fence.i instruction has been executed, all preceding store instructions shall have their effects visible to the instruction fetch of the instructions that are to be executed after the fence.i instruction. Let the instruction right before a fence.i write a different instruction to the address following the fence.i, then observe that the written instruction is executed instead of the original one and that no side-effects (csr updates or otherwise) occur (can possibly mix 16bit/32bit instructions to force a noticable difference).",Directed Test pref. in UVM,,,Yes
fencei stores visible scenario 4,FENCEI.StoresVisible,CVA6V_008,4,"After a fence.i instruction has been executed, all preceding store instructions shall have their effects visible to the instruction fetch of the instructions that are to be executed after the fence.i instruction. Check that after having read one value from an address, then after storing a value to that same address, if executing that address then the value shall always be that which was written (should work well in both sim/formal).",Directed Test pref. in UVM,,,Yes
fencei req high,FENCEI.ExternalHandshake,CVA6V_008,4,"When executing a fence.i instruction, fencei_flush_req_o shall rise sometime before executing the next instruction.",Assertion (uvmt_cv32e40x_fencei_assert adaptation),,,Yes
fencei req wait lsu,FENCEI.ExternalHandshake,CVA6V_008,4,"When executing a fence.i instruction, if there is an ongoing store instruction that has not completed (data_rvalid_i clocked in as 1), then fencei_flush_req_o shall be low. Make sure a store instruction is run right before a fence.i, and (possibly using obi stalls) ensure that the fence.i is pending retirement but holds off until the store's data_rvalid_i is clocked in and that fencei_flush_req_o was low until this point where it now goes high.",Directed Test pref. in UVM + Assertion  (uvmt_cv32e40x_fencei_assert adaptation),,,Yes
fencei req wait writebuffer,FENCEI.ExternalHandshake,CVA6V_008,4,"When executing a fence.i instruction, if the write buffer is not empty, then fencei_flush_req_o shall be low until the write buffer has been emptied and the corresponding data_rvalid_i have been clocked in as 1. Fill up the write buffer prior to executing a fence.i and ensure that fencei_flush_req_o holds off going high until the write buffer to has been emptied.",Directed Test pref. in UVM + Assertion  (uvmt_cv32e40x_fencei_assert adaptation),,,Yes
fencei req wait X interface,FENCEI.ExternalHandshake,CVA6V_008,4,"When executing a fence.i instruction, if the X interface is busy with any store operations, then fencei_flush_req_o shall be low until all the store operations are done. Issue one or more store instructions that uses the X interface and ensure that fencei_flush_req_o waits until the stores have all completed before going high.",Directed Test pref. in UVM + Assertion  (uvmt_cv32e40x_fencei_assert adaptation),,,Yes
fencei req low,FENCEI.ExternalHandshake,CVA6V_008,4,"When fencei_flush_req_o is high, it shall stay high until fencei_flush_req_o and fencei_flush_ack_i has been sampled high simultaneously, and then it shall go low.",Directed Test pref. in UVM + Assertion  (uvmt_cv32e40x_fencei_assert adaptation),,,Yes
fencei ack change,FENCEI.ExternalHandshake,CVA6V_008,4,"fencei_flush_ack_i is allowed to change freely on any clock cycle: It can be permanently high, go high without fence.i and retract, go high at the same cycle as the req, it can delay arbitrarily after req and then go high, etc. Drive ack to test all permutations of rising/falling before/after/on req, acking without req, retracting an early ack, delaying ack after req, etc.",Functional Coverage,,Memory_Ordering,Yes
fencei ack with hold,FENCEI.ExternalHandshake,CVA6V_008,4,"If req is high, but ack never comes, then the core keeps on stalling and the fence.i is blocked from completing. Upon a req, try witholding ack for a long time and see that the fence.i can be stalled arbitrarily long (should have covers for ack delays of at least {[0:5]}).",Functional Coverage,,Memory_Ordering,Yes
fencei branch initiated,FENCEI.ExternalHandshake,CVA6V_008,4,"After req and ack has been sampled simultaneously high and when req is low again, then the core takes a branch to the instruction after the fence.i instruction. Check that the branch is taken at the point after req and ack has been simultaneously high.",Functional Coverage,,Memory_Ordering,Yes
fencei shadowing branch,FENCEI.ExternalHandshake,CVA6V_008,4,"If the fence.i ends up not retiring because it was preceeded by a taken branch or a jump, then the fencei_flush_req_o shall not go high. Take a branch or do a jump to skip a fence.i, and ensure that fencei_flush_req_o doesn't go high.",Directed Test pref. in UVM + Assertion  (uvmt_cv32e40x_fencei_assert adaptation),,,Yes
fencei multicycle,FENCEI.Multicycle,CVA6V_008,4,"Given zero stalls on neither instr-side and data-side obi nor on fencei_flush_ack_i, then the execution of fence.i takes a fixed number of cycles. Check that, given ideal conditions, the cycle count of fence.i is as expected.",Assertion (uvmt_cv32e40x_fencei_assert adaptation),,,Yes
fencei stores complete,FENCEI.StoresComplete,CVA6V_008,4,"Any store instruction that is successfully executed before a fence.i will fully complete and have its effect visible (this is not about syncronization with instruction fetch, but rather seeing that the stores are not aborted). Check that all stores (either to next pc or other places) preceding a fence.i will complete on the bus (excluding exceptions/interrupts/etc) and be readable afterwards (particularly, ensure that the write buffer isn't just purged).",Directed Test pref. in UVM,,,Yes
fencei flush,FENCEI.FLUSH,CVA6V_008,4,"When fence.i is executed, then any prefetched instructions shall be flushed; meaning that pipeline stages are flushed, prefetcher is flushed, write buffer is flushed, and data_req_o is eventually supressed. Check that a fence.i will cause flushing of the pipeline, prefetcher, write buffer, and data_req_o.",Functional Coverage,,Memory_Ordering,Yes
fencei unused fields,FENCEI.UnusedFields,CVA6V_008,4,"imm[11:0], rs1, rd are reserved for future extensions, and implementations shall ignore them. Try giving random values in those fields and see that all else works as expected",Functional Coverage,,Memory_Ordering,Yes
branch table buffer,FRONTEND.PCGenStage,CVA6V_003,5,"If instruction is a JALR and BTB (Branch Target Buffer) returns a valid address, next PC is predicted by BTB. Else JALR is not considered as a control flow instruction, which will generate a mispredict. Execute test with JALR instructions. Functional cov: JALR is executed and BTB output is not valid. ",Functional Coverage,,Control_Flow,Yes
branch history table,FRONTEND.PCGenStage,CVA6V_003,5,"If instruction is a branch and BTH (Branch History table) returns a valid address, next PC is predicted by BHT. Else branch is not considered as an control flow instruction, which will generate a mispredict when branch is taken. Execute test with BRANCH instructions. Functional cov: a BRANCH is executed, BTB output is not valid and the branch is taken.",Functional Coverage,,Control_Flow,Yes
return address stack,FRONTEND.PCGenStage,CVA6V_003,5,If instruction is a RET and RAS (Return Address Stack) returns a valid address then RET has already been consummed by instruction queue. Else RET is considered as a control flow instruction but next PC is not predicted. A mispredict wil be generated. e test with RET instructions. Functional cov: RET is executed and RAS output is not valid.,Functional Coverage,,Control_Flow,Yes
return from environment call,FRONTEND.PCGenStage,CVA6V_003,5,"When CSR asks a return from an environment call, the PC is assigned to the successive PC to the one stored in the CSR [m-s]epc register. Set two different addresses for mepc and sepc in CSR registers. Use a arc_test returning from machine env call. Check that when machine return occurs the m/sepc address is fetched. Functional cov: execute a machine/supervisor return.",Functional Coverage,,Privileged_Instructions,Yes
pc generation exception/interrupt,FRONTEND.PCGenStage,CVA6V_007,4,"If an exception (or interrupt, which is in the context of RISC-V systems quite similar) is triggered by the COMMIT, the next PC Gen is assigned to the CSR trap vector base address. The trap vector base address can be different depending on whether the exception traps to S-Mode or M-Mode (user mode exceptions are currently not supported) Set two different addresses for machine and supervisor handlers in CSR registers. Use a test which executes in machine mode and generates a machine exception by UVM. Check that when machine/supervisor exception occurs the machine/supervisor address is fetched. Functional cov: exception occurs in machine/supervisor mode. ",Functional Coverage,,"Interrupt, Exceptions",Yes
pc generation priority,FRONTEND.PCGenStage,CVA6V_000,3,"The next PC can originate from the following sources (listed in order of precedence): Use arch_test executing return from env call and generate Exceptions by UVM during reset, Branch predict, default, mispredict, replay and return from env call. Functional cov: monitor the 6 events",Functional Coverage,,Control_Flow,Yes
branch history table saturation,FRONTEND.PCGenStage,CVA6V_000,3,The Branch History table is a two-bit saturation counter that takes the virtual address of the current fetched instruction by the CACHE. It states whether the current branch request should be taken or not. The two bit counter is updated by the successive execution of the current instructions as shown in the following figure. Execute a series of taken and not taken branch to check the saturation mechanism.,Functional Coverage,,Control_Flow,Yes
fetch exception- bus error,FRONTEND.FetchStage,CVA6V_000,3,"Memory and MMU can feedback potential exceptions generated by the memory fetch request. They can be bus errors, invalid accesses or instruction page faults. Generate a bus error exception and check that the exception address is fetched. Functional cov: a bus error exception occurs.",Functional Coverage,,Exceptions,Yes
fetch exception- invalid access,FRONTEND.FetchStage,CVA6V_000,3,"Memory and MMU can feedback potential exceptions generated by the memory fetch request. They can be bus errors, invalid accesses or instruction page faults. Generate an invalid access exception and check that the exception address is fetched. Functional cov: an invalid access exception occurs.",Functional Coverage,,Exceptions,Yes
,,,,,,,,
,,,,,,,,
,,,,,,,,
load instructions,ISA.RV64I,CVA6V_003,5,"Load Byte (LB), Load Halfword (LH), Load Word (LWU), Load Byte Unsigned (LBU), Load Half Unigned (LHU), Load Double (LD), Load Word Unsigned (LWU) ",Functional Coverage,,Memory,No
store instructions,ISA.RV64I,CVA6V_003,5,"Store Byte (SB), Store Halfword (SH), Store Word (SW), Store Double (SD)",Functional Coverage,,ALU,No
shift instructions,ISA.RV64I,CVA6V_003,5,"Shift Left Logical (SLL), Shift Left Logical Immediate (SLLI), Shift Right Logical (SRL), Shift Right Logical Immediate (SRLI), Shift Right Arithmetic (SRA), Shift Right Arithmetic Immediate (SRAI), Shift Left Logical Word (SLLW), Shift Left Logical Immediate Word (SLLIW), Shift Right Logical Word (SRLW), Shift Right Logical Immediate Word (SRLIW), Shift Right Arithmetic Word (SRAW), Shift Right Arithmetic Immediate Word (SRAIW)",Functional Coverage,,ALU,No
arithmetic instructions,ISA.RV64I,CVA6V_003,5,"Add (ADD), Add Immediate (ADDI), Subtract (SUB), Load Upper Immediate (LUI), Add Upper Immediate to PC (AUIPC), Add Word (ADDW), Add Immediate Word (ADDIW), Subtract Word (SUBW)",Functional Coverage,,ALU,No
logical instructions,ISA.RV64I,CVA6V_003,5,"XOR (XOR), XOR Immediate (XORI), OR (OR), OR Immediate (ORI), AND (AND), AND Immediate (ANDI)",Functional Coverage,,ALU,No
compare instructions,ISA.RV64I,CVA6V_003,5,"Set < (SLT), Set < Immediate (SLTI), Set < Unsigned (SLTU), Set < Imm Unsigned (SLTIU)",Functional Coverage,,ALU,No
branch instructions,ISA.RV64I,CVA6V_003,5,"Branch Equal (BEQ), Branch Not Equal (BNEQ), Branch Less Than (BLT), Branch Greater Than or Equal to (BGE), Branch Less Than Unsigned (BLTU), Branch Greater Than Or Equal To Unsigned (BGEU)",Functional Coverage,,Control_Flow,No
jump and link instructions,ISA.RV64I,CVA6V_003,5,"Jump and Link (JAL), Jump and Link Register (JALR)",Functional Coverage,,Control_Flow,No
synch instructions,ISA.RV64I,CVA6V_008,4,"Sync Thread (FENCE), Sync Instruction and Data (FENCE.I)",Functional Coverage,,Control_Flow,No
system instructions,ISA.RV64I,CVA6V_000,5,"System Call (SCALL), System Break (SBREAK)",Functional Coverage,,Privileged_Instructions,No
counter instructions,ISA.RV64I,CVA6V_005,2,"Read Cycle (RDCYCLE), Read Cycle Upper Half (RDCYCLEH), Read Time (RDTIME), Read Time Upper Half (RDTIMEH), Read Instruction Retired (RDINSTRET), Read Instruction Retired Upper Half (RDINSTRETH)",Functional Coverage,,Counters_Timers,No
CSR access instructions,ISA.RVPrivileged,CVA6V_000,5,"Atomic Read/Write (CSRRW), Atomic Read and Set Bit (CSRRS), Atomic Read and Clear Bit (CSRRC), Atomic Read/Write Immediate (CSRRWI), Atomic Read and Set Immediate (CSRSI), Atomic Read and Clear Immediate (CSRCI)",Functional Coverage,,Privileged_Instructions,No
change level instructions,ISA.RVPrivileged,CVA6V_000,5,"Env. Call (ECALL), Env. Breakpoint (EBREAK), Env. Return (ERET)",Functional Coverage,,Privileged_Instructions,No
trap redirect instructions,ISA.RVPrivileged,CVA6V_006,5,Redirect Trap to Supervisor (MRTS),Functional Coverage,,Privileged_Instructions,No
interrupt instructions,ISA.RVPrivileged,CVA6V_007,5,Wait for Interrupt (WFI),Functional Coverage,,Privileged_Instructions,No
mmu instructions,ISA.RVPrivileged,CVA6V_009,5,Supervisor FENCE (SFENCE.VM),Functional Coverage,,Privileged_Instructions,No
compressed loads,ISA.RVC,CVA6V_003,5,"Load Word (C.LW), Load Word SP (C.LWSP), Load Double (C.LD), Load Double SP (C.LDSP)",Functional Coverage,,Memory,No
compressed stores,ISA.RVC,CVA6V_003,5,"Store Word (C.SW), Store Word SP (C.SWSP), Store Double (C.SD), Store Double SP (C.SDSP)",Functional Coverage,,Memory,No
compressed arithmetic,ISA.RVC,CVA6V_003,5,"Add (C.ADD), Add Word (C.ADDW), ADD Immediate (C.ADDI), Add Word Immediate (C.ADDIW), Add SP Immediate * 16 (C.ADDI16SP), Add SP Immediate * 4 (C.ADDI4SPN), Load Immediate (C.LI), Load Upper Immediate (C.LUI), Move (C.MV), Sub (C.SUB)",Functional Coverage,,ALU,No
compressed shifts,ISA.RVC,CVA6V_003,5,Shift Left Immediate (C.SLLI),Functional Coverage,,ALU,No
compressed branches,ISA.RVC,CVA6V_003,5,"Branch If Equal to Zero (C.BEQZ), Branch If Not Zero (C.BNEZ)",Functional Coverage,,Control_Flow,No
compressed jumps,ISA.RVC,CVA6V_003,5,"Jump (C.J), Jump Register (C.JR)",Functional Coverage,,Control_Flow,No
compressed jump and link,ISA.RVC,CVA6V_003,5,"Jump and Link (C.JAL), Jump and Link Register (C.JALR)",Functional Coverage,,Control_Flow,No
compressed system,ISA.RVC,CVA6V_003,5,Env Break (C.EBREAK),Functional Coverage,,Privileged_Instructions,No
multiply instructions,ISA.RVM,CVA6V_003,5,"Multiply (MUL), Multiply Word (MULW), Multiply Upper Half (MULH), Multiply Half Signd Unsigned (MULHSU), Multiply Upper Half Unsigned (MULHU), Divide (DIV), Divide Word (DIVW), Divide Unsigned (DIVU), Remainder (REM), Remainder Word (REMW), Remainder Unsigned (REMU), Remainder Unsigned Word (REMUW)",Functional Coverage,,ALU,No
atomic load,ISA.RVA,CVA6V_003,5,"Load Reserved Word (LR.W), Load Reserved Double (LR.D)",Functional Coverage,,Memory,No
atomic store,ISA.RVA,CVA6V_003,5,"Store Conditioan Word (SC.W), Store Conditional Double (SC.D)",Functional Coverage,,Memory,No
atomic swap,ISA.RVA,CVA6V_003,5,"Swap Word (AMOSWAP.W), Swap Double (AMOSWAP.D)",Functional Coverage,,ALU,No
atomic add,ISA.RVA,CVA6V_003,5,"Add Word (AMOADD.W), Add Double (AMOADD.D)",Functional Coverage,,ALU,No
atomic logical,ISA.RVA,CVA6V_003,5,"XOR Word (AMOXOR), XOR Double (AMOXOR.D), AND Word (AMOAND.W), AND Double (AMOAND.D), OR Word (AMOOR.W), OR Double (AMOOR.D)",Functional Coverage,,ALU,No
atomic min max,ISA.RVA,CVA6V_003,5,"Minimum Word (AMOMIN.W), Minimum Double (AMOMIN.D), Maximum Word (AMOMAX.W), Maximum Double (AMOMAX.D), Minimum Word Unsigned (AMOMINU.W), Minimum Double Unsigned (AMOMINU.D), Maximum Word Unsigned (AMOMAXU.W), Maximum Double Unsigned (AMOMAXU.D)",Functional Coverage,,ALU,No
fp move,ISA.RVF,CVA6V_004,5,"Move from Integer Half Precision (FMV.H.X), Move from Integer Single Precision (FMV.S.X), Move to Integer Half Precision (FMV.X.H), Move to Integer Single Precision (FMV.X.S)",Functional Coverage,,FPU,No
fp convert,ISA.RVF,CVA6V_004,5,"Convert from Int Half Precision (FCVT.H.W), Convert from Int Single Precision (FCVT.S.W), Convert from Int Unsigned Half Precision (FCVT.H.WU), Convert from Int Unsigned Single Precision (FCVT.S.WU), Convert to Int Half Precision (FCVT.W.H), Convert to Int Single Precision (FCVT.W.S), Convert to Int Unsigned Half Precision (FCVT.WU.H), Convert to Int Unsigned Single Precision (FCVT.WU.S)",Functional Coverage,,FPU,No
fp load,ISA.RVF,CVA6V_003,5,Load (FLW),Functional Coverage,,FPU,No
fp store,ISA.RVF,CVA6V_003,5,Store (FLW),Functional Coverage,,FPU,No
fp arithmetic,ISA.RVF,CVA6V_003,5,"Add (FADD.S), Subtract (FSUB.S), Multiply (FMUL.S), Divide (FDIV.S), Square Root (FSQRT.S)",Functional Coverage,,FPU,No
fp multiply add,ISA.RVF,CVA6V_003,5,"Multiply-add (FMADD.S), Multiply-subtract (FMSUB.S), Negative Multiply Subtract (FNMSUB.S), Negative Multiply-add (FNMADD.S)",Functional Coverage,,FPU,No
fp sign inject,ISA.RVF,CVA6V_003,5,"Sign Source (FSGNJ.S), Negative Sign Source (FSGNJN.S), XOR Sign Source (FSGNJX.S)",Functional Coverage,,FPU,No
fp min max,ISA.RVF,CVA6V_003,5,"Minimum (FMIN.S), Maximum (FMAX.S)",Functional Coverage,,FPU,No
fp compare,ISA.RVF,CVA6V_003,5,"Compare Float Equal (FEQ.S), Compare Float Less Than (FLT.S), Compare Float Less Than Or Equal (FLE.S)",Functional Coverage,,FPU,No
fp categorization,ISA.RVF,CVA6V_003,5,Classify Type (FCLASS.S),Functional Coverage,,FPU,No
fp configuration,ISA.RVF,CVA6V_003,5,"Read Status (FRCSR), Read Rounding Mode (FRRM), Read Flags (FRFLAGS), Swap Status Reg (FSCSR), Swap Rounding Mode (FSRM), Swap Flags (FSFLAGS), Swap Rounding Mode Imm (FSRMI), Swap Flags Imm (FSFLAGSI)",Functional Coverage,,FPU,No
,,,,,,,,
,,,,,,,,
,,,,,,,,
pte.V=0 - read,MMU.SV39,CVA6V_009,4,"If PTE does not have Valid (pte.V=0) permission, then accessing it would raise page fault exception of the corresponding access type.When satp.mode=sv39 and PTE has (r,w,x) PMP permissions, then test the following in supervisor and user privilege mode for level2 to level0 PTE: Set PTE.V = 0 and test the read acces. For testing at levelN, set all the pte perimssions at level(N+1) to 0 except pte.v, so that level(N+1) points to levelN. Set pte.U=0 when test in Supervisor mode and Set pte.U=1 when testing in user mode. Page fault exception should be raised according to {x,r,w} access type. Check m/scause and m/sepc accordingly for read accesses.",Directed Test,riscv-mmu test suite,,Derived
pte.V=0 - write,MMU.SV39,CVA6V_009,4,"If PTE does not have Valid (pte.V=0) permission, then accessing it would raise page fault exception of the corresponding access type.When satp.mode=sv39 and PTE has (r,w,x) PMP permissions, then test the following in supervisor and user privilege mode for level2 to level0 PTE: Set PTE.V = 0 and test the write acces. For testing at levelN, set all the pte perimssions at level(N+1) to 0 except pte.v, so that level(N+1) points to levelN. Set pte.U=0 when test in Supervisor mode and Set pte.U=1 when testing in user mode. Page fault exception should be raised according to {x,r,w} access type. Check m/scause and m/sepc accordingly for write accesses.",Directed Test,riscv-mmu test suite,,Derived
pte.V=0 - execute,MMU.SV39,CVA6V_009,4,"If PTE does not have Valid (pte.V=0) permission, then accessing it would raise page fault exception of the corresponding access type.When satp.mode=sv39 and PTE has (r,w,x) PMP permissions, then test the following in supervisor and user privilege mode for level2 to level0 PTE: Set PTE.V = 0 and test the execute acces. For testing at levelN, set all the pte perimssions at level(N+1) to 0 except pte.v, so that level(N+1) points to levelN. Set pte.U=0 when test in Supervisor mode and Set pte.U=1 when testing in user mode. Page fault exception should be raised according to {x,r,w} access type. Check m/scause and m/sepc accordingly for execute accesses.",Directed Test,riscv-mmu test suite,,Derived
reserved RWX PTE permission - read,MMU.SV39,CVA6V_009,4,"If PTE has reserved RWX encodings (pte.w=1 & pte.r=0), then accessing it would raise page fault exception of the corresponding access type. When satp.mode=sv39, PTE has (r,w,x) PMP permissions, and pte.v=1, then test the following in supervisor and user privilege mode for level2 to level0 PTE: Set pte.w=1 & pte.r=0 and test the read access. For testing at levelN, set all the pte perimssions at level(N+1) to 0 except pte.v, so that level(N+1) points to levelN. Set pte.U=0 when test in Supervisor mode and Set pte.U=1 when testing in user mode.  Page fault exception should be raised according to {x,r,w} access type. Check m/scause and m/sepc accordingly for read accesses.",Directed Test,riscv-mmu test suite,,Derived
reserved RWX PTE permission - write,MMU.SV39,CVA6V_009,4,"If PTE has reserved RWX encodings (pte.w=1 & pte.r=0), then accessing it would raise page fault exception of the corresponding access type. When satp.mode=sv39, PTE has (r,w,x) PMP permissions, and pte.v=1, then test the following in supervisor and user privilege mode for level2 to level0 PTE: Set pte.w=1 & pte.r=0 and test the write access. For testing at levelN, set all the pte perimssions at level(N+1) to 0 except pte.v, so that level(N+1) points to levelN. Set pte.U=0 when test in Supervisor mode and Set pte.U=1 when testing in user mode.  Page fault exception should be raised according to {x,r,w} access type. Check m/scause and m/sepc accordingly for write accesses.",Directed Test,riscv-mmu test suite,,Derived
reserved RWX PTE permission - execute,MMU.SV39,CVA6V_009,4,"If PTE has reserved RWX encodings (pte.w=1 & pte.r=0), then accessing it would raise page fault exception of the corresponding access type. When satp.mode=sv39, PTE has (r,w,x) PMP permissions, and pte.v=1, then test the following in supervisor and user privilege mode for level2 to level0 PTE: Set pte.w=1 & pte.r=0 and test the execute access. For testing at levelN, set all the pte perimssions at level(N+1) to 0 except pte.v, so that level(N+1) points to levelN. Set pte.U=0 when test in Supervisor mode and Set pte.U=1 when testing in user mode.  Page fault exception should be raised according to {x,r,w} access type. Check m/scause and m/sepc accordingly for execute accesses.",Directed Test,riscv-mmu test suite,,Derived
non-leaf PTE permission at level 0 - read,MMU.SV39,CVA6V_009,4,"If PTE at level0 has non-leaf RWX permissions, then accessing it would raise page fault exception of the corresponding access type. When satp.mode=sv39, PTE has (r,w,x) PMP permissions, and pte.v=1, then test the following in supervisor and user privilege mode for level0 PTE: Set pte.x=0 & pte.r=0 & pte.w=0 and test the read acces. For testing at levelN, set all the pte perimssions at level(N+1) to 0 except pte.v, so that level(N+1) points to levelN. Set pte.U=0 when test in Supervisor mode and Set pte.U=1 when testing in user mode.  Page fault exception should be raised according to {x,r,w} access type. Check m/scause and m/sepc accordingly for read accesses.",Directed Test,riscv-mmu test suite,,Derived
non-leaf PTE permission at level 0 -write,MMU.SV39,CVA6V_009,4,"If PTE at level0 has non-leaf RWX permissions, then accessing it would raise page fault exception of the corresponding access type. When satp.mode=sv39, PTE has (r,w,x) PMP permissions, and pte.v=1, then test the following in supervisor and user privilege mode for level0 PTE: Set pte.x=0 & pte.r=0 & pte.w=0 and test the write acces. For testing at levelN, set all the pte perimssions at level(N+1) to 0 except pte.v, so that level(N+1) points to levelN. Set pte.U=0 when test in Supervisor mode and Set pte.U=1 when testing in user mode.  Page fault exception should be raised according to {x,r,w} access type. Check m/scause and m/sepc accordingly for write accesses.",Directed Test,riscv-mmu test suite,,Derived
non-leaf PTE permission at level 0 -execute,MMU.SV39,CVA6V_009,4,"If PTE at level0 has non-leaf RWX permissions, then accessing it would raise page fault exception of the corresponding access type. When satp.mode=sv39, PTE has (r,w,x) PMP permissions, and pte.v=1, then test the following in supervisor and user privilege mode for level0 PTE: Set pte.x=0 & pte.r=0 & pte.w=0 and test the execute acces. For testing at levelN, set all the pte perimssions at level(N+1) to 0 except pte.v, so that level(N+1) points to levelN. Set pte.U=0 when test in Supervisor mode and Set pte.U=1 when testing in user mode.  Page fault exception should be raised according to {x,r,w} access type. Check m/scause and m/sepc accordingly for execute accesses.",Directed Test,riscv-mmu test suite,,Derived
RWX on S-mode pages in S-mode - read,MMU.SV39,CVA6V_009,4,"If PTE belongs to supervisor mode i.e. its U permission bit is clear (pte.u = 0), then accessing that PTE in supervisor mode should be successful if the corresponding (r,w,x) permission of PTE is granted. Otherwise raise page fault exception of the corresponding access type. When satp.mode=sv39, PTE has (r,w,x) PMP permissions, PTE has non-reserved RWX encoding, pte.u=0 and pte.v=1, then test the following in supervisor privilege mode for level 2 to level 0 PTE: Test the read access for both pte.r=1 and for pte.r=0. Check for both successful access and access with page fault exceptions.  Check m/scause and m/sepc accordingly for read accesses.",Directed Test,riscv-mmu test suite,,Derived
RWX on S-mode pages in S-mode - write,MMU.SV39,CVA6V_009,4,"If PTE belongs to supervisor mode i.e. its U permission bit is clear (pte.u = 0), then accessing that PTE in supervisor mode should be successful if the corresponding (r,w,x) permission of PTE is granted. Otherwise raise page fault exception of the corresponding access type. When satp.mode=sv39, PTE has (r,w,x) PMP permissions, PTE has non-reserved RWX encoding, pte.u=0 and pte.v=1, then test the following in supervisor privilege mode for level 2 to level 0 PTE: Test the write access for both pte.w=1 and for pte.w=0. Check for both successful access and access with page fault exceptions.  Check m/scause and m/sepc accordingly for write accesses.",Directed Test,riscv-mmu test suite,,Derived
RWX on S-mode pages in S-mode - execute,MMU.SV39,CVA6V_009,4,"If PTE belongs to supervisor mode i.e. its U permission bit is clear (pte.u = 0), then accessing that PTE in supervisor mode should be successful if the corresponding (r,w,x) permission of PTE is granted. Otherwise raise page fault exception of the corresponding access type. When satp.mode=sv39, PTE has (r,w,x) PMP permissions, PTE has non-reserved RWX encoding, pte.u=0 and pte.v=1, then test the following in supervisor privilege mode for level 2 to level 0 PTE: Test the execute access for both pte.x=1 and for pte.x=0. Check for both successful access and access with page fault exceptions.  Check m/scause and m/sepc accordingly for execute accesses.",Directed Test,riscv-mmu test suite,,Derived
RWX on S-mode pages in U-mode - read,MMU.SV39,CVA6V_009,4,"If PTE belongs to supervisor mode i.e. its U permission bit is clear (pte.u = 0), then accessing that PTE in user mode would raise page fault exception of the corresponding access type. When satp.mode=sv39, PTE has (r,w,x) PMP permissions, PTE has on-reserved RWX encoding, and pte.v=1, then test the following user privilege mode for level2 to level0 PTE: Set pte.u=0 and test the read access. Check m/scause and m/sepc accordingly for read accesses.",Directed Test,riscv-mmu test suite,,Derived
RWX on S-mode pages in U-mode - write,MMU.SV39,CVA6V_009,4,"If PTE belongs to supervisor mode i.e. its U permission bit is clear (pte.u = 0), then accessing that PTE in user mode would raise page fault exception of the corresponding access type. When satp.mode=sv39, PTE has (r,w,x) PMP permissions, PTE has on-reserved RWX encoding, and pte.v=1, then test the following user privilege mode for level2 to level0 PTE: Set pte.u=0 and test the write access. Check m/scause and m/sepc accordingly for write accesses.",Directed Test,riscv-mmu test suite,,Derived
RWX on S-mode pages in U-mode - execute,MMU.SV39,CVA6V_009,4,"If PTE belongs to supervisor mode i.e. its U permission bit is clear (pte.u = 0), then accessing that PTE in user mode would raise page fault exception of the corresponding access type. When satp.mode=sv39, PTE has (r,w,x) PMP permissions, PTE has on-reserved RWX encoding, and pte.v=1, then test the following user privilege mode for level2 to level0 PTE: Set pte.u=0 and test the execute access. Check m/scause and m/sepc accordingly for execute accesses.",Directed Test,riscv-mmu test suite,,Derived
RWX on U-mode pages in S-mode w/ mstatus.SUM=0 - read,MMU.SV39,CVA6V_009,4,"If PTE belongs to user mode i.e. its U permission bit is set (pte.u = 1) and m/sstatus.SUM = 0, then accessing that PTE in supervisor mode would raise page fault exception of the corresponding access type. When satp.mode=sv39, PTE has (r,w,x) PMP permissions, PTE has non-reserved RWX encoding, and pte.v=1, then test the following in supervisor mode for level 2 to level 0 PTE. Set pte.u=1 & s/mstatus.SUM = 0 and test the read access.  For testing at levelN, set all the pte perimssions at level(N+1) to 0 except pte.v, so that level(N+1) points to levelN. Check m/scause and m/sepc accordingly for read accesses.",Directed Test,riscv-mmu test suite,,Derived
RWX on U-mode pages in S-mode w/ mstatus.SUM=0 - write,MMU.SV39,CVA6V_009,4,"If PTE belongs to user mode i.e. its U permission bit is set (pte.u = 1) and m/sstatus.SUM = 0, then accessing that PTE in supervisor mode would raise page fault exception of the corresponding access type. When satp.mode=sv39, PTE has (r,w,x) PMP permissions, PTE has non-reserved RWX encoding, and pte.v=1, then test the following in supervisor mode for level 2 to level 0 PTE. Set pte.u=1 & s/mstatus.SUM = 0 and test the write access.  For testing at levelN, set all the pte perimssions at level(N+1) to 0 except pte.v, so that level(N+1) points to levelN. Check m/scause and m/sepc accordingly for write accesses.",Directed Test,riscv-mmu test suite,,Derived
RWX on U-mode pages in S-mode w/ mstatus.SUM=0 - execute,MMU.SV39,CVA6V_009,4,"If PTE belongs to user mode i.e. its U permission bit is set (pte.u = 1) and m/sstatus.SUM = 0, then accessing that PTE in supervisor mode would raise page fault exception of the corresponding access type. When satp.mode=sv39, PTE has (r,w,x) PMP permissions, PTE has non-reserved RWX encoding, and pte.v=1, then test the following in supervisor mode for level 2 to level 0 PTE. Set pte.u=1 & s/mstatus.SUM = 0 and test the execute access.  For testing at levelN, set all the pte perimssions at level(N+1) to 0 except pte.v, so that level(N+1) points to levelN. Check m/scause and m/sepc accordingly for execute accesses.",Directed Test,riscv-mmu test suite,,Derived
RWX on U-mode pages in S-mode w/ mstatus.SUM=1 - read,MMU.SV39,CVA6V_009,4,"If PTE belongs to user mode i.e. its U permission bit is set (pte.u = 1) and m/sstatus.SUM = 1, then RW access to that PTE in supervisor mode would be successful but eXecute access would raise instruction page fault exception in s-mode. When atp.mode=sv39, PTE has (r,w,x) PMP permissions, PTE has non-reserved RWX encoding, and pte.v=1, then test the following in supervisor mode for level2 to level0 PTE: Set pte.r=1 & pte.u=1 & s/mstatus.SUM = 1 and test the read access. For testing at levelN, set all the pte perimssions at level(N+1) to 0 except pte.v, so that level(N+1) points to levelN. Check m/scause and m/sepc accordingly for read accesses.",Directed Test,riscv-mmu test suite,,Derived
RWX on U-mode pages in S-mode w/ mstatus.SUM=1 - write,MMU.SV39,CVA6V_009,4,"If PTE belongs to user mode i.e. its U permission bit is set (pte.u = 1) and m/sstatus.SUM = 1, then RW access to that PTE in supervisor mode would be successful but eXecute access would raise instruction page fault exception in s-mode. When atp.mode=sv39, PTE has (r,w,x) PMP permissions, PTE has non-reserved RWX encoding, and pte.v=1, then test the following in supervisor mode for level2 to level0 PTE: Set pte.r=1 & pte.u=1 & s/mstatus.SUM = 1 and test the write access. For testing at levelN, set all the pte perimssions at level(N+1) to 0 except pte.v, so that level(N+1) points to levelN. Check m/scause and m/sepc accordingly for write accesses.",Directed Test,riscv-mmu test suite,,Derived
RWX on U-mode pages in S-mode w/ mstatus.SUM=1 - execute,MMU.SV39,CVA6V_009,4,"If PTE belongs to user mode i.e. its U permission bit is set (pte.u = 1) and m/sstatus.SUM = 1, then RW access to that PTE in supervisor mode would be successful but eXecute access would raise instruction page fault exception in s-mode. When atp.mode=sv39, PTE has (r,w,x) PMP permissions, PTE has non-reserved RWX encoding, and pte.v=1, then test the following in supervisor mode for level2 to level0 PTE: Set pte.r=1 & pte.u=1 & s/mstatus.SUM = 1 and test the execute access. For testing at levelN, set all the pte perimssions at level(N+1) to 0 except pte.v, so that level(N+1) points to levelN. . Check m/scause and m/sepc accordingly for execute accesses.",Directed Test,riscv-mmu test suite,,Derived
RWX on U-mode pages in U-mode -read,MMU.SV39,CVA6V_009,4,"If PTE belongs to user mode i.e. its U permission bit is set (pte.u = 1), then accessing that PTE in user mode should be successful if the corresponding (r,w,x) permission of PTE is granted. Otherwise raise page fault exception of the corresponding access type. When satp.mode=sv39, PTE has (r,w,x) PMP permissions, PTE has non-reserved RWX encoding, pte.u=1 and pte.v=1, then test the following in user privilege mode for level2 to level0 PTE. Test the read access for both pte.r=1 and for pte.r=0. For testing at levelN, set all the pte perimssions at level(N+1) to 0 except pte.v, so that level(N+1) points to levelN. Check m/scause and m/sepc accordingly for read accesses.",Directed Test,riscv-mmu test suite,,Derived
RWX on U-mode pages in U-mode -write,MMU.SV39,CVA6V_009,4,"If PTE belongs to user mode i.e. its U permission bit is set (pte.u = 1), then accessing that PTE in user mode should be successful if the corresponding (r,w,x) permission of PTE is granted. Otherwise raise page fault exception of the corresponding access type. When satp.mode=sv39, PTE has (r,w,x) PMP permissions, PTE has non-reserved RWX encoding, pte.u=1 and pte.v=1, then test the following in user privilege mode for level2 to level0 PTE. Test the write access for both pte.w=1 and for pte.w=0. For testing at levelN, set all the pte perimssions at level(N+1) to 0 except pte.v, so that level(N+1) points to levelN. Check m/scause and m/sepc accordingly for write accesses.",Directed Test,riscv-mmu test suite,,Derived
RWX on U-mode pages in U-mode -execute,MMU.SV39,CVA6V_009,4,"If PTE belongs to user mode i.e. its U permission bit is set (pte.u = 1), then accessing that PTE in user mode should be successful if the corresponding (r,w,x) permission of PTE is granted. Otherwise raise page fault exception of the corresponding access type. When satp.mode=sv39, PTE has (r,w,x) PMP permissions, PTE has non-reserved RWX encoding, pte.u=1 and pte.v=1, then test the following in user privilege mode for level2 to level0 PTE. Test the execute access for both pte.x=1 and for pte.x=0. For testing at levelN, set all the pte perimssions at level(N+1) to 0 except pte.v, so that level(N+1) points to levelN. Check m/scause and m/sepc accordingly for execute accesses.",Directed Test,riscv-mmu test suite,,Derived
Executable Page Readability with s/mstatus.MXR=0,MMU.SV39,CVA6V_009,4,"If PTE has only execute permission (pte.x = 1) and s/mstatus.MXR=0, then read access on that PTE should raise load page fault exception. When satp.mode=sv39, PTE has (r,w,x) PMP permissions, and pte.v=1, then test the following in supervisor and user privilege mode for level2 to level0 PTE. Set pte.r=0 & pte.w=0 & pte.x=1 & s/mstatus.MXR=0 and test the read access. For testing at levelN, set all the pte perimssions at level(N+1) to 0 except pte.v, so that level(N+1) points to levelN. Set pte.U=0 when test in Supervisor mode and Set pte.U=1 when testing in user mode. Check m/scause and m/sepc accordingly for read accesses.",Directed Test,riscv-mmu test suite,,Derived
Executable Page Readability with s/mstatus.MXR=1,MMU.SV39,CVA6V_009,4,"If PTE has only execute permission (pte.x = 1) and s/mstatus.MXR=1, then read access on that PTE should be successful without having explicit read permission (pte.r=0). When satp.mode=sv39, PTE has (r,w,x) PMP permissions, and pte.v=1, then test the following in supervisor and user privilege mode for level2 to level0 PTE. Set pte.r=0 & pte.w=0 & pte.x=1 & s/mstatus.MXR=1 and test the read acces. For testing at levelN, set all the pte perimssions at level(N+1) to 0 except pte.v, so that level(N+1) points to levelN. Set pte.U=0 when test in Supervisor mode and Set pte.U=1 when testing in user mode. Check m/scause and m/sepc accordingly for read accesses.",Directed Test,riscv-mmu test suite,,Derived
global mapping,MMU.SV39,CVA6V_009,4,"For two different processes having same Virtual address and different satp.ASID, maps to same Physical address, and the pte.G is set; then one process will go through the address translation and update the TLB while the 2nd process will not go through the translation if pte.G is set and Physical address exist in TLB. Show that two different processes having same VA to PA mapping can access the translated PA from TLB (if exist) and not go through complete translation.",Directed Test,riscv-mmu test suite,,Derived
access bit implementation -read,MMU.SV39,CVA6V_009,4,"If implementation does not set the pte.A on accessing the PTE, and PTE has pte.A=0, then accessing it would raise page fault exception of the corresponding access type. When satp.mode=sv39, PTE has (r,w,x) PMP permissions, and pte.v=1, then test the following in supervisor and user privilege mode for level2 and level0 PTE. Execute sfence.vma before accessign the PTE. Set pte.r=1 & pte.a=0 and test the read access. For testing at levelN, set all the pte perimssions at level(N+1) to 0 except pte.v, so that level(N+1) points to levelN. Set pte.U=0 when test in Supervisor mode and Set pte.U=1 when testing in user mode. Check m/scause and m/sepc accordingly for read accesses.",Directed Test,riscv-mmu test suite,,Derived
access bit implementation -write,MMU.SV39,CVA6V_009,4,"If implementation does not set the pte.A on accessing the PTE, and PTE has pte.A=0, then accessing it would raise page fault exception of the corresponding access type. When satp.mode=sv39, PTE has (r,w,x) PMP permissions, and pte.v=1, then test the following in supervisor and user privilege mode for level2 and level0 PTE. Execute sfence.vma before accessign the PTE. Set pte.w=1 & pte.a=0 and test the write access. For testing at levelN, set all the pte perimssions at level(N+1) to 0 except pte.v, so that level(N+1) points to levelN. Set pte.U=0 when test in Supervisor mode and Set pte.U=1 when testing in user mode. Check m/scause and m/sepc accordingly for write accesses.",Directed Test,riscv-mmu test suite,,Derived
access bit implementation -execute,MMU.SV39,CVA6V_009,4,"If implementation does not set the pte.A on accessing the PTE, and PTE has pte.A=0, then accessing it would raise page fault exception of the corresponding access type. When satp.mode=sv39, PTE has (r,w,x) PMP permissions, and pte.v=1, then test the following in supervisor and user privilege mode for level2 and level0 PTE. Execute sfence.vma before accessign the PTE. Set pte.x=1 & pte.a=0 and test the execute access. For testing at levelN, set all the pte perimssions at level(N+1) to 0 except pte.v, so that level(N+1) points to levelN. Set pte.U=0 when test in Supervisor mode and Set pte.U=1 when testing in user mode. Check m/scause and m/sepc accordingly for execute accesses.",Directed Test,riscv-mmu test suite,,Derived
dirty bit Implementation,MMU.SV39,CVA6V_009,4,"If implementation does not sets the pte.D when PTE is written, and PTE has pte.D=0, then attempting to store on that PTE would raise Store/AMO page fault exception. When satp.mode=sv39, PTE has (r,w,x) PMP permissions, pte.a=1 and pte.v=1, then test the following in supervisor and user privilege mode for level2 to level0 PTE. Execute sfence.vma before accessign the PTE. Set pte.w=1 & pte.d=0 and test the write access. For testing at levelN, set all the pte perimssions at level(N+1) to 0 except pte.v, so that level(N+1) points to levelN. Set pte.U=0 when test in Supervisor mode and Set pte.U=1 when testing in user mode. Store/AMO page fault exception should be raised. Check m/scause and m/sepc accordingly for write accesses.",Directed Test,riscv-mmu test suite,,Derived
misaligned superpage,MMU.SV39,CVA6V_009,4,"If PTE at level2/level1 is leaf PTE (superpage) and its pte.ppn[1/0]=0, then it is a misaligned superpage and accessing that PTE would raise page fault exception of the corresponding access type. When satp.mode=sv32, PTE has (r,w,x) PMP permissions, PTE has non-reserved RWX encodings, (pte.r | pte.x)=1, and pte.v=1, then test the following in supervisor and user privilege mode for level2/level1 PTE: Set pte.ppn[0]=0 and test for read, write and execute access. Set pte.U=0 when test in Supervisor mode and Set pte.U=1 when testing in user mode.  Check m/scause and m/sepc accordingly for read/write/execute accesses.",Directed Test,riscv-mmu test suite,,Derived
accessing satp and sfence.vma CSRs,MMU.SV39,CVA6V_009,4,"If mstatus.TVM=1, read and write access to the satp and sfence.vma will raise illegal instruction exception in S-mode. Show that s/mcause contains the exception number of illegal instruction exception. Check that m/sepc must contain the virtual address of the instruction at which the trap occurs.",Directed Test,riscv-mmu test suite,,Derived
satp access permission,MMU.SV39,CVA6V_009,4,"Access satp in M, S, and U mode using csrrw, csrrc, csrrs. Show that satp is only accessible in M and S mode and illegal instruction exception is generated when accessed in lower privilege mode.",Directed Test,riscv-mmu test suite,,Derived
satp mode field= sv39,MMU.SV39,CVA6V_009,4,Mode field allows to select different schemes of address translation. Writes to satp are ignored when unsupported mode is selected. Show that supported address translation scheme i.e sv39 is selected by writing satp.mode=sv39 and reading back the satp.,Directed Test,riscv-mmu test suite,,Derived
satp mode field= bare,MMU.SV39,CVA6V_009,4,Verify Bare Mode/Virtualization disabled.,Directed Test,riscv-mmu test suite,,Derived
satp ASID field,MMU.SV39,CVA6V_009,4,"ASIDLEN is the number of ASID bits implemented. MAXASID bits for sv39 is 16. Determine by writing one to every bit position in the ASID field, then reading back the value in satp to see which bit positions in the ASID field hold a one. Show that ASIDLEN is equal to the expected ASIDLEN",Directed Test,riscv-mmu test suite,,Derived
,,,,,,,,
,,,,,,,,
,,,,,,,,
vector configuration instructions,ISA.RVV,CVA6V_0011,5,"Set Vector Length and Type With Imm5 (vsetvli), Set Vector Length and Type With Uimm and Imm5 (vsetivli), Set Vector Length and Type (vsetvl)",Functional Coverage,,Vector,No
vector integer add subtract instructions,ISA.RVV,CVA6V_0011,5,"Vector-Vector Averaging Addition (vaadd.vv), Vector-Integer Averaging Addition (vaadd.vx) , Vector-Vector Averaging Addition Unsigned (vaaddu.vv), Vector-Integer Averaging Addition Unsigned (vaaddu.vx), Vector-Vector Addition with Carry (vadc.vvm), Vector-Scalar Addition with Carry (vadc.vxm), Vector-Immediate Addition with Carry (vadc.vim), Vector-Vector Addition (vadd.vv), Vector-Scalar Addition (vadd.vx), Vector-Immediate Addition (vadd.vi), Vector-Vector Averaging Subtraction (vasub.vv), Vector-Scalar Averaging Subtraction (vasub.vx), Vector-Immediate Averaging Subtraction (vasub.vi), Vector-Vector Averaging Subtraction Unsigned (vasubu.vv), Vector-Integer Averaging Subtraction Unsigned (vasubu.vx), Vector-Immediate Averaging Subtraction Unsigned (vasubu.vi), Vector-Scalar Add with Carry In Mask Register (vmadc.vxm),  Vector-Immediate Add with Carry In Mask Register (vmadc.vim),  Vector-Vector Add No Carry In (vmadc.vv), Vector-Scalar Add No Carry In (vmadc.vx), Vector-Immediate Add No Carry In (vmadc.vi), Vector-Vector Subtract with Borrow In Mask Register (vmsbc.vvm),  Vector-Scalar Subtract with Borrow In Mask Register (vmsbc.vxm),  Vector-Vector Subtract No Borrow In (vmsbc.vv), Vector-Scalar Subtract No Borrow In (vmsbc.vx), Vector-Scalar Reverse Subtract (vrsub.vx), Vector-Immediate Reverse Subtract (vrsub.vi), Vector-Vector Subtract With Borrow (vsbc.vvm),  Vector-Scalar Subtract With Borrow (vsbc.vxm), Vector-Vector Subtract (vsub.vv), Vector-Scalar Subtract (vsub.vx)",Functional Coverage,,Vector,No
vector integer saturating add subtract instructions,ISA.RVV,CVA6V_0011,5,"Vector-Vector Saturating Add Unsigned (vsaddu.vv), Vector-Scalar Saturating Add Unsigned (vsaddu.vx), Vector-Immediate Saturating Add Unsigned (vsaddu.vi), Vector-Vector Saturating Add Signed (vsadd.vv), Vector-Scalar Saturating Add Signed (vsadd.vx), Vector-Immediate Saturating Add Signed (vsadd.vi), Vector-Vector Saturating Subtract Unsigned (vssubu.vv), Vector-Scalar Saturating Subtract Unsigned (vssubu.vx), Vector-Immediate Saturating Subtract Unsigned (vssubu.vi), Vector-Vector Saturating Subtract Signed (vssub.vv), Vector-Scalar Saturating Subtract Signed (vssub.vx), Vector-Immediate Saturating Subtract Signed (vssub.vi)",Functional Coverage,,Vector,No
vector integer widening add subtract instructions,,CVA6V_0011,,"Vector-Vector Widening Unsigned Integer Add (vwaddu.vv), Vector-Scalar Widening Unsigned Integer Add (vwaddu.vx), Vector-Vector Widening Signed Integer Add (vwadd.vv), Vector-Scalar Widening Signed Integer Add (vwadd.vx), Vector-Vector Widening Unsigned Integer Subtract (vwsubu.vv), Vector-Scalar Widening Unsigned Integer Subtract (vwsubu.vx), Vector-Vector Widening Signed Integer Subtract (vwsub.vv), Vector-Scalar Widening Signed Integer Subtract (vwsub.vx)",Functional Coverage,,Vector,No
vector integer widening multiply-add instructions,ISA.RVV,CVA6V_0011,5,"Vector-Vector Widening Unsigned Integer Multiply Add (vwmaccu.vv), Vector-Scalar Widening Unsigned Integer Multiply Add (vwmaccu.vx), Vector-Vector Widening Signed Integer Multiply Add (vwmacc.vv), Vector-Scalar Widening Signed Integer Multiply Add (vwmacc.vx), Vector-Vector Widening Signed-Unsigned Integer Multiply Add (vwmaccsu.vv), Vector-Scalar Widening Signed-Unsigned Integer Multiply Add (vwmaccsu.vx),  Vector-Scalar Widening Unsigned-Signed Integer Multiply Add (vwmaccus.vx), Vector-Vector Widening Signed Integer Multiply (vwmul.vv), Vector-Scalar Widening Signed Integer Multiply (vwmul.vx), Vector-Vector Widening Unsigned Integer Multiply (vwmulu.vv), Vector-Scalar Widening Unsigned Integer Multiply (vwmulu.vx), Vector-Vector Widening Signed-Unsigned Integer Multiply (vwmulsu.vv), Vector-Scalar Widening Signed-Unsigned Integer Multiply (vwmulsu.vv)",Functional Coverage,,Vector,No
vector integer multiply divide instructions,ISA.RVV,CVA6V_0011,5,"Vector-Vector Division (vdiv.vv), Vector-Scalar Division (vdiv.vx), Vector-Immediate Division (vdiv.vi), Vector-Vector Division Unsigned (vdivu.vv), Vector-Scalar Division Unsigned (vdivu.vx), Vector-Immediate Division Unsigned (vdivu.vi), Vector-Vector Multiply-Accumulate (vmacc.vv), Vector-Scalar Multiply-Accumulate (vmacc.vx), Vector-Vector Multiply Add (vmadd.vv), Vector-Scalar Multiply Add (vmadd.vx), Vector-Vector Multiply (vmul.vv), Vector-Scalar Multiply (vmul.vx), Vector-Vector Multiply High Bits Product (vmulh.vv), Vector-Scalar Multiply High Bits Product (vmulh.vx),  Vector-Vector Multiply High Bits Product Signed Unsigned (vmulhsu.vv), Vector-Scalar Multiply High Bits Product Signed Unsigned (vmulhsu.vx), Vector-Vector Multiply High Bits Product Unsigned (vmulhu.vv), Vector-Scalar Multiply High Bits Product Unsigned (vmulhu.vx), Vector-Vector Multiply-Sub Overwrite Minuend (vnmsac.vv), Vector-Scalar Multiply-Sub Overwrite Minuend (vnmsac.vx),  Vector-Vector Multiply-Sub Overwrite Multiplicand  (vnmsub.vv),   Vector-Scalar Multiply-Sub Overwrite Multiplicand  (vnmsac.vx), Vector-Vector Remainder Unsigned (vremu.vv),  Vector-Scalar Remainder Unsigned (vremu.vx), Vector-Vector Remainder Signed (vrem.vv),  Vector-Scalar Remainder Signed (vrem.vx)",Functional Coverage,,Vector,No
vector integer saturating multiply divide instructions,,CVA6V_0011,,"Vector-Vector Signed Saturating And Rounding Fractional Multiply (vsmul.vv), Vector-Scalar Signed Saturating And Rounding Fractional Multiply (vsmul.vx)",,,Vector,
vector integer logical instructions,ISA.RVV,CVA6V_0011,5,"Vector-Vector AND (vand.vv), Vector-Scalar AND (vand.vx), Vector-Immediate AND (vand.vi), Vector-Vector OR (vor.vv), Vector-Scalar OR (vor.vx), Vector-Immediate OR (vor.vi), Vector-Vector Shift Left Logical (vsll.vv), Vector-Scalar Shift Left Logical (vsll.vx), Vector-Immediate Shift Left Logical (vsll.vi),  Vector-Vector Shift Right Logical (vsrl.vv), Vector-Scalar Shift Right Logical (vsrl.vx), Vector-Immediate Shift Right Logical (vsrl.vi), Vector-Vector Shift Right Arithmetic (vsra.vv), Vector-Scalar Shift Right Arithmetic (vsra.vx), Vector-Immediate Shift Right Arithmetic (vsra.vi), Vector-Vector Scaling Shift Right Arithmetic (vssra.vv), Vector-Scalar Scaling Shift Right Arithmetic (vssra.vx), Vector-Immediate Scaling Shift Right Arithmetic (vssra.vi), Vector-Vector Scaling Shift Right Logical (vssrl.vv), Vector-Scalar Scaling Shift Right Logical (vssrl.vx), Vector-Immediate Scaling Shift Right Logical (vssrl.vi), Vector-Vector XOR (vxor.vv), Vector-Scalar XOR (vxor.vx), Vector-Immediate XOR (vxor.vi)",Functional Coverage,,Vector,No
vector integer reduction instructions,ISA.RVV,CVA6V_0011,5,"Vector Reduction AND (vredand.vs), Vector Reduction Maximum Signed  (vredmax.vs), Vector Reduction Maximum Unsigned (vredmaxu.vs), Vector Reduction Minimum Signed  (vredmin.vs), Vector Reduction Minimum Unsigned (vredminu.vs),  Vector Reduction OR (vredor.vs), Vector Reduction SUM (vredsum.vs), Vector Reduction XOR (vredxor.vs), Vector Widening Unsigned Sum Reduction (vwredsumu.vs), Vector Widening Signed Sum Reduction (vwredsum.vs)",Functional Coverage,,Vector,No
vector permutation instructions,ISA.RVV,CVA6V_0011,5,"Vector Compress (vcompress.vm), Vector Population Count (vcpop.m), Vector First Non-Zero (vfirst.m), Vector-Vector Floating Point Maximum (vfmax.vv), Vector-Scalar Floating Point Maximum (vfmax.vf), Vector Floating Point Merge (vfmerge.vfm), Vector-Vector Floating Point Minimum (vfmin.vv), Vector-Scalar Floating Point Minimum (vfmin.vf), Vector Floating Point Slide 1 Down (vfslide1down.vf), Vector Floating Point Slide 1 Up (vfslide1up.vf), Vector-Vector Maximum (vmax.vv), Vector-Scalar Maximum (vmax.vx), Vector-Vector Maximum Unsigned (vmaxu.vv), Vector-Scalar Maximum Unsigned (vmaxu.vx), Vector-Vector Integer Merge (vmerge.vvm), Vector-Scalar Integer Merge (vmerge.vxm), Vector-Immediate Integer Merge (vmerge.vim), Vector-Vector Minimum (vmin.vv), Vector-Scalar Minimum (vmin.vx), Vector-Vector Minimum Unsigned (vminu.vv), Vector-Scalar Minimum Unsigned (vminu.vx), Vector-Vector Register Gather (vrgather.vv), Vector-Scalar Register Gather (vrgather.vx), Vector-Immediate Register Gather (vrgather.vi), Vector-Vector Register Gather EEW=16 and EMUL = (16/SEW)*LMUL (vrgatherei16.vv), Vector Slide 1 Down (vslide1down.vx), Vector Immediate Slide 1 Down (vslide1down.vi), Vector Slide 1 Up (vslide1up.vx), Vector Immediate Slide 1 Up (vslide1up.vi), Vector Slide Down (vslidedown.vx), Vector Slide Down Immediate (vslidedown.vi), Vector Slide Up (vslideup.vx), Vector Slide Up Immediate (vslideup.vi)",Functional Coverage,,Vector,No
vector floating point arithmetic instructions,ISA.RVV,CVA6V_0011,5,"Vector-Vector Floating-Point Addition (vfadd.vv), Vector-Scalar Floating-Point Addition (vfadd.vf), Vector Floating Point Classify (vfclass.v), Vector-Vector Floating-Point Division (vfdiv.vv), Vector-Scalar Floating-Point Division (vfdiv.vf), Vector-Vector Floating Point Multiply Acummulate (vfmacc.vv), Vector-Scalar Floating Point Multiply Acummulate (vfmacc.vf),  Vector-Vector Floating Point Multiply Add (vfmadd.vv), Vector-Scalar Floating Point Multiply Add (vfmadd.vf), Vector-Vector Floating Point Multiply Subtract Accumulator (vfmsac.vv), Vector-Scalar Floating Point  Multiply Subtract Accumulator (vfmsac.vf), Vector-Vector Floating Point Multiply Subtract (vfmsub.vv), Vector-Scalar Floating Point  Multiply Subtract (vfmsub.vf), Vector-Vector Floating-Point Multiplication (vfmul.vv), Vector-Scalar Floating-Point Multiplication (vfmul.vf), Reverse Floating Point Divide Vector (vfrdiv.vf), Vector Floating-Point Reciprocal Estimate to 7 Bits (frec7.v), Vector Floating-Point Reciprocal Square-Root Estimate to 7 Bits (vfsqrt7.v), Vector Floating Point Subtract (vfrsub.vf), Vector Floating Point Square Root (vfsqrt.v), Vector-Vector Floating Point Subtract (vfsub.vv), Vector-Scalar Floating Point Subtract (vfsub.vf)",Functional Coverage,,Vector,No
vector floating point arithmetic negate instructions,ISA.RVV,CVA6V_0011,5,"Vector-Vector Floating Point Negate Multply Acummulate (vfnmacc.vv), Vector-Scalar Floating Point Negate Multply Acummulate (vfnmacc.vf),  Vector-Vector Floating Point Negate Multiply Add (vfnmadd.vv), Vector-Scalar Floating Point Negate Multiply Add (vfnmadd.vf), Vector-Vector Floating Point Negate Multiply Subtract Accumulator (vfnmsac.vv), Vector-Scalar Floating Point Negate Multiply Subtract Accumulator (vfnmsac.vf), Vector-Vector Floating Point Negate Multiply Subtract (vfnmsub.vv), Vector-Scalar Floating Point Negate Multiply Subtract (vfnmsub.vf)",Functional Coverage,,Vector,No
vector floating point arithmetic widening instructions,ISA.RVV,CVA6V_0011,5,"Vector-Vector Widening Floating Point Addition (vfwadd.vv),  Vector-Scalar Widening Floating Point Addition (vfwadd.vf),  Widened Vector-Vector Widening Floating Point Addition (vfwadd.wv), Widened Vector-Scalar Widening Floating Point Addition (vfwadd.wf), Vector-Vector Widening Floating Point Subtraction (vfwsub.vv),  Vector-Scalar Widening Floating Point Subtraction (vfwsub.vf),  Widened Vector-Vector Widening Floating Point Subtraction (vfwsub.wv), Widened Vector-Scalar Widening Floating Point Subtraction (vfwsub.wf), Vector-Vector Widening Floating-Point Multiply-Accumulate (vfwmacc.vv),  Vector-Scalar Widening Floating-Point Multiply-Accumulate  (vfwmacc.vf),  Vector-Vector Widening Floating-Point Multiply-Subtract-Accumulate (vfwmsac.vv), Vector-Scalar Widening Floating-Point Multiply-Subtract-Accumulate (vfwmsac.vf), Vector-Vector Widening Floating-Point Multiply (vfwmul.vv), Vector-Scalar Widening Floating-Point Multiply (vfwmul.vf), Vector-Vector Widening Floating-Point Negate Multiply-Accumulate (vfwnmacc.vv),  Vector-Scalar Widening Floating-Point Negate Multiply-Accumulate (vfwnmacc.vf), Vector-Vector Widening Floating-Point Negate Multiply-Subtract-Accumulate (vfwnmsac.vv), Vector-Scalar Widening Floating-Point Negate Multiply-Subtract-Accumulate (vfwnmsac.vf)",Functional Coverage,,Vector,No
vector floating point conversion instructions,ISA.RVV,CVA6V_0011,5,"Vector Floating Point Conversion To Unsigned Integer (vfcvt.xu.f.v), Vector Floating Point Conversion To Signed Integer (vfcvt.x.f.v), Vector Floating Point Conversion To Unsigned Integer Using Round to Zero (vfcvt.rtz.xu.f.v), Vector Floating Point Conversion To Signed Integer Using Round to Zero (vfcvt.rtz.x.f.v), Vector Unsigned Integer Conversion to Floating Point (vfcvt.f.xu.v), Vector Double Width Float Convert to Unsigned Integer (vfncvt.xu.f.w), Vector Double Width Float Convert to Signed Integer (vfncvt.x.f.w), Vector Double Width Float Convert to Unsigned Integer Truncating (vfncvt.rtz.xu.f.w), Vector Double Width Float Convert to Signed Integer Truncating (vfncvt.rtz.x.f.w), Vector Double Width Unsigned Integer Convert to Float (vfncvt.f.xu.w), Vector Double Width Signed Integer Convert to Float (vfncvt.f.x.w), Vector Double Width Float Convert to Single Width Float (vfncvt.f.f.w), Vector Double Width Float Convert to Single Width Float  Rounding to Odd (vfncvt.rod.f.f.w)",Functional Coverage,,Vector,No
vector floating point conversion widening instructions,ISA.RVV (Zvfh Zvfhmin),CVA6V_0012,5,"Convert Float to Double-Width Unsigned Integer (vfwcvt.xu.f.v), Convert Float to Double-Width Signed Integer (vfwcvt.x.f.v), Convert Float to Double-Width Unsigned Integer, Truncating (vfwcvt.rtz.xu.f.v), Convert Float to Double-Width Signed Integer, Truncating (vfwcvt.rtz.x.f.v), Convert Unsigned Integer to Double-Width Float (vfwcvt.f.xu.v), Convert Signed Integer to Double-Width Float (vfwcvt.f.x.v),  Convert Single-Width Float to Double-Width Float (vfwcvt.f.f.v)",Functional Coverage,,Vector,No
vector floating point move instructions,ISA.RVV,CVA6V_0011,5,"Vector Floating Point Move (vfmv.v.f),  Floating Point Scalar Move to Vector (vfmv.f.s), Vector  Move to Floating Point (vfmv.s.f), ",Functional Coverage,,Vector,No
vector floating point reduction instructions,ISA.RVV,CVA6V_0011,5,"Vector Floating Point Reduction Maximum (vfredmax.vs), Vector Floating Point Reduction Minimum (vfredmin.vs), Vector Floating Point Reduction Ordered Sum (vfredosum.vs), Vector Floating Point Reduction Unordered Sum (vfredusum.vs), Vector Widening Floating Point Reduction Ordered Sum (vfwredosum.vs), Vector Widening Floating Point Reduction Unordered Sum (vfwredusum.vs)",Functional Coverage,,Vector,No
vector floating point sign injection instructions,ISA.RVV,CVA6V_0011,5,"Vector-Vector Sign Injection (vfsgnj.vv), Vector-Scalar  Sign Injection (vfsgnj.vf), Vector-Vector Negated Sign Injection (vfsgnjn.vv) , Vector-Scalar Negated Sign Injection (vfsgnjn.vf), Vector-Vector Sign Injection Exclusive OR (vfsgnjx.vv), Vector-Scalar Sign Injection Exclusive OR (vfsgnjx.vf)",Functional Coverage,,Vector,No
vector floating point compare instructions,ISA.RVV,CVA6V_0011,5,"Vector-Vector Floating Point Compare Equal (vmfeq.vv), Vector-Scalar Floating Point Compare Equal (vmfeq.vf), Vector-Vector Floating Point Compare Greater Than Or Equal (vmfge.vv), Vector-Scalar Floating Point Compare Greater Than Or Equal (vmfge.vf), Vector-Vector Floating Point Compare Greater Than (vmfgt.vv), Vector-Scalar Floating Point Compare Greater Than (vmfgt.vf), Vector-Vector Floating Point Compare Less Than Or Equal (vmfle.vv), Vector-Scalar Floating Point Compare Less Than Or Equal (vmfle.vf), Vector-Vector Floating Point Compare Less Than (vmflt.vv), Vector-Scalar Floating Point Compare Less Than (vmflt.vf), Vector-Vector Floating Point Not Equal (vmfne.vv), Vector-Scalar Floating Point Compare Not Equal (vmfne.vf), ",Functional Coverage,,Vector,No
vector load instructions,ISA.RVV,CVA6V_0014,5,"Vector Load with VLEN/8 bytes (vl1re8.v), Vector Load with VLEN/16 bytes (vl1re16.v), Vector Load with VLEN/32 bytes (vl1re32.v), Vector Load 2 Registers with VLEN/8 bytes (vl2re8.v), Vector Load 2 registers with VLEN/16 bytes (vl2re16.v), Vector Load 2 Registers with VLEN/32 bytes (vl2re32.v), Vector Load 2 Registers with VLEN/8 bytes (vl2re8.v), Vector Load 2 registers with VLEN/16 bytes (vl2re16.v), Vector Load 2 Registers with VLEN/32 bytes (vl2re32.v), Vector Load 4 Registers with VLEN/8 bytes (vl4re8.v), Vector Load 4 registers with VLEN/16 bytes (vl4re16.v), Vector Load 4 Registers with VLEN/32 bytes (vl4re32.v), Vector Load 8 Registers with VLEN/8 bytes (vl8re8.v), Vector Load 8 registers with VLEN/16 bytes (vl8re16.v), Vector Load 8 Registers with VLEN/32 bytes (vl8re32.v), ",Functional Coverage,,Vector,No
vector unit stride/index loads,ISA.RVV,CVA6V_0014,5,"8-bit Unit-Stride Load (vle8.v), 16-bit Unit-Stride Load (vle16.v), 32-bit Unit-Stride Load (vle32.v), 8-bit Unit-Stride Fault-Only-First load (vle8ff.v), 16-bit Unit-Stride Fault-Only-First load (vle16ff.v), 32-bit Unit-Stride Fault-Only-First load (vle32ff.v), Unordered 8-bit Indexed Load of SEW data (vluxei8.v), Unordered  16-bit Indexed Load of SEW data (vluxei16.v), Unordered  32-bit Indexed Load of SEW data (vluxei32.v), Ordered 8-bit Indexed Load of SEW data (vloxei8.v), Ordered 16-bit Indexed Load of SEW data (vloxei16.v), Ordered 32-bit Indexed Load of SEW data (vloxei32.v), 8-bit Strided Load (vlse8.v), 16-bit Strided Load (vlse16.v), 32-bit Strided Load (vlse32.v), 1-unit Load (vle1.v)",Functional Coverage,,Vector,No
vector unit stride/index stores,ISA.RVV,CVA6V_0014,5,"Store 1 Vector Register To Address (vs1r.v), Store 2 Vector Register To Address (vs2r.v), Store 4 Vector Register To Address (vs4r.v), Store 8 Vector Register To Address (vs8r.v), 8-Bit Unit-Stride Store (vse8.v), 16-Bit Unit-Stride Store (vse16.v), 32-Bit Unit-Stride Store (vse32.v), 1-unit Store (vse1.v), 8-bit Strided Store (vsse8.v), 16-bit Strided Store (vsse16.v), 32-bit Strided Store (vsse32.v), Unordered  8-bit Indexed Store (vsuxei8.v), Unordered  16-bit Indexed Store (vsuxei16.v), Unordered  32-bit Indexed Store (vsuxei32.v), Ordered  8-bit Indexed Store (vsoxei8.v), Ordered  16-bit Indexed Store (vsoxei16.v), Ordered  32-bit Indexed Store (vsoxei32.v)",Functional Coverage,,Vector,No
vector mask instructions,ISA.RVV,CVA6V_0011,5,"Vector Mask AND (vmand.mm), Vector Mask AND With Negated Last Operand (vmandn.mm), Vector Mask AND Negated (vmnand.mm), Vector Mask NOR (vmnor.mm), Vector Mask OR (vmor.mm), Vector Mask OR With Negated Last Operand (vmorn.mm), Set-Before-First Mask Bit (vmsbf.m), Vector-Vector Mask Set If Equal (vmseq.vv), Vector-Scalar Mask Set If Equal (vmseq.vx), Vector-Immediate Mask Set If Equal (vmseq.vi), Vector-Scalar Mask Set If Greater Than Signed (vmsgt.vx), Vector-Immediate Mask Set If Greater Than Signed (vmsgt.vi),  Vector-Scalar Mask Set If Greater Than Unsigned (vmsgtu.vx), Vector-Immediate Mask Set If Greater Than Unsigned (vmsgtu.vi), Set-Including-First-Mask-Bit (vmsif.m), Vector-Vector Mask Set If Less Than Or Equal (vmsle.vv), Vector-Scalar Mask Set If Less Than Or Equal (vmsle.vx), Vector-Immediate Mask Set If Less Than Or Equal (vmsle.vi), Vector-Vector Mask Set If Less Than Or Equal Unsigned (vmsleu.vv), Vector-Scalar Mask Set If Less Than Or Equal Unsigned (vmsleu.vx), Vector-Immediate Mask Set If Less Than Or Equal Unsigned (vmsleu.vi),  Vector-Vector Mask Set If Less Than (vmslt.vv), Vector-Scalar Mask Set If Less Than (vmslt.vx), Vector-Immediate Mask Set If Less Than (vmslt.vi), Vector-Vector Mask Set If Less Than Unsigned (vmsltu.vv), Vector-Scalar Mask Set If Less Unsigned (vmsltu.vx), Vector-Immediate Mask Set If Less Than Unsigned (vmsltu.vi),  Vector-Vector Mask Set If Not Equal (vmsne.vv), Vector-Scalar Mask Set If Not Equal  (vmsne.vx), Vector-Immediate Mask Set If Not Equal (vmsne.vi), Set-Only-First Mask Bit (vmsof.m), Vector Mask XNOR (vmxnor.mm), Vector Mask XOR (vmxor.mm)",Functional Coverage,,Vector,No
vector narrowing instructions,,CVA6V_0011,5,"Narrowing Unsigned Clip From Vector Shift Amount (vnclip.wv), Narrowing Unsigned Clip From Integer  Shift Amount (vnclip.wx), Narrowing Unsigned Clip From Immediate Shift Amount (vnclip.wv), Vector-Vector Narrowing Shift Right Arithmetic (vnsra.wv), Vector-Scalar Narrowing Shift Right Arithmetic (vnsra.wx), Vector-Immediate Narrowing Shift Right Arithmetic (vnsra.wi), Vector-Vector Narrowing Shift Right Logical (vnsrl.wv), Vector-Scalar Narrowing Shift Right Logical (vnsrl.wx), Vector-Immediate Narrowing Shift Right Logical (vnsrl.wi),",Functional Coverage,,Vector,No
vector misc instructions,ISA.RVV,CVA6V_0011,5,"Vector Element Index (vid.v), Vector Ioata (viota.m), Vector-Vector Move (vmv.v.v), Vector-Scalar Move (vmv.v.x), Vector-Immediate Move (vmv.v.i), 1 Whole Register Move (vmv1r.v), 2 Whole Register Move (vmv2r.v), 4 Whole Register Move (vmv4r.v), 8 Whole Register Move (vmv8r.v), Vector-Scalar Move SEW-wide (vmv.x.s), Vector Scalar Integer Register Move (vmv.s.x), Vector Sign Extend SEW/2 (vsext.vf2), Vector Sign Extend SEW/4 (vsext.vf4), Vector Zero Extend SEW/2 (vzext.vf2), Vector Zero Extend SEW/4 (vzext.vf4)",Functional Coverage,,Vector,No
,,,,,,,,
,,,,,,,,
,,,,,,,,
cache block clean,ISA.Zicbom,CVA6V_0010,4,"Cache Block Clean (cbo.clean base). A clean operation makes data from store operations performed by the set of coherent agents visible to a set of non-coherent agents at a point common to both sets by performing a write transfer of a copy of a cache block to that point provided a coherent agent performed a store operation that modified the data in the cache block since the previous invalidate, clean, or flush operation on the cache block.",Directed Test,Find test suite or implement,,No
cache block invalidate,ISA.Zicbom,CVA6V_0010,4,Cache Block Invalidate (cbo.inval base). An invalidate operation makes data from store operations performed by a set of non-coherent agents visible to the set of coherent agents at a point common to both sets by deallocating all copies of a cache block from the set of coherent caches up to that point.,Directed Test,Find test suite or implement,,No
cache block flush,ISA.Zicbom,CVA6V_0010,4,Cache Block Flush (cbo.flush base). A flush operation atomically performs a clean operation followed by an invalidate operation.,Directed Test,Find test suite or implement,,No
,,,,,,,,
,,,,,,,,
,,,,,,,,
floating point accrued exceptions (FFLAGS),CSR,CVA6V_000,3,"Generate the following scenario individually and combination of at least 2. NX (Inexact): This bit is set when a floating-point operation produces an inexact result, meaning the result is not exactly representable in the target precision. UF (Underflow): This bit is set when a floating-point operation produces a result that is too small to be represented in the normalized format and is therefore rounded to zero or a denormalized number. OF (Overflow): This bit is set when a floating-point operation produces a result that is too large to be represented in the target format and is therefore rounded to infinity. DZ (Divide by Zero): This bit is set when a floating-point divide operation has a zero divisor and a non-zero dividend, resulting in a signed infinity. NV (Invalid Operation): This bit is set when a floating-point operation has invalid operands, such as performing a square root on a negative number or an addition involving NaNs (Not a Number). ",Functional Coverage,,CSR,No
floating point fixed rounding mode (FRM),CSR,CVA6V_000,3,"Floating Point Rounding Mode. RNE (Round to Nearest, ties to Even): This is the default rounding mode. It rounds to the nearest representable value. If the result is exactly halfway between two representable values, it rounds to the nearest even value. RTZ (Round towards Zero): This mode rounds towards zero, effectively truncating the fractional part. RDN (Round Down, towards -): This mode rounds towards negative infinity. It always rounds down, regardless of the sign of the result. RUP (Round Up, towards +): This mode rounds towards positive infinity. It always rounds up, regardless of the sign of the result. RMM (Round to Nearest, ties to Max Magnitude): This mode rounds to the nearest representable value. If the result is exactly halfway between two representable values, it rounds to the value with the larger magnitude (i.e., away from zero). ",Functional Coverage,,CSR,No
floating point dynamic rounding mode (FRM),CSR,CVA6V_000,3,"FRM can be set to enable dynamic rounding mode, allowing the rounding mode to be specified on a per-instruction basis. This provides flexibility in numerical computations where different operations may require different rounding behaviors. In dynamic rounding mode, the rounding mode is encoded as part of the floating-point instruction, enabling precise control over how each operation rounds its results.",Functional Coverage,,CSR,No
floating point control and status (FCSR),CSR,CVA6V_000,3,"Floating Point Control and Status Register is a composite register that combines the FFLAGS, FRM, and other potential floating-point control fields into a single 32-bit register. This register allows you to efficiently manage both the floating-point exception flags and the rounding mode in a single operation. Verify that FRM and FFLAGS can be set and also read using FCSR register.",Functional Coverage,,CSR,No
ftran (FTRAN),CSR,CVA6V_000,3,Floating Point Custom CSR. FIXME: not enough information can be found.,Functional Coverage,,CSR,No
debug CSR (DCSR),CSR,CVA6V_0015,4,"Verify the following fields in Debug CSR register: Debug Version, Ebreak M-mode, Ebreak S-mode, Ebreak U-mode, Stepping Interrupt Enable, Stop Counters, Stop Timers, Cause, Modify Privilege Enable, Non-Maskable Interrupt Pending, Step and Privilege Level. For details of each field, refer to https://docs.openhwgroup.org/projects/cva6-user-manual/01_cva6_user/CV32A6_Control_Status_Registers.html.",Functional Coverage,,CSR,No
debug PC (DPC),CSR,CVA6V_0015,4,"Debug Program Counter. Upon entry to debug mode, dpc is updated with the virtual address of the next instruction to be executed. When resuming, the harts PC is updated to the virtual address stored in dpc. A debugger may write dpc to change where the hart resumes. Verify all causes of the debug mode entry: Ebreak, Single Step, Halt Request. Note that Trigger Module is not supported in CVA6V.",Functional Coverage,,CSR,No
debug scratch (DSCRATCH[2]),CSR,CVA6V_0015,4,Optional scratch register. A debugger must not write to this register unless hartinfo explicitly mentions it. FIXME: What is to be tested here? Just a plain read or write?,Functional Coverage,,CSR,No
supervisor status (SSTATUS),CSR,CVA6V_006,4,"Verify functionality of each Supervisor Status Register field: UIE (User Interrupt Enable) - Bit 0: Enables or disables interrupts in user mode. SIE (Supervisor Interrupt Enable) - Bit 1: Enables or disables interrupts in supervisor mode. UPIE (User Previous Interrupt Enable)  - Bit 4: The value of UIE before the last exception. SPIE (Supervisor Previous Interrupt Enable) - Bit 5: The value of SIE before the last exception. SPP (Supervisor Previous Privilege) - Bit 8: Indicates the privilege level at which the last exception occurred (0 = user mode,  1 = supervisor mode). FS (Floating-Point Status) - Bits 13-14: Represents the status of the floating-point unit (off, initial, clean, dirty). XS (Extension Status) - Bits 15-16: Represents the status of additional user-mode extensions or coprocessors (off, initial, clean, dirty). SUM (Supervisor User Memory Access) - Bit 18: Controls whether supervisor mode can access user-mode memory. MXR (Make Executable Readable) - Bit 19: Controls whether executable pages are readable. UXL (User XLEN) - Bits 32-33 in RV64: Represents the  effective XLEN for user mode (64). SD (State Dirty) - Bit 63 in RV64: Indicates whether any state in the FS or XS fields is dirty. ",Functional Coverage,,CSR,No
supervisor interrupt enable  (SIE),CSR,CVA6V_006,4,Verify functionality of each Supervisor Interrupt Enable Register field. Bit 1: SSIE (Supervisor Software Interrupt Enable): Controls the enabling of supervisor-level software interrupts. Bit 5: STIE (Supervisor Timer Interrupt Enable): Controls the enabling of supervisor-level timer interrupts. Bit 9: SEIE (Supervisor External Interrupt Enable): Controls the enabling of supervisor-level external interrupts.,Functional Coverage,,CSR,No
supervisor interrupt pending (SIP),CSR,CVA6V_006,4,Verify functionality of each Supervisor Interrupt Pending Register field. Bit 1: SSIP (Supervisor Software Interrupt Pending): Indicates a pending supervisor-level software interrupt. Bit 5: STIP (Supervisor Timer Interrupt Pending): Indicates a pending supervisor-level timer interrupt. Bit 9: SEIP (Supervisor External Interrupt Pending): Indicates a pending supervisor-level external interrupt.,Functional Coverage,,CSR,No
supervisor trap vector (STVEC),CSR,CVA6V_006,4,"Verify functionality of each Supervisor Trap Vector Field. It consists of two main fields: BASE (Bits 2 to XLEN-1): This field contains the base address of the trap handler. MODE (Bits 0 to 1): This field specifies the mode of operation for the trap handler. The MODE field in stvec determines how the trap handler address is calculated: 0 (Direct Mode): In this mode, all traps are handled at the address specified in the BASE field. 1 (Vectored Mode): In this mode, the actual trap handler address is calculated as BASE + 4 *  cause, where cause is the trap cause number. This allows for different entry points for different traps. ",Functional Coverage,,CSR,No
supervisor counter enable (SCOUNTEREN),CSR,CVA6V_006,2,The SCOUNTEREN CSR controls access to various performance counters and timers from supervisor mode. The fields in the register include: CY: Cycle counter. TM: Timer counter. IR: Instruction retired counter. HPM3 to HPM31: Hardware performance monitors 3  through 31.,Functional Coverage,,CSR,No
supervisor scratch (SSCRATCH),CSR,CVA6V_006,4,"Typically, sscratch is used to hold a pointer to the hart-local supervisor context while the hart is executing user code. At the beginning of a trap handler, sscratch is swapped with a user register to provide an initial working register. Verify that the sscratch register can be correctly read and written.",Functional Coverage,,CSR,No
supervisor exception program counter (SEPC),CSR,CVA6V_006,4,"When a trap is taken into S-mode, sepc is written with the virtual address of the instruction that was interrupted or that encountered the exception. Otherwise, sepc is never written by the implementation, though it may be explicitly written by software.",Functional Coverage,,CSR,No
supervisor cause interrupt (SCAUSE),CSR,CVA6V_006,4,Cover each interrupt cause (i.e. bit 63 is set to 0) with the following interrupt code: 1: Supervisor software interrupt 5: Supervisor timer interrupt 9: Supervisor external interrupt,Functional Coverage,,CSR,No
supervisor cause exception (SCAUSE),CSR,CVA6V_006,4,Cover each exception cause (i.e. bit 63 is set to 1) with the following exception code: 0: Instruction address misaligned 1: Instruction access fault 2: Illegal instruction 3: Breakpoint 4: Load address misaligned 5: Load access fault 6: Store/AMO address misaligned 7: Store/AMO access fault 8: Environment call from U-mode 9: Environment call from S-mode 12: Instruction page fault 13: Load page fault 15: Store/AMO page fault,Functional Coverage,,CSR,No
supervsior trap value (STVAL),CSR,CVA6V_006,4,"The meaning of STVAL contents varies based on the type of exception or interrupt that caused the trap: For address-related exceptions, stval holds the faulting address. For certain other exceptions, stval might hold other relevant information (e.g., the instruction that caused an illegal instruction exception). For interrupts, stval is usually zero. Example Values for STVAL: 1. Instruction address misaligned: Holds the address of the instruction that caused the misaligned access. 2. Instruction access fault: Holds the faulting instruction address. 3. Illegal instruction: Holds the instruction that caused the exception. 4. Breakpoint: Holds the address of the breakpoint. 5. Load/store address misaligned: Holds the faulting address for the load or store. 6. operation. 7. Load/store access fault: Holds the faulting address. 8. Page faults: Holds the faulting address for instruction, load, or store page faults.",Functional Coverage,,CSR,No
supervisor address translation and protection (SATP),CSR,CVA6V_006,4,"In RV64, the structure of the satp register depends on the specific virtual memory scheme being used (e.g., SV39, SV48). Below are the general structures for SV39: Bits [63:60]: Mode (should be set to 8 for SV39) Bits [59:44]: ASID (Address Space Identifier) Bits [43:0]: PPN (Physical Page Number)",Directed Test,riscv-mmu test suite,,No
supervisor environment config (SENVCFG),CSR,CVA6V_006,4,"If register field FIOM (Fence of I/O implies Memory) is set to 1 in senvcfg, FENCE instructions executed in U-mode are modified so the requirement to order accesses to device I/O implies also the requirement to order main memory accesses. When bits PI, PO, SI, and SO are set in U- mode when FIOM=1, PR implied, PW impied, SR impied and SW implied are the modified interpretation respectively. Register fied CBZE is always set to 0 since Zicboz extension is not supported. Verify behavior of setting the Cache Block Invalidate instruction Enable (CBIE) field. CBIE enables the execution of the cache block invalidate instruction, CBO.INVAL, in a lowerprivilege mode: 00: The instruction raises an illegal instruction or virtual instruction exception; 01: The instruction is executed and performs a flush operation; 10: Reserved; 11: The instruction is executed and performs an invalidate operation. Verify the behavior of Cache Block Clean and Flush instruction Enable (CBCFE) field. CBCFE enables the execution of the cache block clean instruction, CBO.CLEAN, and the cache block flush instruction, CBO.FLUSH, in a lower privilege mode: 0: The instruction raises an illegal instruction or virtual instruction exception; 1: The instruction is executed.",Directed Test,Find test suite or implement,,No
machine status (MSTATUS) - 63:15,CSR,CVA6V_000,3,"Verify functionality of each Machine Status Register field: SD (Bit 63) - Summary Dirty bit. Indicates that at least one of the writable fields (FS, XS) is dirty. Usage: Simplifies checking whether context-switching needs to save or restore the state of additional processor resources (e.g., floating-point unit). TSR (Bit 22) Trap SRET. If set, attempts to execute the SRET instruction when mstatus.TSR=1 will cause an illegal instruction exception. Usage: Used to trap and handle attempts to return from supervisor mode to user mode. TW (Bit 21) Timeout Wait. If set, WFI instructions will cause an illegal instruction exception. Usage: Used to prevent supervisors from using WFI to avoid handling interrupts. TVM (Bit 20) Trap Virtual Memory. If set, attempts to access the satp CSR in supervisor mode will cause an illegal instruction exception. Usage: Used to prevent supervisor mode from disabling or modifying virtual memory translation. MXR (Bit 19) Make Executable Readable. Allows loads from pages marked executable. Useful for certain operating systems that treat code as read-only data. SUM (Bit 18) Supervisor User Memory  Access. If set, supervisor mode may access user-mode memory. Usage: Controls whether supervisor code can directly access user-mode memory. MPRV (Bit 17) Modify Privilege. If set, load and store memory accesses use mstatus.MPP to determine the effective privilege level. Usage: Used for systems that need to access memory with a different privilege level than the current mode. XS (Bits 16:15) Extension Status. Encodes the status of additional (non-standard) extensions. Usage: Indicates whether the additional state (e.g., for vector or other custom extensions) is clean, dirty, or off.",Functional Coverage,,CSR,No
machine status (MSTATUS) - 14:0,CSR,CVA6V_000,3,Verify functionality of each Machine Status Register field: FS (Bits 14:13) Floating-Point Status. Encodes the status of the floating-point unit. Values: 00: Off (FPU state is clean and not in use) 01: Initial (FPU state is clean and initialized) 10: Clean (FPU state is clean) 11: Dirty (FPU state is dirty and needs to be  saved/restored) Usage: Indicates whether the floating-point unit is in use and whether its state needs to be saved/restored. MPP (Bits 12:11) Machine Previous Privilege mode. Holds the previous privilege mode before an interrupt. Values: 00: User mode 01: Supervisor mode 11:  Machine mode (binary 10 is reserved) Usage: Used to return to the correct privilege level after handling an interrupt. SPP (Bit 8) Supervisor Previous Privilege mode. Holds the previous privilege mode before an interrupt. Values: 0: User mode 1: Supervisor mode Usage: Used to return to the correct privilege level  after handling an interrupt in supervisor mode. MPIE (Bit 7) Machine Previous Interrupt Enable. Holds the value of the MIE bit prior to the last machine-mode interrupt. Usage: Used to restore the interrupt enable state after returning from an interrupt. SPIE (Bit 5) Description: Supervisor Previous Interrupt Enable. Holds the value of the SIE bit prior to the last supervisor-mode interrupt. Usage: Used to restore the interrupt enable state after returning from an interrupt in supervisor mode. UPIE (Bit 4) User Previous Interrupt Enable. Holds the value of the UIE bit prior to the last user-mode interrupt. Usage: Used to restore the interrupt enable state after returning from an interrupt in user mode. MIE (Bit 3) Machine Interrupt Enable. Global interrupt enable bit for machine mode. Usage: Enables or disables all interrupts in machine mode. SIE (Bit 1) Supervisor Interrupt Enable. Global interrupt enable bit for supervisor mode. Usage: Enables or disables all interrupts in supervisor mode. UIE (Bit 0) User Interrupt Enable. Global interrupt enable bit for user mode. Usage: Enables or disables all interrupts in user mode.,Functional Coverage,,CSR,No
machine status high (MSTATUSH),CSR,CVA6V_000,3,"Bits 30:4 of mstatush generally contain the same fields found in bits 62:36 of mstatus for RV64. Fields SD, SXL, and UXL do not exist in mstatush. Verify that MSTATUSH correctly reflects the status from MSTATUS.",Functional Coverage,,CSR,No
machine instruction set architecture (MISA),CSR,CVA6V_000,3,Verify that MISA.MXL field corresponds to 64-bit. Verify that MISA.Extension is expected: Bit 0: A (Atomic) asserted Bit 1: B (Bit Manipulation) negated Bit 2: C (Compressed) asserted bit 3: D (Double-Precision Floating-Point) negated Bit 4: E (RV32E Base ISA) negated Bit 5: F (Single-Precision Floating-Point) asserted Bit 6: G (Reserved) negated Bit 7: H (Hypervisor) negated Bit 8: I (RV32I/64I/128I Base ISA) asserted Bit 9: J (Reserved) negated Bit 10: K (Reserved) negated Bit 11: L (Reserved) negated Bit 12: M (Integer Multiplication and Division) asserted Bit 13: N (User-level interrupts) negated Bit 14: O (Reserved) negated Bit 15: P (Packed-SIMD) negated Bit 16: Q (Quad-Precision Floating-Point) negated Bit 17: R (Reserved) negated Bit 18: S (Supervisor Mode) asserted Bit 19: T (Reserved) negated Bit 20: U (User Mode) asserted Bit 21: V (Vector Extensions) asserted Bit 22: W (Reserved) Bit 23: X (Non-standard Extensions) negated Bit 24: Y (Reserved) Bit 25: Z (Reserved),Directed test,riscv-tests test suite,,No
machine exception delegattion(MEDELEG),CSR,CVA6V_000,3,Verify that exceptions can be delegated to S-mode using MEDELEG.  Bit 0: Instruction address misaligned Bit 1: Instruction access fault Bit 2: Illegal instruction Bit 3: Breakpoint Bit 4: Load address misaligned Bit 5: Load access fault Bit 6: Store/AMO address misaligned Bit 7: Store/AMO access fault Bit 8: Environment call from U-mode Bit 9: Environment call from S-mode Bit 10: Reserved Bit 11: Environment call from M-mode Bit 12: Instruction page fault Bit 13:  Load page fault Bit 14: Reserved Bit 15:  Store/AMO page fault Bit 16-63: Reserved for future standard use.,Functional Coverage,,CSR,No
machine interrupt delegation (MIDELEG),CSR,CVA6V_000,3,Verify that interrupts can be delegated to S-mode using MIDELEG. Bit 0: User software interrupt Bit 1: Supervisor software interrupt Bit 2: Reserved Bit 3: Machine software interrupt Bit 4: User timer interrupt Bit 5: Supervisor timer interrupt Bit 6: Reserved Bit 7: Machine timer interrupt Bit 8: User external interrupt Bit 9: Supervisor external interrupt Bit 10: Reserved Bit 11: Machine external interrupt Bit 12-15: Reserved Bit 16-63: Reserved for future standard use.,Functional Coverage,,CSR,No
machine interrupt enable (MIE),CSR,CVA6V_000,3,Verify each interrupt enable bit in MIE register. Bit 1: Supervisor software interrupt enable (SSIE) Bit 3: Machine software interrupt enable (MSIE) Bit 5: Supervisor timer interrupt enable (STIE) Bit 7: Machine timer interrupt enable (MTIE) Bit 9: Supervisor external interrupt enable (SEIE) Bit 11: Machine external interrupt enable (MEIE),Functional Coverage,,CSR,No
machine trap vector (MTVEC),CSR,CVA6V_000,3,"Verify functionality of each Machine Trap Vector Field. It consists of two main fields: BASE (Bits 2 to XLEN-1): This field contains the base address of the trap handler. MODE (Bits 0 to 1): This field specifies the mode of operation for the trap handler. The MODE field in mtvec determines how the trap handler address is calculated: 0 (Direct Mode): In this mode, all traps are handled at the address specified in the BASE field. 1 (Vectored Mode): In this mode, the actual trap handler address is calculated as BASE + 4 *  cause, where cause is the trap cause number. This allows for different entry points for different traps. ",Functional Coverage,,CSR,No
machine counter enable (MCOUNTEREN),CSR,CVA6V_006,2,The MCOUNTEREN CSR controls access to various performance counters and timers from supervisor mode. The fields in the register include: CY: Cycle counter. TM: Timer counter. IR: Instruction retired counter. HPM3 to HPM31: Hardware performance monitors 3  through 31.,Functional Coverage,,CSR,No
machine scratch (MSCRATCH),CSR,CVA6V_000,3,"Typically, it is used to hold a pointer to a machine-mode hart-local context space and swapped with a user register upon entry to an M-mode trap handler Verify that the sscratch register can be correctly read and written.",Functional Coverage,,CSR,No
machine exception program counter (MEPC),CSR,CVA6V_000,3,"When a trap is taken into M-mode, mepc is written with the virtual address of the instruction that was interrupted or that encountered the exception. Otherwise, mepc is never written by the implementation, though it may be explicitly written by software.",Functional Coverage,,CSR,No
machine cause interrupt (MCAUSE),CSR,CVA6V_000,3,Cover each interrupt cause (i.e. bit 63 is set to 0) with the following interrupt code: 1: Supervisor software interrupt 3: Machine-mode software interrupt 5: supervisor timer interrupt 7: Machine-mode timer interrupt. 9: supervisor external interrupt 11: machine external interrupt.,Functional Coverage,,CSR,No
machine cause exception (MCAUSE),CSR,CVA6V_000,3,Cover each exception cause (i.e. bit 63 is set to 1) with the following exception code: 0: Instruction address misaligned 1: Instruction access fault 2: Illegal instruction 3: Breakpoint 4: Load address misaligned 5: Load access fault 6: Store/AMO address misaligned 7: Store/AMO access fault 8: Environment call from U-mode 9: Environment call from S-mode 11: Environmen call from M-mode 12: Instruction page fault 13: Load page fault 15: Store/AMO page fault,Functional Coverage,,CSR,No
machine trap value (MTVAL),CSR,CVA6V_000,3,"The meaning of MTVAL contents varies based on the type of exception or interrupt that caused the trap. For address-related exceptions (e.g., instruction page faults, load/store page faults), mtval usually contains the faulting address. For illegal instruction traps, mtval  can contain the actual instruction that caused the trap. For other types of exceptions, mtval might not be used, or it might hold zero. ",Functional Coverage,,CSR,No
machine trap value 2 (MTVAL2),CSR,CVA6V_000,3,"By checking the details in both mtval and mtval2, verify that the system correctly handles complex trap scenarios and that the additional context provided by mtval2 is accurate and useful for debugging and exception handling. Create test scenarios that intentionally  cause complex traps requiring mtval2 and check both mtval and mtval2 registers for the expected values. For example, in a multi-level page fault, mtval might hold the initial faulting virtual address, while mtval2 holds an intermediate physical address.",Functional Coverage,,CSR,No
machine interrupt pending (MIP),CSR,CVA6V_007,4,Verify functionality of each Machine Interrupt Pending Register field. Bit 1: SSIP (Supervisor Software Interrupt Pending) Bit 3: MSIP (Machine Software Interrupt Pending) Bit 5: STIP (Supervisor Timer Interrupt Pending) Bit 7: MTIP (Machine Timer Interrupt Pending) Bit 9: SEIP (Supervisor External Interrupt Pending) Bit 11: MEIP (Machine External Interrupt Pending),Functional Coverage,,CSR,No
machine environment config (MENVCFG),CSR,CVA6V_000,3,"If register field FIOM (Fence of I/O implies Memory) is set to 1 in menvcfg, FENCE instructions executed in U-mode or S-mode are modified so the requirement to order accesses to device I/O implies also the requirement to order main memory accesses. When bits PI, PO, SI, and SO are set in U- mode when FIOM=1, PR implied, PW impied, SR impied and SW implied are the modified interpretation respectively. Register fied CBZE is always set to 0 since Zicboz extension is not supported. Verify behavior of setting the Cache Block Invalidate instruction Enable (CBIE) field. CBIE enables the execution of the cache block invalidate instruction, CBO.INVAL, in a lower privilege mode: 00: The instruction raises an illegal instruction or virtual instruction exception; 01: The instruction is executed and performs a flush operation; 10: Reserved; 11: The instruction is executed and performs an invalidate operation. Verify the behavior of Cache Block Clean and Flush instruction Enable (CBCFE) field. CBCFE enables the execution of the cache block clean instruction, CBO.CLEAN, and the cache block flush instruction, CBO.FLUSH, in a lower privilege mode: 0: The instruction raises an illegal instruction or virtual instruction exception; 1: The instruction is executed. Verify that fields STCE and PBMTE are read-only with a value of 0.",Functional Coverage,,CSR,No
machine environment config high (MENVCFGH),CSR,CVA6V_000,3,Register menvcfgh does not exist when XLEN=64. Verify that it returns an exception accessing it.,Functional Coverage,,CSR,No
machine vendor ID (MVENDORID),CSR,CVA6V_000,3,Verify correct value in MVENDORID.,Functional Coverage,,CSR,No
machine arch ID (MARCHID),CSR,CVA6V_000,3,Verify correct value in MARCHID.,Functional Coverage,,CSR,No
machine implementation ID (MIMPID),CSR,CVA6V_000,3,Verify correct value in MIMPID.,Functional Coverage,,CSR,No
machine hart ID (MHARTID),CSR,CVA6V_000,3,Verify correct value in MHARTID.,Functional Coverage,,CSR,No
machine config pointer (MCONFIGPTR),CSR,CVA6V_000,3,"MCONFIGPTR is an MXLEN-bit read-only CSR that holds the physical address of a configuration data structure. Software can traverse this data structure to discover information about the harts, the platform, and their configuration. The pointer alignment in bits must be no smaller than the greatest supported MXLEN: i.e., if the greatest supported MXLEN is 64, then mconfigptr[2:0] must be zero.",Functional Coverage,,CSR,No
machine count inhibit (MCOUNTINHIBIT),CSR,CVA6V_005,2,"MCOUNTINHIBIT controls which of the hardware performance-monitoring counters increment. The settings in this register only control whether the counters increment; their accessibility is not affected by the setting of this register. When the CY, IR, or HPMn bit in the mcountinhibit register is clear, the cycle, instret, or hpmcountern register increments as usual. When the CY, IR, or HPM_n_ bit is set, the corresponding counter does not increment.",Functional Coverage,,CSR,No
machine cycle (MCYCLE),CSR,CVA6V_005,2,MYCYLE is a performance monitoring register that counts the number of clock cycles since the last reset. Verify the it correcly increments per clock and it can be manually set to a pariticular value and increment from that value.,Functional Coverage,,CSR,No
machine cycle high (MCYCLEH),CSR,CVA6V_005,2,Verify that MCYCLEH is equavalent to bits 63 down to 32 of MCYCLE. Writes to MYCYCLEH only modifies the same upper 32-bits.,Functional Coverage,,CSR,No
machine instruction retired (MINSTRET),CSR,CVA6V_005,2,Verify that MINSTRET correctly counts the number of retired instructions. Verify that instructions that cause synchronous exceptions like ECALL and EBREAK do not increment the value in MINSTRET CSR.,Functional Coverage,,CSR,No
machine instruction retired high (MINSTRETH),CSR,CVA6V_005,2,Verify that MINSTRETH is equavalent to bits 63 down to 32 of MINSTRET. Writes to MINSTRETH only modifies the same upper 32-bits.,Functional Coverage,,CSR,No
cycle (CYCLE),CSR,CVA6V_005,2,Verify that CYCLE is a read-only shadow of MCYCLE.,Functional Coverage,,CSR,No
cycle high (CYCLEH),CSR,CVA6V_005,2,Verify that CYCLEH is a read-only shadow of MCYCLEH.,Functional Coverage,,CSR,No
instruction retired (INSTRET),CSR,CVA6V_005,2,Verify that INSTRET is a read-only shadow of MINSTRET.,Functional Coverage,,CSR,No
instruction retired high (INSTRETH),CSR,CVA6V_005,2,Verify that INSTRETH is a read-only shadow of MINSTRETH.,Functional Coverage,,CSR,No
machine high performance monitoring counter  (MHPMCOUNTER3-31),CSR,CVA6V_005,2,"Verify that MHPMCOUNTERn correctly counts the event corresponding to MHPMVENTn. ",Functional Coverage,,CSR,No
machine high performance monitoring event (MHPMEVENT3-31),CSR,CVA6V_005,2,Verify each event setting correspond to the actual scenario/event being counted.,Functional Coverage,,CSR,No
high performance counter (HPMCOUNTER3-31),CSR,CVA6V_005,2,Verify that HPMCOUNTERn is a read-only shadow of MHPMCOUNTERn.,Functional Coverage,,CSR,No
data cache (DCACHE),CSR,CVA6V_001,5,Verify that setting/unsetting of DCACHE CSR enables/disables the data cache.,Functional Coverage,,CSR,No
instruction cache (ICACHE),CSR,CVA6V_001,5,Verify that setting/unsetting of ICACHE CSR enables/disables the instruction cache.,Functional Coverage,,CSR,No
physical memory protection config (PMPCFG0-3),CSR,CVA6V_002,1,"Verify PMPCFG0 and PMPCFG2 for RV64. Since PMP feature is dropped, this will be very low priority/ even NA.",Functional Coverage,,CSR,No
physical memory protection address (PMPADDR0-15),CSR,CVA6V_002,1,"Verify address regions can be set using PMPADDR0 to PMPADDR15. Since PMP feature is dropped, this will be very low priority/ even NA.",Functional Coverage,,CSR,No
unsupported csr,CSR,CVA6V_000,3,"The following registers are not implemented and should result in an exception when accessed: TSELECT, TDATA1-3, VSSTATUS, VSIE, VSIP, VSVTEC, VSSCRATCH, VSEPC, VSCAUSE, VSTVAL, VSATP, HSTATUS, HEDELEG, HIDELEG, HIE, HIP, HVIP, HCOUNTEREN, HTVAL, HTINST, HGEIE, HGEIP, HENVCFG, HGATP, MHPMCOUNTER_3H-31H, HPMCOUNTER_3H-31H",Functional Coverage,,CSR,No
,,,,,,,,
,,,,,,,,
,,,,,,,,
lower level CSR on debug mode,Debug_Mode,CVA6V_015,4,Verify that all CSR can be accessed in debug mode.,Functional Coverage,,CSR,No
entry and exit to and from debug mode,Debug_Mode,CVA6V_015,4,Verify that debug mode can be entered and exited multiple times.,Functional Coverage,,Debug_Mode,No
xdebugver,Debug_Mode,CVA6V_015,4,"Verify whether external debug value is expected. If external debug is supported, verify the specific external debug functionality.",Functional Coverage,,Debug_Mode,No
ebreakm,Debug_Mode,CVA6V_015,4,Verify Environment Breakpoint M-mode. A value of 0 means ebreak instructions in M-mode behave as described in the Privileged Spec. A value of 1 means ebreak instructions in M-mode enter Debug Mode.,Functional Coverage,,Debug_Mode,No
ebreaks,Debug_Mode,CVA6V_015,4,Verify Environment Breakpoint S-mode. A value of 0 means ebreak instructions in S-mode behave as described in the Privileged Spec. A value of 1 means ebreak instructions in S-mode enter Debug Mode.,Functional Coverage,,Debug_Mode,No
ebreaku,Debug_Mode,CVA6V_015,4,Verify Environment Breakpoint U-mode. A value of 0 means ebreak instructions in U-mode behave as described in the Privileged Spec. A value of 1 means ebreak instructions in U-mode enter Debug Mode.,Functional Coverage,,Debug_Mode,No
stepie,Debug_Mode,CVA6V_015,4,Verify Single Stepping Interrupt Enable. A value of 0 means interrupts are disabled during single stepping. A value of 1 means interrupts are enabled during single stepping.,Functional Coverage,,Debug_Mode,No
stopcount,Debug_Mode,CVA6V_015,4,Verify Stop Counters. A value of 0 means counters increment as usual. A value of 1 means any counter while in Debug Mode or on ebreak instructions that cause entry into Debug Mode does not increment.,,,,
stoptime,Debug_Mode,CVA6V_015,4,Verify Stop Timers. A value of 0 means timers increment as usual. A value of 1 means  any hart-local timers  do not increment while in Debug Mode.,Functional Coverage,,Debug_Mode,No
debug cause,Debug_Mode,CVA6V_015,4,"Verify Debug Cause. This field explains why Debug Mode was entered. When there are multiple reasons to enter Debug Mode in a single cycle, hardware sets cause to the cause with the highest priority. A value of 0b001 means an ebreak instruction was executed. (priority 3). A value of 0b010 means the Trigger Module caused a breakpoint exception. (priority 4, highest, but should not happen since it is not supported). A value of 0b011 maens the debugger requested entry to Debug Mode using haltreq. (priority 1). A value of 0b100 means the hart single stepped because step was set. (priority 0, lowest). A value of 0b101 means the hart halted directly out of reset due to resethaltreq. It is also acceptable to report a value of 0b011 when this happens. (priority 2).",Functional Coverage,,Debug_Mode,No
mprven,Debug_Mode,CVA6V_015,4,Verify Debug Modify Privilege Enable. This field enables/disables the modify privilege setting in debug mode. A value of 0 means MPRV in mstatus is ignored in Debug Mode. A value of 1 means MPRV in mstatus takes effect in Debug Mode.,Functional Coverage,,Debug_Mode,No
nmip,Debug_Mode,CVA6V_015,4,"Non-Maskable Interrupt Pending. Since NMI is not supported, verify that this is read always with a 0.",Functional Coverage,,Debug_Mode,No
debug step,Debug_Mode,CVA6V_015,4,"Verify Debug Step. When set and not in Debug Mode, the hart will only execute a single instruction and then enter Debug Mode. If the instruction does not complete due to an exception, the hart will immediately enter Debug Mode before executing the trap handler, with appropriate exception registers set. The debugger must not change the value of this bit while the hart is running.",Functional Coverage,,Debug_Mode,No
debug privilege,Debug_Mode,CVA6V_015,4,Verify Debug Privilege. This field contains the privilege level the hart was operating in when Debug Mode was entered. A debugger can change this value to change the harts privilege level when exiting Debug Mode.,Functional Coverage,,Debug_Mode,No
,,,,,,,,
,,,,,,,,
,,,,,,,,
raptor offloading and execution,CVA6V_Specific,CVA6V_011,5,Verify that vector instructions can be offloaded to Raptor speculatively. Also verify that actual computation and execution only happens non-speculatively.,Assertion,,,No
cva6 retirement during raptor busy,CVA6V_Specific,CVA6V_011,5,"Because the vector register file (VRF) is part of Raptor and not directly accessible by CVA6, almost all instructions can be retired by CVA6 once they are not speculative anymore, even though the final result is not yet ready. Verify that CVA6 core retires instruction while Raptor is still executing the same instruction.",Function Coverage,,Instruction_Timing,No
cva6 and raptor concurrency,CVA6V_Specific,CVA6V_011,5,Verify that scalar and vector transactions can be executed concurrently.,Function Coverage,,Instruction_Timing,No
raptor access to L1 memory,CVA6V_Specific,CVA6V_011,5,Verify that Raptor can access all the banks of L1 memory region,Function Coverage,,Memory_Access,No
raptor access to DCache,CVA6V_Specific,CVA6V_011,5,Verify that Raptor can access CVA6's Data Cache.,Function Coverage,,Memory_Access,No
boot address,CVA6V_Specific,CVA6V_011,5,Verify different input boot addresses.,Directed Test,cva6v_boot_addr_test,,No
hart id,CVA6V_Specific,CVA6V_011,3,Verify  different hart ID's and check that is is reflected into the CSR.,Directed Test,cva6v_hart_id_test,,No
L1 memory region input enable,CVA6V_Specific,CVA6V_011,5,Verify that L1 regions can be set using memreg_tcdm_i input.,Directed Test,cva6v_l1_tcdm_test,,No
interrupt sources,CVA6V_Specific,CVA6V_007,4,"Issue interrupt from various sources: irq_i[1:0]: interrupt lines [sip, mip] ipi_i: inter processor interrupt,  time_irq_i: timer interrupt, platform_irq_i[]: platform interrupt, debug_req_i: debug request interrupt,  debug_rst_halt_req_i: halt the core on reset",Directed Test,cva6v_irq_test,,No
debug stop time output,CVA6V_Specific,CVA6V_015,4,debug_stop_time_o: stop the external timer in debug mode. FIXME! Functionality not clear.,Directed Test,cva6v_debug_time_test,,No
hart status,CVA6V_Specific,CVA6V_011,3,"Verify the following output signals: hart_is_wfi_o: hart is waiting for interrupt, hart_unavail_o: hart is unavailable, hart_under_reset_o: hart is undergoing reset",Assertion,,,No
AXI protocol,CVA6V_Specific,CVA6V_011,3,Verify that CVA6V conforms to the AXI protocol as an AXI 4 Master.,AXI VIP Monitor Check,,,No
TCDM /L1 Memory Ports,CVA6V_Specific,CVA6V_011,5,Verify that the memory transcations through mem_req and mem_resp ports are consistent with the sparse memory model at the end of the simulation.,Memory/Scoreboard Check,,,No
Monitoring Signals,CVA6V_Specific,CVA6V_011,2,"Verify that the following monitoring signals are at least toggling (if not functionally tested): perf_cntr_fu_status_o: Status of Raptor's functional units, perf_cntr_dispatch_queue_full_o: Bit indicating whether Raptor's dispatch queue is full, perf_cntr_dispatch_queue_empty_o: Bit indicating whether Raptor's dispatch queue is empty, perf_cntr_commit_queue_full_o: Bit indicating whether Raptor's commit queue is full, perf_cntr_commit_queue_empty_o: Bit indicating whether Raptor's commit , queue is empty",Toggle Code Coverage,,,No
Tracing Probes,CVA6V_Specific,CVA6V_016,4,Verify CVA6 and Raptor trace signals. This is implicitly verified via RVVI.,Functional Coverage,,All instruction related covergroups,No
,,,,,,,,
,,,,,,,,
,,,,,,,,
scalar data hazards,Scenario,CVA6V_003,5,"RAW Hazard, WAR Hazard, WAW Hazard",Functional Coverage,,Pipeline,No
vector data hazards,Scenario,CVA6V_011,5,"RAW Hazard, WAR Hazard, WAW Hazard",Functional Coverage,,Pipeline,No
control hazards,Scenario,CVA6V_003,5,"These are some enumerated ways to introduce control hazard:  1. Write a program with several branch instructions, some taken and some not taken. 2. Use a sequence of branches with predictable patterns (e.g., alternating taken and not taken). 3. Introduce branches that are intentionally mispredicted. 4. Implement speculative execution paths with branches that might or might not be taken.",Functional Coverage,,Pipeline,No
structural hazards,Scenario,CVA6V_003,5,"Structural hazard can be introduced using the following: 1. Shared Functional Units: If multiple instructions need to use a single functional unit (e.g., an ALU, multiplier, or divider) at the same time. 2. Memory Access: When multiple instructions require access to the memory system (instruction fetch, data read/write) simultaneously and there are not enough memory ports. 3. Register File Access: When multiple instructions need to read from or write to the register file at the same time and the register file cannot handle multiple accesses.",Functional Coverage,,Pipeline,No
forwarding,Scenario,CVA6V_003,5,"Forwarding, also known as data bypassing, is a technique to resolve data hazards by directly passing the result of an instruction to subsequent instructions that need it, without waiting for the result to be written back to the register file. When an instruction produces a result, this result is forwarded directly to a later instruction that needs it, bypassing the need to wait for the result to go through the normal pipeline stages.",Functional Coverage,,Pipeline,No
stalling,Scenario,CVA6V_003,5,"Stalling is a technique used to handle data hazards by pausing the pipeline until the necessary data is available. This involves inserting ""bubble"" cycles (no-operation instructions) into the pipeline to delay subsequent instructions.",Functional Coverage,,Pipeline,No
aligned /misaligned accesses,Scenario,CVA6V_003,5,Perform load and stores from and to memory using aligned and misaligned addresses.,Functional Coverage,,Memory,No
nested loops,Scenario,CVA6V_003,5,Perform multiple level of nested loops.,Functional Coverage,,Control Flow,No
nested interrupts,Scenario,CVA6V_007,4,Verify combinations of different interrupt sources and privilege modes.,Functional Coverage,,Interrupt,No
nested exceptions,Scenario,CVA6V_007,4,Verify combinations of different exceptions and privilege modes.,Functional Coverage,,Exceptions,No
cache hit and miss,Scenario,CVA6V_009,4,"Verify that data retrieved from the cache is always correct and consistent with the main memory. Verify the correct implementation of cache replacement policies (e.g., LRU, FIFO, Random). Verify that the system correctly handles cold, conflict, and capacity misses.",Functional Coverage,,Cache,No
return from trap,Scenario,CVA6V_000,3,"Use MRET/SRET instructions. Verify that the m/s/epc register correctly restores the program counter. Check that the m/s/status register correctly restores the processor status, including the interrupt enable bits and previous privilege level. Verify that pending interrupts and exceptions are correctly managed when returning from a trap. ",Functional Coverage,,Privileged_Instructions,No
types of trap,Scenario,CVA6V_000,3,"Generate contained, requested, invisible and fatal traps.",Functional Coverage,,Exceptions,No
hints,Scenario,CVA6V_003,5,Verify that using random hints in between instructions does not alter the state of the processor. CVA6V does not do anything special with HINT instructions.,Functional Coverage,,Hints,No
subnormal arithmetic,Scenario,CVA6V_003,5,"Verify that the FPU correctly represents subnormal numbers. Verify that the FPU correctly performs arithmetic operations involving subnormal numbers, including edge cases. Verify that operations involving small values result in gradual underflow to subnormal numbers  rather than abrupt underflow to zero.",Functional Coverage,,,No
load and stores interchanging increments,Scenario,CVA6V_003,5,"Copy data from one memory location to another using positive/negative/interchanging (+4, -4, +8, -8) increments and different widths",Directed Test,cva6v_asm_ldst_increment_test,,No
load and stores instruction memory access,Scenario,CVA6V_003,5,"Test to read data from instruction memory, different offsets and instructions.",Directed Test,cva6v_asm_ldst_instr_mem_access_test,,No
fpu stall and flush on speculative branches,Scenario,CVA6V_003,5,Exercise stalls / flushes (speculative branches) in between FPU instructions.,Directed Test,cva6v_asm_fpu_flush_and_stall_test,,No
fcsr plus fpu instructions,Scenario,CVA6V_003,5,Combine FCSR access with floating point operations. Test if FPU pipeline is emptied / everything has executed.,Directed Test,cva6v_asm_fpu_fcsr_test,,No
clock gating,Scenario,Extra,3,Verify clock gating by turning on and off the CVA6V clock. The DUT should perform normally upon clock activations.,Directed Test,cva6v_clock_gate_test,,No
random reset,Scenario,Extra,3,Issue reset at random timing and perform recovery instructions.,Directed Test,cva6v_reset_test,,No
