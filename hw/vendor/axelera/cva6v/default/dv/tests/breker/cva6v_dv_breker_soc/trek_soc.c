
/******************************************************************************
 * Embedded SoC C Test generated by TrekSoC-2.1.7
 * Created on Wed Sep 11 15:59:15 2024
 * 
 * File Name: trek_soc.c
 * Generated Seed: 0xff26ca7c
 *******************************************************************************/
#define TREK_PROCESSOR_COUNT 1
#define TREK_MAX_THREADS_PER_PROCESSOR 1

/*-----------------------------------------------------------------------------
 * User Include Files
 *-----------------------------------------------------------------------------*/
// Axelera specific includes to be added here
// #include <xxx.h>
#define NO_HYPERVISOR_EXTENSION


/*-----------------------------------------------------------------------------
 * Include Files
 *-----------------------------------------------------------------------------*/
#include "/apps/eda/breker/trek5-2.1.7-GCC6_el7/target/include/trek_target_common.h"
#include "/apps/eda/breker/trek5-2.1.7-GCC6_el7/opensrc/riscv-src/util/encoding.h"
#include "/apps/eda/breker/trek5-2.1.7-GCC6_el7/target/include/riscv64/trek_target_riscv64.h"

/*-----------------------------------------------------------------------------
 * Global Variables
 *-----------------------------------------------------------------------------*/
unsigned int runtime_init_var = 0;
// memory resource "C2TMBOXES" with 0x10 bytes
#define trek_mem_C2TMBOXES 0x3000000000ULL
// memory resource "T2CMBOXES" with 0x10 bytes
#define trek_mem_T2CMBOXES 0x3000000080ULL
// memory resource "ddr0" with 0x10000 bytes
#define trek_mem_ddr0 0x200000a400ULL

// macro definitions to improve code readability
#define hart0_active_threads (trek_mem_ddr0+0x00000328)
#define hart0_iterations (trek_mem_ddr0+0x00004dbc)
#define runtime_init_done (&runtime_init_var)
#define trek_hart0_T0_state (trek_mem_ddr0+0x00004d88)
#define trek_hart0_state (trek_mem_ddr0+0x0000b178)

/*-----------------------------------------------------------------------------
 * Function Prototypes
 *-----------------------------------------------------------------------------*/
int trek_hart0_main(void);
void trek_initialize_memory_regions(void);


/*-----------------------------------------------------------------------------
 * User Code
 *-----------------------------------------------------------------------------*/

int trek_main(void)
{
  // must enter in M privilege 
  unsigned long mhartid = trek_get_cpuid();
  trek_test_setup();

  int ret = 0;
  switch (mhartid) {
    case 0: { ret = trek_hart0_main(); break; }

    default: { ret = -1; } // should not happen
  }

  trek_test_teardown();
  return ret;
}
// platform specific exit with error code
void shutdown(void);
#undef trek_exit
#define trek_exit(status) shutdown();

// Axelera specific code to be added here
#undef trek_mem_barrier  
#define trek_mem_barrier(addr) asm volatile("fence")

#undef trek_mem_cache_flush
#define trek_mem_cache_flush(addr) trek_mem_barrier(addr)

#undef trek_mem_cache_invd
#define trek_mem_cache_invd(addr) trek_mem_barrier(addr)

#undef trek_t2c_wait
#define trek_t2c_wait(thread_id) 0

#undef trek_t2c_get
#define trek_t2c_get(thread_id) 0

int main(void)
{
  return trek_main();
}

int trek_microloop_write_check8( void * addrs[], unsigned int count, trek_uint8_t pattern){
  unsigned int errorCount = 0;
  trek_uint8_t pattern2 = pattern;
  unsigned int ii;
  for ( ii = 0; ii < count; ++ii){
    trek_write8(pattern2, addrs[ii]);
    ++pattern2;
  }
  pattern2 = pattern;
  for ( ii = 0; ii < count; ++ii){
    if (trek_read8(addrs[ii]) != (pattern2)) {
      ++errorCount;
      trek_runtime_error("trek_microloop_write_check8", addrs[ii], pattern2, trek_read8(addrs[ii]));
    };
    ++pattern2;
  }
  return errorCount;
}

int trek_microloop_write_check16( void * addrs[], unsigned int count, trek_uint16_t pattern){
  unsigned int errorCount = 0;
  trek_uint16_t pattern2 = pattern;
  unsigned int ii;
  for ( ii = 0; ii < count; ++ii){
    trek_write16(pattern2, addrs[ii]);
    ++pattern2;
  }
  pattern2 = pattern;
  for ( ii = 0; ii < count; ++ii){
    if (trek_read16(addrs[ii]) != (pattern2)) {
      ++errorCount;
      trek_runtime_error("trek_microloop_write_check16", addrs[ii], pattern2, trek_read16(addrs[ii]));
    };
    ++pattern2;
  }
  return errorCount;
}

int trek_microloop_write_check32( void * addrs[], unsigned int count, trek_uint32_t pattern){
  unsigned int errorCount = 0;
  trek_uint32_t pattern2 = pattern;
  unsigned int ii;
  for ( ii = 0; ii < count; ++ii){
    trek_write32(pattern2, addrs[ii]);
    ++pattern2;
  }
  pattern2 = pattern;
  for ( ii = 0; ii < count; ++ii){
    if (trek_read32(addrs[ii]) != (pattern2)) {
      ++errorCount;
      trek_runtime_error("trek_microloop_write_check32", addrs[ii], pattern2, trek_read32(addrs[ii]));
    };
    ++pattern2;
  }
  return errorCount;
}

int trek_microloop_write_check64( void * addrs[], unsigned int count, trek_uint64_t pattern){
  unsigned int errorCount = 0;
  trek_uint64_t pattern2 = pattern;
  unsigned int ii;
  for ( ii = 0; ii < count; ++ii){
    trek_write64(pattern2, addrs[ii]);
    ++pattern2;
  }
  pattern2 = pattern;
  for ( ii = 0; ii < count; ++ii){
    if (trek_read64(addrs[ii]) != (pattern2)) {
      ++errorCount;
      trek_runtime_error("trek_microloop_write_check64", addrs[ii], pattern2, trek_read64(addrs[ii]));
    };
    ++pattern2;
  }
  return errorCount;
}

int trek_fakeWr_write_check8( void * addrs[],
									  unsigned int count, trek_uint8_t pattern,
                                      unsigned int fakeCount, trek_uint8_t fakePattern)
{
  int errorCount = 0;
  trek_uint8_t pattern2 = pattern;
  unsigned int ii, jj;
  for ( ii = 0; ii < count; ++ii){
    for ( jj = 0; jj < fakeCount; ++jj){
      trek_write8(fakePattern, addrs[ii]);
	  ++fakePattern;
	}
    trek_write8(pattern2, addrs[ii]);
    ++pattern2;
  }
  pattern2 = pattern;
  for ( ii = 0; ii < count; ++ii){
    if (trek_read8(addrs[ii]) != (pattern2)) {
      ++errorCount;
      trek_runtime_error("trek_microloop_write_check8", addrs[ii], pattern2, trek_read8(addrs[ii]));
    };
    ++pattern2;
  }
  return errorCount;
}

int trek_fakeWr_write_check16( void * addrs[],
									  unsigned int count, trek_uint16_t pattern,
                                      unsigned int fakeCount, trek_uint16_t fakePattern)
{
  int errorCount = 0;
  trek_uint16_t pattern2 = pattern;
  unsigned int ii, jj;
  for ( ii = 0; ii < count; ++ii){
    for ( jj = 0; jj < fakeCount; ++jj){
      trek_write16(fakePattern, addrs[ii]);
	  ++fakePattern;
	}
    trek_write16(pattern2, addrs[ii]);
    ++pattern2;
  }
  pattern2 = pattern;
  for ( ii = 0; ii < count; ++ii){
    if (trek_read16(addrs[ii]) != (pattern2)) {
      ++errorCount;
      trek_runtime_error("trek_microloop_write_check16", addrs[ii], pattern2, trek_read16(addrs[ii]));
    };
    ++pattern2;
  }
  return errorCount;
}

int trek_fakeWr_write_check32( void * addrs[],
									  unsigned int count, trek_uint32_t pattern,
                                      unsigned int fakeCount, trek_uint32_t fakePattern)
{
  int errorCount = 0;
  trek_uint32_t pattern2 = pattern;
  unsigned int ii, jj;
  for ( ii = 0; ii < count; ++ii){
    for ( jj = 0; jj < fakeCount; ++jj){
      trek_write32(fakePattern, addrs[ii]);
	  ++fakePattern;
	}
    trek_write32(pattern2, addrs[ii]);
    ++pattern2;
  }
  pattern2 = pattern;
  for ( ii = 0; ii < count; ++ii){
    if (trek_read32(addrs[ii]) != (pattern2)) {
      ++errorCount;
      trek_runtime_error("trek_microloop_write_check32", addrs[ii], pattern2, trek_read32(addrs[ii]));
    };
    ++pattern2;
  }
  return errorCount;
}

int trek_fakeWr_write_check64( void * addrs[],
									  unsigned int count, trek_uint64_t pattern,
                                      unsigned int fakeCount, trek_uint64_t fakePattern)
{
  int errorCount = 0;
  trek_uint64_t pattern2 = pattern;
  unsigned int ii, jj;
  for ( ii = 0; ii < count; ++ii){
    for ( jj = 0; jj < fakeCount; ++jj){
      trek_write64(fakePattern, addrs[ii]);
	  ++fakePattern;
	}
    trek_write64(pattern2, addrs[ii]);
    ++pattern2;
  }
  pattern2 = pattern;
  for ( ii = 0; ii < count; ++ii){
    if (trek_read64(addrs[ii]) != (pattern2)) {
      ++errorCount;
      trek_runtime_error("trek_microloop_write_check64", addrs[ii], pattern2, trek_read64(addrs[ii]));
    };
    ++pattern2;
  }
  return errorCount;
}

/*! Breker - Begin of generated test */

/*-----------------------------------------------------------------------------
 * Executable Code for Processor hart0
 *-----------------------------------------------------------------------------*/
#undef TREK_PROCESSOR_IDX
#define TREK_PROCESSOR_IDX 0

/* Processor: hart0, Thread: T0 */
#undef TREK_THREAD_ID
#define TREK_THREAD_ID 0

#undef TREK_THREAD_IDX
#define TREK_THREAD_IDX 0

void
trek_hart0_T0(void) {

  switch (trek_read32_shared(trek_hart0_T0_state)) {
  case (0x1): {
    trek_c2t_event(0, 0x2);           // [event:0x2 MAIN]
        /* tbx: trek_message("Thread trek_hart0_T0 started");  */

/***********************************************************************************/
// dekkerOp.3
    trek_c2t_event(0, 0x3);           // [event:0x3 agent:hart0 thread:T0 instance:dekkerOp.3]
        /* tbx: trek_message("Begin dekkerOp.3");  */
    trek_write32(0x9382a547, trek_mem_ddr0+0x0000b184);
    trek_mem_barrier(trek_mem_ddr0+0x0000b184);

    // trek_copy_memory_block(trek_mem_ddr0+0x0000b184, trek_mem_ddr0+0x00004d90, 0x4)
    trek_write32(trek_read32(trek_mem_ddr0+0x0000b184), trek_mem_ddr0+0x00004d90);

    trek_c2t_event(0, 0x4);           // [event:0x4 agent:hart0 thread:T0 instance:dekkerOp.3]
        /* tbx: trek_message("End dekkerOp.3");  */
    trek_write32_shared(0x2, trek_hart0_T0_state);
    break;
  }
  case (0x2): {

/***********************************************************************************/
// dekkerCheck.3
    trek_c2t_event(0, 0x5);           // [event:0x5 agent:hart0 thread:T0 instance:dekkerCheck.3]
        /* tbx: trek_message("Begin dekkerCheck.3");  */
    if (!(!((trek_read32(trek_mem_ddr0+0x00004d90) == 0x6bd0b466)))) {
      trek_c2t_arg(0, 0x0);
      trek_c2t_event(0, 0x6);           // [event:0x6 agent:hart0 thread:T0 instance:dekkerCheck.3]
        /* tbx: trek_verbatim_check ("!((trek_read32(trek_mem_ddr0+0x00004d90) == 0x6bd0b466))")  */
    }
    trek_write32(0x9382a547, trek_mem_ddr0+0x0000b184);
    trek_write32(0x9382a547, trek_mem_ddr0+0x00004d90);
    trek_c2t_event(0, 0x7);           // [event:0x7 agent:hart0 thread:T0 instance:dekkerCheck.3]
        /* tbx: trek_message("End dekkerCheck.3");  */
    trek_write32_shared(0x3, trek_hart0_T0_state);
    break;
  }
  case (0x3): {

/***********************************************************************************/
// dekkerOp.6
    trek_c2t_event(0, 0x8);           // [event:0x8 agent:hart0 thread:T0 instance:dekkerOp.6]
        /* tbx: trek_message("Begin dekkerOp.6");  */
    trek_write16(0xf144, trek_mem_ddr0+0x00004d94);
    trek_mem_barrier(trek_mem_ddr0+0x00004d94);

    // trek_copy_memory_block(trek_mem_ddr0+0x00004d94, trek_mem_ddr0+0x00004d9c, 0x2)
    trek_write16(trek_read16(trek_mem_ddr0+0x00004d94), trek_mem_ddr0+0x00004d9c);

    trek_c2t_event(0, 0x9);           // [event:0x9 agent:hart0 thread:T0 instance:dekkerOp.6]
        /* tbx: trek_message("End dekkerOp.6");  */
    trek_write32_shared(0x4, trek_hart0_T0_state);
    break;
  }
  case (0x4): {

/***********************************************************************************/
// dekkerCheck.6
    trek_c2t_event(0, 0xa);           // [event:0xa agent:hart0 thread:T0 instance:dekkerCheck.6]
        /* tbx: trek_message("Begin dekkerCheck.6");  */
    if (!(!((trek_read16(trek_mem_ddr0+0x00004d9c) == 0x5e1a)))) {
      trek_c2t_arg(0, 0x0);
      trek_c2t_event(0, 0xb);           // [event:0xb agent:hart0 thread:T0 instance:dekkerCheck.6]
        /* tbx: trek_verbatim_check ("!((trek_read16(trek_mem_ddr0+0x00004d9c) == 0x5e1a))")  */
    }
    trek_write16(0xf144, trek_mem_ddr0+0x00004d94);
    trek_write16(0xf144, trek_mem_ddr0+0x00004d9c);
    trek_c2t_event(0, 0xc);           // [event:0xc agent:hart0 thread:T0 instance:dekkerCheck.6]
        /* tbx: trek_message("End dekkerCheck.6");  */
    trek_write32_shared(0x5, trek_hart0_T0_state);
    break;
  }
  case (0x5): {

/***********************************************************************************/
// dekkerOp.4
    trek_c2t_event(0, 0xd);           // [event:0xd agent:hart0 thread:T0 instance:dekkerOp.4]
        /* tbx: trek_message("Begin dekkerOp.4");  */
    trek_write16(0x57de, trek_mem_ddr0+0x000064b0);
    trek_mem_barrier(trek_mem_ddr0+0x000064b0);

    // trek_copy_memory_block(trek_mem_ddr0+0x000064b0, trek_mem_ddr0+0x00006522, 0x2)
    trek_write16(trek_read16(trek_mem_ddr0+0x000064b0), trek_mem_ddr0+0x00006522);

    trek_c2t_event(0, 0xe);           // [event:0xe agent:hart0 thread:T0 instance:dekkerOp.4]
        /* tbx: trek_message("End dekkerOp.4");  */
    trek_write32_shared(0x6, trek_hart0_T0_state);
    break;
  }
  case (0x6): {

/***********************************************************************************/
// dekkerCheck.4
    trek_c2t_event(0, 0xf);           // [event:0xf agent:hart0 thread:T0 instance:dekkerCheck.4]
        /* tbx: trek_message("Begin dekkerCheck.4");  */
    if (!(!((trek_read16(trek_mem_ddr0+0x00006522) == 0x6b86)))) {
      trek_c2t_arg(0, 0x0);
      trek_c2t_event(0, 0x10);          // [event:0x10 agent:hart0 thread:T0 instance:dekkerCheck.4]
        /* tbx: trek_verbatim_check ("!((trek_read16(trek_mem_ddr0+0x00006522) == 0x6b86))")  */
    }
    trek_write16(0x57de, trek_mem_ddr0+0x000064b0);
    trek_write16(0x57de, trek_mem_ddr0+0x00006522);
    trek_c2t_event(0, 0x11);          // [event:0x11 agent:hart0 thread:T0 instance:dekkerCheck.4]
        /* tbx: trek_message("End dekkerCheck.4");  */
    trek_write32_shared(0x7, trek_hart0_T0_state);
    break;
  }
  case (0x7): {

/***********************************************************************************/
// dekkerOp.9
    trek_c2t_event(0, 0x12);          // [event:0x12 agent:hart0 thread:T0 instance:dekkerOp.9]
        /* tbx: trek_message("Begin dekkerOp.9");  */
    trek_write32(0x54c4b501, trek_mem_ddr0+0x00004db4);
    trek_mem_barrier(trek_mem_ddr0+0x00004db4);

    // trek_copy_memory_block(trek_mem_ddr0+0x00004db4, trek_mem_ddr0+0x0000b180, 0x4)
    trek_write32(trek_read32(trek_mem_ddr0+0x00004db4), trek_mem_ddr0+0x0000b180);

    trek_c2t_event(0, 0x13);          // [event:0x13 agent:hart0 thread:T0 instance:dekkerOp.9]
        /* tbx: trek_message("End dekkerOp.9");  */
    trek_write32_shared(0x8, trek_hart0_T0_state);
    break;
  }
  case (0x8): {

/***********************************************************************************/
// dekkerCheck.9
    trek_c2t_event(0, 0x14);          // [event:0x14 agent:hart0 thread:T0 instance:dekkerCheck.9]
        /* tbx: trek_message("Begin dekkerCheck.9");  */
    if (!(!((trek_read32(trek_mem_ddr0+0x0000b180) == 0xcc94b781)))) {
      trek_c2t_arg(0, 0x0);
      trek_c2t_event(0, 0x15);          // [event:0x15 agent:hart0 thread:T0 instance:dekkerCheck.9]
        /* tbx: trek_verbatim_check ("!((trek_read32(trek_mem_ddr0+0x0000b180) == 0xcc94b781))")  */
    }
    trek_write32(0x54c4b501, trek_mem_ddr0+0x00004db4);
    trek_write32(0x54c4b501, trek_mem_ddr0+0x0000b180);
    trek_c2t_event(0, 0x16);          // [event:0x16 agent:hart0 thread:T0 instance:dekkerCheck.9]
        /* tbx: trek_message("End dekkerCheck.9");  */
    trek_write32_shared(0x9, trek_hart0_T0_state);
    break;
  }
  case (0x9): {

/***********************************************************************************/
// dekkerOp.5
    trek_c2t_event(0, 0x17);          // [event:0x17 agent:hart0 thread:T0 instance:dekkerOp.5]
        /* tbx: trek_message("Begin dekkerOp.5");  */
    trek_write32(0xe5528b18, trek_mem_ddr0+0x00004d98);
    trek_mem_barrier(trek_mem_ddr0+0x00004d98);

    // trek_copy_memory_block(trek_mem_ddr0+0x00004d98, trek_mem_ddr0+0x0000651c, 0x4)
    trek_write32(trek_read32(trek_mem_ddr0+0x00004d98), trek_mem_ddr0+0x0000651c);

    trek_c2t_event(0, 0x18);          // [event:0x18 agent:hart0 thread:T0 instance:dekkerOp.5]
        /* tbx: trek_message("End dekkerOp.5");  */
    trek_write32_shared(0xa, trek_hart0_T0_state);
    break;
  }
  case (0xa): {

/***********************************************************************************/
// dekkerCheck.5
    trek_c2t_event(0, 0x19);          // [event:0x19 agent:hart0 thread:T0 instance:dekkerCheck.5]
        /* tbx: trek_message("Begin dekkerCheck.5");  */
    if (!(!((trek_read32(trek_mem_ddr0+0x0000651c) == 0x4ca7f936)))) {
      trek_c2t_arg(0, 0x0);
      trek_c2t_event(0, 0x1a);          // [event:0x1a agent:hart0 thread:T0 instance:dekkerCheck.5]
        /* tbx: trek_verbatim_check ("!((trek_read32(trek_mem_ddr0+0x0000651c) == 0x4ca7f936))")  */
    }
    trek_write32(0xe5528b18, trek_mem_ddr0+0x00004d98);
    trek_write32(0xe5528b18, trek_mem_ddr0+0x0000651c);
    trek_c2t_event(0, 0x1b);          // [event:0x1b agent:hart0 thread:T0 instance:dekkerCheck.5]
        /* tbx: trek_message("End dekkerCheck.5");  */
    trek_write32_shared(0xb, trek_hart0_T0_state);
    break;
  }
  case (0xb): {

/***********************************************************************************/
// dekkerOp.7
    trek_c2t_event(0, 0x1c);          // [event:0x1c agent:hart0 thread:T0 instance:dekkerOp.7]
        /* tbx: trek_message("Begin dekkerOp.7");  */
    trek_write64(0x3b92af150acf669fULL, trek_mem_ddr0+0x00004da0);
    trek_mem_barrier(trek_mem_ddr0+0x00004da0);

    // trek_copy_memory_block(trek_mem_ddr0+0x00004da0, trek_mem_ddr0+0x00004da8, 0x8)
    trek_write64(trek_read64(trek_mem_ddr0+0x00004da0), trek_mem_ddr0+0x00004da8);

    trek_c2t_event(0, 0x1d);          // [event:0x1d agent:hart0 thread:T0 instance:dekkerOp.7]
        /* tbx: trek_message("End dekkerOp.7");  */
    trek_write32_shared(0xc, trek_hart0_T0_state);
    break;
  }
  case (0xc): {

/***********************************************************************************/
// dekkerCheck.7
    trek_c2t_event(0, 0x1e);          // [event:0x1e agent:hart0 thread:T0 instance:dekkerCheck.7]
        /* tbx: trek_message("Begin dekkerCheck.7");  */
    if (!(!((trek_read64(trek_mem_ddr0+0x00004da8) == 0x9f2623cd601b6466ULL)))) {
      trek_c2t_arg(0, 0x0);
      trek_c2t_event(0, 0x1f);          // [event:0x1f agent:hart0 thread:T0 instance:dekkerCheck.7]
        /* tbx: trek_verbatim_check ("!((trek_read64(trek_mem_ddr0+0x00004da8) == 0x9f2623cd601b6466ULL))")  */
    }
    trek_write64(0x3b92af150acf669fULL, trek_mem_ddr0+0x00004da0);
    trek_write64(0x3b92af150acf669fULL, trek_mem_ddr0+0x00004da8);
    trek_c2t_event(0, 0x20);          // [event:0x20 agent:hart0 thread:T0 instance:dekkerCheck.7]
        /* tbx: trek_message("End dekkerCheck.7");  */
    trek_write32_shared(0xd, trek_hart0_T0_state);
    break;
  }
  case (0xd): {

/***********************************************************************************/
// dekkerOp.8
    trek_c2t_event(0, 0x21);          // [event:0x21 agent:hart0 thread:T0 instance:dekkerOp.8]
        /* tbx: trek_message("Begin dekkerOp.8");  */
    trek_write32(0x8c920868, trek_mem_ddr0+0x00004db0);
    trek_mem_barrier(trek_mem_ddr0+0x00004db0);

    // trek_copy_memory_block(trek_mem_ddr0+0x00004db0, trek_mem_ddr0+0x00004d8c, 0x4)
    trek_write32(trek_read32(trek_mem_ddr0+0x00004db0), trek_mem_ddr0+0x00004d8c);

    trek_c2t_event(0, 0x22);          // [event:0x22 agent:hart0 thread:T0 instance:dekkerOp.8]
        /* tbx: trek_message("End dekkerOp.8");  */
    trek_write32_shared(0xe, trek_hart0_T0_state);
    break;
  }
  case (0xe): {

/***********************************************************************************/
// dekkerCheck.8
    trek_c2t_event(0, 0x23);          // [event:0x23 agent:hart0 thread:T0 instance:dekkerCheck.8]
        /* tbx: trek_message("Begin dekkerCheck.8");  */
    if (!(!((trek_read32(trek_mem_ddr0+0x00004d8c) == 0x9e18186)))) {
      trek_c2t_arg(0, 0x0);
      trek_c2t_event(0, 0x24);          // [event:0x24 agent:hart0 thread:T0 instance:dekkerCheck.8]
        /* tbx: trek_verbatim_check ("!((trek_read32(trek_mem_ddr0+0x00004d8c) == 0x9e18186))")  */
    }
    trek_write32(0x8c920868, trek_mem_ddr0+0x00004db0);
    trek_write32(0x8c920868, trek_mem_ddr0+0x00004d8c);
    trek_c2t_event(0, 0x25);          // [event:0x25 agent:hart0 thread:T0 instance:dekkerCheck.8]
        /* tbx: trek_message("End dekkerCheck.8");  */
    trek_write32_shared(0xf, trek_hart0_T0_state);
    break;
  }
  case (0xf): {

/***********************************************************************************/
// dekkerOp.1
    trek_c2t_event(0, 0x26);          // [event:0x26 agent:hart0 thread:T0 instance:dekkerOp.1]
        /* tbx: trek_message("Begin dekkerOp.1");  */
    trek_write8(0xbc, trek_mem_ddr0+0x000064a6);
    trek_mem_barrier(trek_mem_ddr0+0x000064a6);

    // trek_copy_memory_block(trek_mem_ddr0+0x000064a6, trek_mem_ddr0+0x00004d96, 0x1)
    trek_write8(trek_read8(trek_mem_ddr0+0x000064a6), trek_mem_ddr0+0x00004d96);

    trek_c2t_event(0, 0x27);          // [event:0x27 agent:hart0 thread:T0 instance:dekkerOp.1]
        /* tbx: trek_message("End dekkerOp.1");  */
    trek_write32_shared(0x10, trek_hart0_T0_state);
    break;
  }
  case (0x10): {

/***********************************************************************************/
// dekkerCheck.1
    trek_c2t_event(0, 0x28);          // [event:0x28 agent:hart0 thread:T0 instance:dekkerCheck.1]
        /* tbx: trek_message("Begin dekkerCheck.1");  */
    if (!(!((trek_read8(trek_mem_ddr0+0x00004d96) == 0x52)))) {
      trek_c2t_arg(0, 0x0);
      trek_c2t_event(0, 0x29);          // [event:0x29 agent:hart0 thread:T0 instance:dekkerCheck.1]
        /* tbx: trek_verbatim_check ("!((trek_read8(trek_mem_ddr0+0x00004d96) == 0x52))")  */
    }
    trek_write8(0xbc, trek_mem_ddr0+0x000064a6);
    trek_write8(0xbc, trek_mem_ddr0+0x00004d96);
    trek_c2t_event(0, 0x2a);          // [event:0x2a agent:hart0 thread:T0 instance:dekkerCheck.1]
        /* tbx: trek_message("End dekkerCheck.1");  */
    trek_write32_shared(0x11, trek_hart0_T0_state);
    break;
  }
  case (0x11): {

/***********************************************************************************/
// dekkerOp.10
    trek_c2t_event(0, 0x2b);          // [event:0x2b agent:hart0 thread:T0 instance:dekkerOp.10]
        /* tbx: trek_message("Begin dekkerOp.10");  */
    trek_write32(0x08c3bfc0, trek_mem_ddr0+0x0000b17c);
    trek_mem_barrier(trek_mem_ddr0+0x0000b17c);

    // trek_copy_memory_block(trek_mem_ddr0+0x0000b17c, trek_mem_ddr0+0x00004db8, 0x4)
    trek_write32(trek_read32(trek_mem_ddr0+0x0000b17c), trek_mem_ddr0+0x00004db8);

    trek_c2t_event(0, 0x2c);          // [event:0x2c agent:hart0 thread:T0 instance:dekkerOp.10]
        /* tbx: trek_message("End dekkerOp.10");  */
    trek_write32_shared(0x12, trek_hart0_T0_state);
    break;
  }
  case (0x12): {

/***********************************************************************************/
// dekkerCheck.10
    trek_c2t_event(0, 0x2d);          // [event:0x2d agent:hart0 thread:T0 instance:dekkerCheck.10]
        /* tbx: trek_message("Begin dekkerCheck.10");  */
    if (!(!((trek_read32(trek_mem_ddr0+0x00004db8) == 0x4c197a49)))) {
      trek_c2t_arg(0, 0x0);
      trek_c2t_event(0, 0x2e);          // [event:0x2e agent:hart0 thread:T0 instance:dekkerCheck.10]
        /* tbx: trek_verbatim_check ("!((trek_read32(trek_mem_ddr0+0x00004db8) == 0x4c197a49))")  */
    }
    trek_write32(0x08c3bfc0, trek_mem_ddr0+0x0000b17c);
    trek_write32(0x08c3bfc0, trek_mem_ddr0+0x00004db8);
    trek_c2t_event(0, 0x2f);          // [event:0x2f agent:hart0 thread:T0 instance:dekkerCheck.10]
        /* tbx: trek_message("End dekkerCheck.10");  */
    trek_write32_shared(0x13, trek_hart0_T0_state);
    break;
  }
  case (0x13): {

/***********************************************************************************/
// dekkerOp.2
    trek_c2t_event(0, 0x30);          // [event:0x30 agent:hart0 thread:T0 instance:dekkerOp.2]
        /* tbx: trek_message("Begin dekkerOp.2");  */
    trek_write64(0x6deaf029b8719bb7ULL, trek_mem_ddr0+0x00006498);
    trek_mem_barrier(trek_mem_ddr0+0x00006498);

    // trek_copy_memory_block(trek_mem_ddr0+0x00006498, trek_mem_ddr0+0x000064a8, 0x8)
    trek_write64(trek_read64(trek_mem_ddr0+0x00006498), trek_mem_ddr0+0x000064a8);

    trek_c2t_event(0, 0x31);          // [event:0x31 agent:hart0 thread:T0 instance:dekkerOp.2]
        /* tbx: trek_message("End dekkerOp.2");  */
    trek_write32_shared(0x14, trek_hart0_T0_state);
    break;
  }
  case (0x14): {

/***********************************************************************************/
// dekkerCheck.2
    trek_c2t_event(0, 0x32);          // [event:0x32 agent:hart0 thread:T0 instance:dekkerCheck.2]
        /* tbx: trek_message("Begin dekkerCheck.2");  */
    if (!(!((trek_read64(trek_mem_ddr0+0x000064a8) == 0x9e9b1f2d8199c336ULL)))) {
      trek_c2t_arg(0, 0x0);
      trek_c2t_event(0, 0x33);          // [event:0x33 agent:hart0 thread:T0 instance:dekkerCheck.2]
        /* tbx: trek_verbatim_check ("!((trek_read64(trek_mem_ddr0+0x000064a8) == 0x9e9b1f2d8199c336ULL))")  */
    }
    trek_write64(0x6deaf029b8719bb7ULL, trek_mem_ddr0+0x00006498);
    trek_write64(0x6deaf029b8719bb7ULL, trek_mem_ddr0+0x000064a8);
    trek_c2t_event(0, 0x34);          // [event:0x34 agent:hart0 thread:T0 instance:dekkerCheck.2]
        /* tbx: trek_message("End dekkerCheck.2");  */
    trek_write32_shared(0x15, trek_hart0_T0_state);
    break;
  }
  case (0x15): {
    trek_c2t_event(0, 0x35);          // [event:0x35 MAIN]
        /* tbx: trek_message("Thread trek_hart0_T0 completed");  */
    (trek_read32(hart0_active_threads))--;
    trek_write32_shared(0x16, trek_hart0_T0_state);
    break;
  }
  default:
    if (trek_read32_shared(trek_hart0_T0_state) != 0x16) {
      trek_c2t_event(0, 0x36);        // [event:0x36 MAIN]
        /* tbx: trek_message("bad value in variable trek_hart0_T0_state");  */
    }
    break;
  }
}

void
trek_hart0_reset(void) {
  // active thread and thread state variables
  trek_write32(0x1, hart0_active_threads);
  trek_write32_shared(0x01, trek_hart0_T0_state);
}

void
trek_hart0_run_states(void) {
  switch (trek_read32_shared(trek_hart0_state)) {
  case (0x1): {
    // initialization
    trek_write32_shared(0x2, trek_hart0_state);
  }
  case (0x2): {
    trek_write32_shared((trek_read32_shared(hart0_iterations) + 0x01), hart0_iterations);
    trek_write32_shared(0x3, trek_hart0_state);
  }
  case (0x3): {
    trek_c2t_event(0, 0x37);          // [event:0x37 MAIN]
        /* tbx: **** Start of Processor hart0 Iteration ****  */
    trek_write32_shared(0x4, trek_hart0_state);
  }
  case (0x4): {
    // Run threads
    trek_hart0_T0();
    if (trek_read32(hart0_active_threads)) break;

    trek_c2t_event(0, 0x38);          // [event:0x38 MAIN]
        /* tbx: trek_message("Processor hart0 iteration done");  */
    trek_write32_shared(0x5, trek_hart0_state);
  }
  case (0x5): {
    if (trek_read32_shared(hart0_iterations) < 0x1) {
      // reset thread variables
      trek_hart0_reset();
      trek_write32_shared(0x2, trek_hart0_state);
      break;
    }

    trek_write32_shared(0x6, trek_hart0_state);
    break;
  }
  default:
    if (trek_read32_shared(trek_hart0_state) != 0x6) {
      trek_c2t_event(0, 0x39);        // [event:0x39 MAIN]
        /* tbx: trek_message("bad value in variable trek_hart0_state");  */
    }
    break;
  }
}

int
trek_hart0_main(void) {
  if (trek_read32_shared(runtime_init_done) != 0x0DEFEC75) {
    trek_initialize_memory_regions();
    trek_write32_shared(0x0DEFEC75, runtime_init_done);
  }

  while (trek_read32_shared(trek_hart0_state) < 0x6) {
    trek_hart0_run_states();
  }

  // reset init_done flag
  trek_write32_shared(0x0, runtime_init_done);

  trek_c2t_event(0, 0x3a);            // [event:0x3a MAIN]
        /* tbx: Get test status  */
  while (trek_t2c_wait(0))
    ;
  return (trek_t2c_get(0));
}
/*! Breker - End of generated test */


// Init hash function
void
trek_initialize_memory (trek_uint8_t* base, trek_uint64_t from_offset, trek_uint64_t to_offset) {
  trek_uint64_t offset_i = from_offset;
  while (offset_i < to_offset) {
    trek_uint64_t value = (offset_i * 0x7cc7293cbd7291a6ULL) ^ 0x7cc7293cbd7291a6ULL;
    trek_write64(value, base + offset_i);
    offset_i += 8;  // next 8 bytes
  }
}


// memory regions initialization
void
trek_initialize_memory_regions(void) {
  trek_write64(0x0ULL, (trek_uint8_t*)trek_mem_C2TMBOXES+0x00000000);  // constant
  trek_write64(0x0ULL, (trek_uint8_t*)trek_mem_C2TMBOXES+0x00000008);  // constant
  trek_write64(0x0ULL, (trek_uint8_t*)trek_mem_T2CMBOXES+0x00000000);  // constant
  trek_write64(0x0ULL, (trek_uint8_t*)trek_mem_T2CMBOXES+0x00000008);  // constant
  // memory region trek_mem_ddr0
  trek_initialize_memory((trek_uint8_t*)trek_mem_ddr0, 0x320, 0x330);
  trek_initialize_memory((trek_uint8_t*)trek_mem_ddr0, 0x4d80, 0x4dc0);
  trek_initialize_memory((trek_uint8_t*)trek_mem_ddr0, 0x6490, 0x64c0);
  trek_initialize_memory((trek_uint8_t*)trek_mem_ddr0, 0x6510, 0x6530);
  trek_initialize_memory((trek_uint8_t*)trek_mem_ddr0, 0xb170, 0xb190);
  // initialize variables
  trek_write32(0x1, (trek_uint8_t*)trek_mem_ddr0+0x00000328 );  // hart0_active_threads
  trek_write32(0x1, (trek_uint8_t*)trek_mem_ddr0+0x00004d88 );  // trek_hart0_T0_state
  trek_write32(0x0, (trek_uint8_t*)trek_mem_ddr0+0x00004dbc );  // hart0_iterations
  trek_write32(0x1, (trek_uint8_t*)trek_mem_ddr0+0x0000b178 );  // trek_hart0_state
  trek_mem_barrier(0);
}


#include "/apps/eda/breker/trek5-2.1.7-GCC6_el7/target/src/trek_target_common.c"
#include "/apps/eda/breker/trek5-2.1.7-GCC6_el7/target/src/riscv64/trek_target_riscv64.c"
