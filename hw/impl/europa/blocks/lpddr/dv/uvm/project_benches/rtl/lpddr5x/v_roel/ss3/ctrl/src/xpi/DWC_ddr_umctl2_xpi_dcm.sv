// ------------------------------------------------------------------------------
// 
// Copyright 2024 Synopsys, INC.
// 
// This Synopsys IP and all associated documentation are proprietary to
// Synopsys, Inc. and may only be used pursuant to the terms and conditions of a
// written license agreement with Synopsys, Inc. All other use, reproduction,
// modification, or distribution of the Synopsys IP or the associated
// documentation is strictly prohibited.
// Inclusivity & Diversity - Visit SolvNetPlus to read the "Synopsys Statement on
//            Inclusivity and Diversity" (Refer to article 000036315 at
//                        https://solvnetplus.synopsys.com)
// 
// Component Name   : DWC_ddrctl_lpddr54
// Component Version: 1.60a-lca00
// Release Type     : LCA
// Build ID         : 43.27.35.4.TreMctl_163.DwsDdrChip_8.14.6.DwsDdrctlTop_5.9.7
// ------------------------------------------------------------------------------

// -------------------------------------------------------------------------
// -- Revision: $Id: //dwh/ddr_iip/umctl5/DWC_ddrctl_lpddr54_MAIN_BR/DWC_ddr_umctl5/src/xpi/DWC_ddr_umctl2_xpi_dcm.sv#4 $
// -------------------------------------------------------------------------
// Description:
/******************************************************************************
 *                                                                            *
 *              Dynamic Channel Mapper                                        *
 *              Maps IDs to virtual channels dynamically                      *
 *                                                                            *
 *****************************************************************************/
`include "DWC_ddrctl_all_defs.svh"
module DWC_ddr_umctl2_xpi_dcm
  #(parameter NTOKENS        = 32,
    parameter NTOKENS_LG2    = `UMCTL_LOG2(NTOKENS),
    parameter AXI_IDW        = 8,  // AXI ID width
    parameter AXI_MAXSIZE    = 5,
    parameter USE_BAM        = 0,
    parameter NUM_VIR_CH     = 16,
    parameter NUM_VIR_CH_LG2 = `UMCTL_LOG2(NUM_VIR_CH),
    parameter RRB_THRESHOLD_EN       = 0,
    parameter NTOKENS_SBAM       = 32,
    parameter NTOKENS_LG2_SBAM   = `UMCTL_LOG2(NTOKENS_SBAM),
    parameter READ_DATA_INTERLEAVE_EN = 1,
    parameter USE2RAQ        = 0,
    parameter NBEATS         = 1,
    parameter OCCAP_EN       = 0,
    parameter OCCAP_PIPELINE_EN = 0
    )
  
                               (
   input                                clk,           // clock
   input                                rst_n,         // asynchronous reset
   input                                wr,            // push a new ID, token,generate a new token
   input  [NTOKENS_LG2-1:0]             token,         // token generated by Token Manager
   input                                dch,
   input                                release_token, // token is released by RRB
   input  [NTOKENS_LG2-1:0]             rtoken ,       // the released token
   input [AXI_IDW-1:0]                  arid,          // AXI Address Read ID
   input                                red_queue,
   input [NUM_VIR_CH-1:0]               vtq_empty,
   input                                reg_ddrc_occap_en,

//spyglass disable_block W240
//SMD: Inputs declared but not read
//SJ: Used in generate block.
   // Use SBAM (Simplified BAM) for RRB enhancement
   input [NTOKENS_LG2_SBAM:0]           sbam_tokens_allocated,
   input                                sbam_lead_burst,
   input                                sbam_second_burst,
//spyglass enable_block W240

//spyglass disable_block W240
//SMD: Input declared but not read
//SJ: Used in generate block, read only in applicable configurations  
   input  [AXI_MAXSIZE-1:0]             bam_addr_offset,
   input                                bam_lead_burst,
   input                                bam_arlast,
   input                                split,
//spyglass enable_block W240   
   output [NUM_VIR_CH_LG2-1:0]          channel,       // token generated by Token Manager
   output [NTOKENS_LG2-1:0]             dcm_token,         // token generated by Token Manager
   output                               dcm_dch,
   output                               empty,
//spyglass disable_block W241
//SMD: Output 'dcm_bam_addr_offset[3:0]' is never set
//SJ: Used in genarate block.
   output [NTOKENS_LG2_SBAM:0]          dcm_sbam_tokens_allocated,
   output                               dcm_sbam_lead_burst,
   output                               dcm_sbam_second_burst,
//spyglass enable_block W241

//spyglass disable_block W241
//SMD: Output 'dcm_bam_addr_offset[3:0]' is never set
//SJ: Used in genarate block.
   output [AXI_MAXSIZE-1:0]             dcm_bam_addr_offset,
   output                               dcm_bam_lead_burst,
   output                               dcm_bam_arlast,
   output                               dcm_bam_red_token,
//spyglass enable_block W241
   // last token received per channel information given to xpi_tm
   output [NUM_VIR_CH-1:0]              ch_arlast_received,
   output                               occap_xpi_dcm_par_err
   );

   localparam TOKEN_T_WIDTH   = AXI_IDW+NUM_VIR_CH_LG2+1;
   localparam TOKEN_CH_WIDTH  = NUM_VIR_CH_LG2+AXI_IDW;

    localparam OCCAP_CTRLW = 
                            NUM_VIR_CH_LG2 + // rotate_channel 
                            NUM_VIR_CH +     // booked_channel_table
                            1 +              // empty_reg
                            NUM_VIR_CH_LG2 + // chanel_reg
                            1 +              // first_id
                            1;               // first_id_red
   localparam SL_W = 8;
   localparam PARW = ((OCCAP_CTRLW%SL_W>0) ? OCCAP_CTRLW/SL_W+1 : OCCAP_CTRLW/SL_W);
   localparam OCRSIZE =  (RRB_THRESHOLD_EN ? (1 + 1 + NTOKENS_LG2_SBAM + 1) : (USE_BAM ? (1+AXI_MAXSIZE) : 0 )) + NUM_VIR_CH_LG2+NTOKENS_LG2+1+1+1+1;


  wire [AXI_IDW-1:0]                    id_table_reg[0:NTOKENS-1];
  wire [AXI_IDW-1:0]                    id_table_reg_next[0:NTOKENS-1];
  wire [NUM_VIR_CH_LG2-1:0]             channel_table_reg[0:NTOKENS-1];
  wire [NUM_VIR_CH_LG2-1:0]             channel_table_reg_next[0:NTOKENS-1];
  wire [NTOKENS-1:0]                    used_token_table;
  wire [NTOKENS-1:0]                    used_token_table_next;

  reg [NTOKENS_LG2-1:0]                 id_index;
  reg                                   id_found;

  wire                                  fcr_wr;
  wire                                  fcr_rd;
  wire                                  fcr_empty;
  wire                                  fcr_full;
  wire [NUM_VIR_CH_LG2-1:0]             fcr_channel;

  wire                                  ocr_wr;
  wire                                  ocr_rd;
  wire                                  ocr_full;
  wire                                  ocr_empty;
  wire [NUM_VIR_CH_LG2-1:0]             channel_ocr;  
  
  wire [NUM_VIR_CH_LG2-1:0]             new_channel;
  reg [NUM_VIR_CH_LG2-1:0]              rotate_channel;
  reg [NUM_VIR_CH_LG2-1:0]              rotate_channel_nxt;

  wire [NUM_VIR_CH_LG2-1:0]             last_mapped_channel, last_mapped_channel_next;
  wire [AXI_IDW-1:0]                    last_mapped_id, last_mapped_id_next;
  wire                                  blue_last_token_received_r, red_last_token_received_r;
  reg                                   blue_last_token_received_nxt, red_last_token_received_nxt;

  wire [NUM_VIR_CH_LG2-1:0]             last_mapped_channel_red, last_mapped_channel_red_next;
  wire [AXI_IDW-1:0]                    last_mapped_id_red, last_mapped_id_red_next;

  reg [NUM_VIR_CH-1:0]                  booked_channel_table;
  reg [NUM_VIR_CH-1:0]                  booked_channel_table_nxt;
  reg                                   empty_reg; 
  reg [NUM_VIR_CH_LG2-1:0]              channel_reg; 
  reg [NUM_VIR_CH_LG2-1:0]              free_channel;
  reg                                   free_channel_found;

  reg                                   first_id; 
  reg                                   first_id_nxt; 
  reg                                   first_id_red; 
  reg                                   first_id_red_nxt;

  wire                                  arid_same_as_previous;
  wire                                  arid_same_as_previous_red;
  wire                                  reuse_channel; 

  wire                                  occap_fcr_par_err, occap_ocr_par_err;

  wire [NTOKENS-1:0]                    token_table_par_err;

  wire [TOKEN_CH_WIDTH-1:0]             channel_blue_in, channel_blue_out, channel_red_in, channel_red_out;
  wire                                  channel_blue_set, channel_red_set;
  wire                                  channel_blue_par_err, channel_red_par_err;
  wire                                  occap_xpi_dcm_ctrl_par_err;
  wire [OCRSIZE-1:0]                    ocr_d,ocr_q; 
  logic [NUM_VIR_CH-1:0]                ch_arlast_received_nxt;
  wire [NUM_VIR_CH-1:0]                 ch_arlast_received_reg;
  logic [NUM_VIR_CH-1:0]                ch_assigned;
  wire [NUM_VIR_CH-1:0]                 vtq_empty_reg;
  wire                                  arlast_token_rx_par_err;
  wire                                  vtq_empty_reg_par_err;
  logic                                 ocr_split;
  logic [AXI_IDW-1:0]                   arid_r;          // AXI Address Read ID
  logic [NTOKENS_LG2-1:0]               rtoken_r;        // the released token
  logic                                 release_token_r; // token is released by RRB

  integer i; // for loop index
  genvar gv;

  assign empty = ocr_empty;

  assign occap_xpi_dcm_par_err = occap_fcr_par_err | occap_ocr_par_err | (|token_table_par_err) | channel_blue_par_err | channel_red_par_err |
                                 occap_xpi_dcm_ctrl_par_err | arlast_token_rx_par_err | vtq_empty_reg_par_err;

  // If the expansion (xpi_rp) of an AXI burst is on progress and all read data of the outstanding HIF BLs is drained from RRB, 
  // then arid_same_as_previous selector is used to prevent assigning a new channel to the same ID.
  // xpi_df requires that same beats of the same AXI burst are mapped to the same channel.
  assign arid_same_as_previous = ((last_mapped_id_next==arid) & ~blue_last_token_received_nxt) ?~first_id:1'b0;
  assign arid_same_as_previous_red = ((last_mapped_id_red_next==arid) & ~red_last_token_received_nxt) ?~first_id_red:1'b0;
  
  assign reuse_channel = arid_same_as_previous | arid_same_as_previous_red | id_found;
  
  assign channel_ocr = arid_same_as_previous ? last_mapped_channel_next :
                       arid_same_as_previous_red ? last_mapped_channel_red_next : 
                       id_found ? channel_table_reg_next[id_index] : new_channel;

  assign new_channel = fcr_empty ? rotate_channel : fcr_channel;

  assign ch_arlast_received = ch_arlast_received_nxt;

  generate
  if (USE2RAQ==1 && READ_DATA_INTERLEAVE_EN==0) begin:Dual_RAQ_no_RDI
    // Table which indicates if a Virtual channel has got the last token of the
    // AXI transaction assigned to it or not. 1: Last token recieved, 0: not received.
    always @ (*) begin : vtq_arlast_received_nxt_gen
      ch_arlast_received_nxt = ch_arlast_received_reg;
      for(int i=0;i<NUM_VIR_CH;i=i+1)  begin
// spyglass disable_block W415a
// SMD: Signal ch_arlast_received_nxt[*] is being assigned multiple times ( previous assignment at line [CulpritLineNumber] ) in same always block
// SJ: This is accepted coding style. The signal is initialized first, and then updated inside if condition.
        if (~ocr_empty & dcm_bam_arlast & ~ocr_split & (channel==i)) begin
          ch_arlast_received_nxt[i] = 1'b1;
        end else if (~ocr_empty & (~dcm_bam_arlast | ocr_split) & (channel==i)) begin
          ch_arlast_received_nxt[i] = 1'b0;
        end
// spyglass enable_block W415a
      end
    end

    // flag which indicate if the last token of the current AXI transaction is received or not.
    // blue_last_token_received_r : last token of blue AXI read is received or not.
    // red_last_token_received_r : last token of red AXI read is received or not.
    always @ (*) begin : last_token_received_nxt_gen
      blue_last_token_received_nxt = blue_last_token_received_r;
      red_last_token_received_nxt  = red_last_token_received_r;
      if (~ocr_empty & dcm_bam_arlast & ~ocr_split) begin
        if (~dcm_bam_red_token) begin
          blue_last_token_received_nxt = 1'b1;
        end else begin
          red_last_token_received_nxt = 1'b1;
        end
      end else if (~ocr_empty & (~dcm_bam_arlast | ocr_split)) begin
        if (~dcm_bam_red_token) begin
          blue_last_token_received_nxt = 1'b0;
        end else begin
          red_last_token_received_nxt = 1'b0;
        end
      end
    end
    // Table which tells if a channel has been assigned for a token in this cycle or not.
    // If a channel is assigned in this cycle, it should not be considered as free for the next 2 cycles(till vtq_empty goes low)
    always @ (*) begin : ch_assigned_gen
      ch_assigned = {NUM_VIR_CH{1'b0}};
      for(int i=0;i<NUM_VIR_CH;i=i+1)  begin
// spyglass disable_block W415a
// SMD: Signal ch_assigned[*] is being assigned multiple times ( previous assignment at line [CulpritLineNumber] ) in same always block
// SJ: This is accepted coding style. Signal is initialized first, and then updated inside if condition.
        if (~ocr_empty & (channel==i)) begin
          ch_assigned[i] = 1'b1;
        end
// spyglass enable_block W415a
      end
    end


    localparam ARLAST_RX_REGW = (NUM_VIR_CH+2);
    DWC_ddr_umctl2_par_reg
    
    #(
       .DW      (ARLAST_RX_REGW),
       .OCCAP   (OCCAP_EN),
       .OCCAP_PIPELINE_EN   (OCCAP_PIPELINE_EN),
       .REG_EN  (0),
       .RESVAL  ({ARLAST_RX_REGW{1'b1}})
    )
    U_arlast_token_rx
    (
       .clk        (clk),
       .rst_n      (rst_n),
       .data_in    ({ch_arlast_received_nxt,blue_last_token_received_nxt,red_last_token_received_nxt}),
       .reg_set    (1'b0),
       .parity_en  (reg_ddrc_occap_en),
       .poison_en  (1'b0),
       .data_out   ({ch_arlast_received_reg,blue_last_token_received_r,red_last_token_received_r}),
       .parity_err (arlast_token_rx_par_err)
    );

    // from RRB tokens are returned, 1 cycles after token is read out from VTQ
    // vtq_empty will get asserted at the same time as returned token reaches DCM
    // But it will take 1 more cycle to returned token to be cleared from used_token_table
    // To prevent DCM from considering the channel as free during this 1 cycle, vtq_empty needs to be delayed for 1 cycle.
    // This is use in free channel identification
    
    DWC_ddr_umctl2_par_reg
    
    #(
       .DW      (NUM_VIR_CH),
       .OCCAP   (OCCAP_EN),
       .OCCAP_PIPELINE_EN   (OCCAP_PIPELINE_EN),
       .REG_EN  (0)
    )
    U_vtq_empty_pipe
    (
       .clk        (clk),
       .rst_n      (rst_n),
       .data_in    (vtq_empty),
       .reg_set    (1'b0),
       .parity_en  (reg_ddrc_occap_en),
       .poison_en  (1'b0),
       .data_out   (vtq_empty_reg),
       .parity_err (vtq_empty_reg_par_err)
    );

  end else begin: n_Dual_RAQ_no_RDI
    assign ch_arlast_received_nxt       = {NUM_VIR_CH{1'b1}};
    assign ch_assigned                  = {NUM_VIR_CH{1'b0}};
    assign blue_last_token_received_nxt = 1'b0;
    assign red_last_token_received_nxt  = 1'b0;
    assign arlast_token_rx_par_err      = 1'b0;
    assign vtq_empty_reg                = {NUM_VIR_CH{1'b1}};
    assign vtq_empty_reg_par_err        = 1'b0;
  end
  endgenerate

  //-------------------------------------------------------
  //     Mapped ID/Channel per token tables 
  //-------------------------------------------------------

   generate
      for (gv=0; gv<NTOKENS; gv=gv+1) begin: token_table

         wire [TOKEN_T_WIDTH-1:0] data_in, data_out;
         wire data_set, data_reset;

         assign data_in = {id_table_reg_next[gv],channel_table_reg_next[gv],used_token_table_next[gv]};
         assign {id_table_reg[gv],channel_table_reg[gv],used_token_table[gv]} = data_out;

         assign data_set   = gv==dcm_token  ? ~ocr_empty : 1'b0;
         assign data_reset = gv==rtoken_r ? release_token_r : 1'b0;

         assign id_table_reg_next[gv]      = data_set ? arid_r : id_table_reg[gv];
         assign channel_table_reg_next[gv] = data_set ? channel : channel_table_reg[gv];
         assign used_token_table_next[gv]  = data_set ? 1'b1 :
                                             data_reset ? 1'b0 : used_token_table[gv];
   
         DWC_ddr_umctl2_par_reg
         
         #(
            .DW      (TOKEN_T_WIDTH),
            .OCCAP   (OCCAP_EN),
            .OCCAP_PIPELINE_EN   (OCCAP_PIPELINE_EN),
            .REG_EN  (0)
         )
         U_token_table_r
         (
            .clk        (clk),
            .rst_n      (rst_n),
            .data_in    (data_in),
            .reg_set    (1'b0),
            .parity_en  (reg_ddrc_occap_en),
            .poison_en  (1'b0),
            .data_out   (data_out),
            .parity_err (token_table_par_err[gv])
         );

      end
   endgenerate

   assign last_mapped_channel_next     = channel_blue_set ? channel : last_mapped_channel;
   assign last_mapped_id_next          = channel_blue_set ? arid_r : last_mapped_id;
   assign last_mapped_channel_red_next = channel_red_set ? channel : last_mapped_channel_red;
   assign last_mapped_id_red_next      = channel_red_set ? arid_r : last_mapped_id_red;

   assign channel_blue_in = {last_mapped_channel_next,last_mapped_id_next};
   assign {last_mapped_channel,last_mapped_id} = channel_blue_out;
   assign channel_red_in = {last_mapped_channel_red_next,last_mapped_id_red_next};
   assign {last_mapped_channel_red,last_mapped_id_red} = channel_red_out;

   assign channel_blue_set = ~ocr_empty & ~dcm_bam_red_token;
   assign channel_red_set  = ~ocr_empty & dcm_bam_red_token;

   DWC_ddr_umctl2_par_reg
   
   #(
      .DW      (TOKEN_CH_WIDTH+AXI_IDW+NTOKENS_LG2+1),
      .OCCAP   (OCCAP_EN),
      .OCCAP_PIPELINE_EN   (OCCAP_PIPELINE_EN)
   )
   U_channel_blue_r
   (
      .clk        (clk),
      .rst_n      (rst_n),
      .data_in    ({channel_blue_in,arid,rtoken,release_token}),
      .reg_set    (1'b0),
      .parity_en  (reg_ddrc_occap_en),
      .poison_en  (1'b0),
      .data_out   ({channel_blue_out,arid_r,rtoken_r,release_token_r}),
      .parity_err (channel_blue_par_err)
   );

   DWC_ddr_umctl2_par_reg
   
   #(
      .DW      (TOKEN_CH_WIDTH),
      .OCCAP   (OCCAP_EN),
      .OCCAP_PIPELINE_EN   (OCCAP_PIPELINE_EN)      
   )
   U_channel_red_r
   (
      .clk        (clk),
      .rst_n      (rst_n),
      .data_in    (channel_red_in),
      .reg_set    (1'b0),
      .parity_en  (reg_ddrc_occap_en),
      .poison_en  (1'b0),
      .data_out   (channel_red_out),
      .parity_err (channel_red_par_err)
   );

   always @ (*) begin : token_table_COMB_PROC
      if (channel_blue_set) begin
        first_id_nxt = 1'b0;
      end else begin
        first_id_nxt = first_id;
      end

      

      if (channel_red_set) begin
        first_id_red_nxt = 1'b0;
      end else begin
        first_id_red_nxt = first_id_red;
      end
  end

  always @ (posedge clk or negedge rst_n) begin : token_table_SEQ_PROC
    if (rst_n == 1'b0) begin
      first_id       <= 1'b1;
      first_id_red   <= 1'b1;
    end 
    else begin
      first_id       <= first_id_nxt;
      
// spyglass disable_block FlopEConst
// SMD: Enable pin EN on Flop DWC_ddrctl.U_xpi_$.\dynamic_channel_map.dynamic_channel_map_multi_ch.U_xpi_dcm .first_id_red (master RTL_FDCE) is  always disabled (tied low)
// SJ: if `UMCTL2_XPI_USE2RAQ_$ is 0, the red_queue signal is always 1'b0

      first_id_red   <= first_id_red_nxt;
      
// spyglass enable_block FlopEConst

    end
  end

  //-------------------------------------------------------
  //     Booked Channel Table 
  //-------------------------------------------------------

  always @ (*) begin : booked_channel_table_COMB_PROC
      for (i=0; i <NUM_VIR_CH ; i=i+1) begin
        if (fcr_wr && ~fcr_full && $unsigned(i) == free_channel) begin
          booked_channel_table_nxt[i] = 1'b1;
        end
        else if (~empty_reg && $unsigned(i) == channel_reg) begin
          booked_channel_table_nxt[i] = 1'b0;
        end else begin
          booked_channel_table_nxt[i] = booked_channel_table[i];
        end

      end
  end // block: booked_channel_table_COMB_PROC


  always @ (posedge clk or negedge rst_n) begin : booked_channel_table_SEQ_PROC
    if (rst_n == 1'b0) begin
      empty_reg            <= 1'b1;
      channel_reg          <= {NUM_VIR_CH_LG2{1'b0}};
      booked_channel_table <= {NUM_VIR_CH{1'b0}};
    end 
    else begin
      empty_reg            <= empty;
      channel_reg          <= channel;
      booked_channel_table <= booked_channel_table_nxt;
    end // else: !if(rst_n == 1'b0)
  end // block: booked_channel_table_SEQ_PROC

  //-------------------------------------------------------
  //     Rotate Channel 
  //-------------------------------------------------------
  
  //spyglass disable_block SelfDeterminedExpr-ML
  //SMD: Self determined expression '(rotate_channel==(NUM_VIR_CH - 1))' found in module 'DWC_ddr_umctl2_xpi_dcm'
  //SJ: This coding style is acceptable and there is no plan to change it.
  always @ (*) begin : rotate_channel_COMB_PROC
      if (fcr_empty&wr) begin
        if (rotate_channel==(NUM_VIR_CH-1))
          rotate_channel_nxt = {NUM_VIR_CH_LG2{1'b0}};
        else
          rotate_channel_nxt = rotate_channel+1'b1;
      end else begin
          rotate_channel_nxt = rotate_channel;
      end
  end
  //spyglass enable_block SelfDeterminedExpr-ML

    always @ (posedge clk or negedge rst_n) begin : rotate_channel_SEQ_PROC
    if (rst_n == 1'b0) begin
      rotate_channel <= {NUM_VIR_CH_LG2{1'b0}};
    end 
    else begin
      rotate_channel <= rotate_channel_nxt;
    end
  end

//spyglass disable_block W415a
//SMD: Signal id_index/id_found/free_channel/free_channel_found is being assigned multiple times in same always block. 
//SJ: Using initialization in process to minimize code - sets the default for any hanging branches, avoids latches

  //-------------------------------------------------------
  //     ID search 
  //-------------------------------------------------------

  always @(*) begin : search_id_COMB_PROC
    id_index = {NTOKENS_LG2{1'b0}};
    id_found = 1'b0;
    for (i=0 ; i < NTOKENS ; i=i+1) begin
      if (id_table_reg_next[i]==arid&&used_token_table_next[i]==1'b1) begin 
        id_index = $unsigned(i);
        id_found = 1'b1;
      end
    end
  end

  //-------------------------------------------------------
  //     Free Channel search 
  //-------------------------------------------------------
  
  always @(*) begin : search_free_channel_COMB_PROC
    free_channel = {NUM_VIR_CH_LG2{1'b0}};
    free_channel_found = 1'b0;
    for (i=NUM_VIR_CH-1 ; i >=0 ; i=i-1) begin
      if (vtq_empty[i]&vtq_empty_reg[i]&ch_arlast_received_nxt[i]& ~ch_assigned[i] &~booked_channel_table[i]) begin
//spyglass disable_block W314
//SMD: Converting multi-bit reg type to single bit
//SJ: It can happen when NUM_VIR_CH=2. This is ok
        free_channel= $unsigned(i);
//spyglass enable_block W314
        free_channel_found = 1'b1;
      end
    end
  end
//spyglass enable_block W415a

  //-------------------------------------------------------
  //     Free Channel Retime   
  //-------------------------------------------------------
  DWC_ddr_umctl2_retime
  
    
    #(
    .SIZE   (NUM_VIR_CH_LG2),
    .OCCAP_EN  (OCCAP_EN),
    .OCCAP_PIPELINE_EN   (OCCAP_PIPELINE_EN)    
  ) 
   U_fcr
      (
       .clk         (clk),    
       .rst_n       (rst_n),    
       .d           (free_channel),
       .wr          (fcr_wr),
       .rd          (fcr_rd),
       .par_en      (reg_ddrc_occap_en),
       .q           (fcr_channel),
       .fe          (fcr_empty),
       .ff          (fcr_full),
       .par_err     (occap_fcr_par_err)
       );

  assign fcr_wr = free_channel_found;
  // No pressure from RRB, OCR can never get full, &~fcr_full is redundant.
  assign fcr_rd = wr & ~reuse_channel;

  //-------------------------------------------------------
  //     Output Channel Retime
  //-------------------------------------------------------
  
  DWC_ddr_umctl2_retime
  
    
    #(
    .SIZE   (OCRSIZE),
    .OCCAP_EN  (OCCAP_EN),
    .OCCAP_PIPELINE_EN   (OCCAP_PIPELINE_EN)    
  ) 
   U_ocr
      (
       .clk         (clk),    
       .rst_n       (rst_n),    
       .d           (ocr_d),
       .wr          (ocr_wr),
       .rd          (ocr_rd),
       .par_en      (reg_ddrc_occap_en),
       .q           (ocr_q),
       .fe          (ocr_empty),
//spyglass disable_block W528
//SMD: A signal or variable is set but never read
//SJ: Used in RTL assertion
       .ff          (ocr_full),
//spyglass enable_block W528
       .par_err     (occap_ocr_par_err)
       );

  generate 
    if(USE_BAM==1) begin : HAS_BAM
      assign ocr_d = {split,red_queue,bam_arlast,bam_lead_burst,bam_addr_offset,dch,token,channel_ocr};
//spyglass disable_block W528
//SMD: A signal or variable is set but never read
//SJ: Used in generate block
      assign {ocr_split,dcm_bam_red_token,dcm_bam_arlast,dcm_bam_lead_burst, dcm_bam_addr_offset, dcm_dch,dcm_token,channel} = ocr_q;
//spyglass enable_block W528
      assign dcm_sbam_lead_burst        = 1'b0;
      assign dcm_sbam_second_burst      = 1'b0;
      assign dcm_sbam_tokens_allocated  = {(NTOKENS_LG2_SBAM+1){1'b0}};
    end else if(RRB_THRESHOLD_EN == 1) begin : WITH_SBAM // RRB_THRESHOLD_EN == 1
      assign ocr_d = {split,red_queue,bam_arlast,sbam_lead_burst, sbam_second_burst, sbam_tokens_allocated, dch, token, channel_ocr};
//spyglass disable_block W528
//SMD: A signal or variable is set but never read
//SJ: Used in generate block
      assign {ocr_split,dcm_bam_red_token,dcm_bam_arlast,dcm_sbam_lead_burst, dcm_sbam_second_burst, dcm_sbam_tokens_allocated, dcm_dch, dcm_token, channel} = ocr_q;
//spyglass enable_block W528
    end else begin : NO_BAM
      assign ocr_d = {split,red_queue,bam_arlast,dch,token,channel_ocr};
//spyglass disable_block W528
//SMD: A signal or variable is set but never read
//SJ: Used in generate block
      assign {ocr_split,dcm_bam_red_token,dcm_bam_arlast,dcm_dch,dcm_token,channel} = ocr_q;
//spyglass enable_block W528
      assign dcm_sbam_lead_burst        = 1'b0;
      assign dcm_sbam_second_burst      = 1'b0;
      assign dcm_sbam_tokens_allocated  = {(NTOKENS_LG2_SBAM+1){1'b0}};
    end
  endgenerate

  assign ocr_wr = wr;
  // No pressure from RRB, always pop OCR
  assign ocr_rd = ~ocr_empty;


  //---------------------------------------------------------------------------
  // OCCAP_EN process
  // for control related registers on clk
  //---------------------------------------------------------------------------


  generate
   if (OCCAP_EN==1) begin: OCCAP_en

     
     wire [OCCAP_CTRLW-1:0] pgen_in;  
     wire [OCCAP_CTRLW-1:0] pcheck_in;  

     // 
     // wiring of pgen_in/pcheck_in
     //
  
     assign pgen_in    = {rotate_channel_nxt,
                          booked_channel_table_nxt,
                          empty,
                          channel,
                          first_id_nxt,                        
                          first_id_red_nxt};


     assign pcheck_in  = {rotate_channel,
                          booked_channel_table,
                          empty_reg,
                          channel_reg,
                          first_id,                        
                          first_id_red};


     wire [PARW-1:0]        pgen_in_par;     
     reg  [PARW-1:0]        pgen_in_par_r;     
     wire [PARW-1:0]        pcheck_par_err;
     wire [PARW-1:0]        pgen_parity_corr_unused, pcheck_parity_corr_unused;   
     
     wire                   parity_en;
     reg                    pcheck_en;
     wire [PARW-1:0]        parity_dummy,  mask_in;
     wire                   poison_en;

     assign parity_dummy  = {PARW{1'b1}};
     assign mask_in       = {PARW{1'b1}};
     assign poison_en     = 1'b0;

     assign parity_en = reg_ddrc_occap_en;
     always @(posedge clk or negedge rst_n) begin
           if (~rst_n) begin
              pcheck_en <= 0;
           end
           else begin
              pcheck_en <= parity_en;
           end
      end

           
     // 
     // parity checking logic itself
     //
         DWC_ddr_umctl2_ocpar_calc
         
         
         #(
            .DW      (OCCAP_CTRLW), 
            .CALC    (1), // parity calc
            .PAR_DW  (PARW),
            .SL_W    (SL_W)
         )
         U_pgen
         (
            .data_in       (pgen_in),
            .parity_en     (parity_en),
            .parity_type   (poison_en),
            .parity_in     (parity_dummy),
            .mask_in       (mask_in),
            .parity_out    (pgen_in_par), // parity out
            .parity_corr   (pgen_parity_corr_unused) // not used
         );


         always @ (posedge clk or negedge rst_n)
           if (~rst_n) begin
             pgen_in_par_r <= {PARW{1'b0}};
           end
           else begin
             pgen_in_par_r <= pgen_in_par;
           end


         DWC_ddr_umctl2_ocpar_calc
         
         
         #(
            .DW      (OCCAP_CTRLW),
            .CALC    (0), // parity check
            .PAR_DW  (PARW),
            .SL_W    (SL_W)
         )
         U_pcheck
         (
            .data_in       (pcheck_in),
            .parity_en     (pcheck_en),
            .parity_type   (1'b0),
            .parity_in     (pgen_in_par_r), // parity in
            .mask_in       (mask_in),
            .parity_out    (pcheck_par_err), // parity error
            .parity_corr   (pcheck_parity_corr_unused) // not used
         );     
      

         if (OCCAP_PIPELINE_EN==1) begin : OCCAP_PIPELINE_EN_1

           reg pcheck_par_err_r;
           always @ (posedge clk or negedge rst_n) begin : pcheck_par_err_r_PROC
             if (~rst_n) begin
               pcheck_par_err_r <= 1'b0;
             end else begin
               pcheck_par_err_r <= |pcheck_par_err;
             end
           end

           assign occap_xpi_dcm_ctrl_par_err = pcheck_par_err_r;          

         end else begin : OCCAP_PIPELINE_EN_0
         
           assign occap_xpi_dcm_ctrl_par_err = |pcheck_par_err;

         end 


         
   end else begin: OCCAP_ne
      assign occap_xpi_dcm_ctrl_par_err = 1'b0;
  end
  endgenerate



`ifdef SNPS_ASSERT_ON
`ifndef SYNTHESIS

  // Empty is low one cycle after wr is asserted
  property p_1cycle_mapping;
    @(posedge clk) disable iff(!rst_n) 
      (wr) |->##1 (~empty);
  endproperty 

  a_1cycle_mapping : assert property (p_1cycle_mapping) else 
    $display("-> %0t ERROR: [xpi_dcm] Channel mapping latency is more than 1 cycle", $realtime);
  
  // Considering that booked channels can only reside in FCR (2), OCR (2) and channel_reg (1),
  // The maximum number of booked channels must not be greater than 5.
  property p_booked_ch_less_than_5;
    @(posedge clk) disable iff(!rst_n) 
      ($countones(booked_channel_table)<=5);
  endproperty 

  a_booked_ch_less_than_5 : assert property (p_booked_ch_less_than_5) else 
  $display("-> %0t ERROR: [xpi_dcm] More than 5 channels are simultaniously booked. This is not expected!", $realtime);

  // There is no pressure from RRB, OCR must never get full
  property p_xpi_ocr_never_full; 
    @(posedge clk) disable iff(!rst_n) 
      (~ocr_full);
  endproperty 

  a_xpi_ocr_never_full : assert property (p_xpi_ocr_never_full) else 
  $display("-> %0t ERROR: [xpi_dcm] Output Channel Retime is full!", $realtime);

  // Free channel retime must not be empty when empty virtual channels exisit
  property p_fcr_empty_all_vtq_busy;
    @(posedge clk) disable iff(!rst_n) 
      (fcr_empty) |-> (~(|vtq_empty));
  endproperty 
//  a_fcr_empty_all_vtq_busy : assert property (p_fcr_empty_all_vtq_busy) else 
//    $display("-> %0t ERROR: [xpi_dcm] Free Channel Retime empty while free VTQ exist", $realtime);
  
  // mapped channel covers all available channels
  covergroup channels_seen @ (posedge clk);
    coverpoint channel {
      bins ch_zero = { 0 };
      bins ch_middle = {[1:(NUM_VIR_CH-1)]};
      bins ch_last= { NUM_VIR_CH};
    }
  endgroup : channels_seen

 // Current ARID is the same last mapped ARID, the same channel will be assigned
  cp_arid_same_as_previous :
  cover property (
    @(posedge clk) disable iff(!rst_n)
    wr==1'b1&&arid_same_as_previous==1'b1
  );

 // Current ARID red queue is the same last mapped ARID from red queue, the same channel will be assigned
  cp_arid_same_as_previous_red :
  cover property (
    @(posedge clk) disable iff(!rst_n)
    wr==1'b1&&arid_same_as_previous_red==1'b1
  );
 // ARID already mapped to a channel reuse the same channel.
  cp_arid_already_mapped :
  cover property (
    @(posedge clk) disable iff(!rst_n)
    wr==1'b1&&id_found==1'b1
  );
 // All channels are mapped, rotating channels.
  cp_all_channel_mapped :
  cover property (
    @(posedge clk) disable iff(!rst_n)
    wr==1'b1&&fcr_empty==1'b1
  );

`endif // SYNTHESIS
`endif // SNPS_ASSERT_ON    
  
endmodule // DWC_ddr_umctl2_dcm
