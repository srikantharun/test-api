global phy_regs
source ../../pdl/dwc_lpddr5xphy_regs.tcl

iProcsForModule lpddr_p
global env
iProc simulation_only_backdoor_load_mem { {lpddr_top DUT_inst } } {
    global env

    iNote "TESSENT_PRAGMA simulation_only begin"

        
    for {set j 0} {$j < 2} {incr j} {
        for {set i 0} {$i < 4} {incr i} {
            iNote "load_mem ${lpddr_top}.u_lpddr_subsys_wrapper.snps_ddr_subsystem_inst.i_DWC_ddrphy_mem_wrap.genblock_iccm${j}[${i}]"
            if {$j==0} {
                set prefix i_
            } else {
                set prefix i_iccm${j}_
            }
            iNote "TESSENT_PRAGMA verilog_insert\n\t\t\/\/Inserted by lpddr.pdl\n\t\treg[512*8:1]  _new_filename_imem_${j}_ecc_mem${i};\n\t\t\$sformat(_new_filename_imem_${j}_ecc_mem${i},\"%0s/ddr_ate_firmware/ddr_ate_imem_bank${j}_ecc_mem${i}\",_new_path);\n\t\t${lpddr_top}.u_lpddr_subsys_wrapper.snps_ddr_subsystem_inst.i_DWC_ddrphy_mem_wrap.genblock_iccm${j}[${i}].${prefix}ln05lpe_a00_mc_ra1rwp_hsr_lvt_1536x78m4b4c1r2_wrapper.u_mem.load_mem(_new_filename_imem_${j}_ecc_mem${i});"
        }
    }
    for {set j 0} {$j < 4} {incr j} {
        for {set i 0} {$i < 4} {incr i} {
            iNote "load_mem ${lpddr_top}.u_lpddr_subsys_wrapper.snps_ddr_subsystem_inst.i_DWC_ddrphy_mem_wrap.genblock_dccm${j}[${i}]"
            iNote "TESSENT_PRAGMA verilog_insert\n\t\t\/\/Inserted by lpddr.pdl\n\t\treg[512*8:1]  _new_filename_dmem_${j}_ecc_mem${i};\n\t\t\$sformat(_new_filename_dmem_${j}_ecc_mem${i},\"%0s/ddr_ate_firmware/ddr_ate_dmem_bank${j}_ecc_mem${i}\",_new_path);\n\t\t${lpddr_top}.u_lpddr_subsys_wrapper.snps_ddr_subsystem_inst.i_DWC_ddrphy_mem_wrap.genblock_dccm${j}[${i}].i_dccm${j}_ln05lpe_a00_mc_ra1rwp_hsr_rvt_1536x39m4b4c1r2_wrapper.u_mem.load_mem(_new_filename_dmem_${j}_ecc_mem${i});"
        }
    }
    iNote "TESSENT_PRAGMA simulation_only end"
    

}

iProc simulation_only_init {} {

    #Must used Bender file hw/vendor/synopsys/lpddr_subsys/default/rtl/pg_pins
    iNote "TESSENT_PRAGMA simulation_only begin"
    iNote "tessent_pragma verilog_insert force DUT_inst.u_lpddr_subsys_wrapper.snps_ddr_subsystem_inst.i_DWC_lpddr5x_phy.VSS = 1'b0;"
    iNote "tessent_pragma verilog_insert force DUT_inst.u_lpddr_subsys_wrapper.snps_ddr_subsystem_inst.i_DWC_lpddr5x_phy.VDD = 1'b1;"
    iNote "tessent_pragma verilog_insert force DUT_inst.u_lpddr_subsys_wrapper.snps_ddr_subsystem_inst.i_DWC_lpddr5x_phy.VDDQ_ZCAL = 1'b1;"
    iNote "tessent_pragma verilog_insert force DUT_inst.u_lpddr_subsys_wrapper.snps_ddr_subsystem_inst.i_DWC_lpddr5x_phy.VDDQ_DB0_DX0 = 1'b1;"
    iNote "tessent_pragma verilog_insert force DUT_inst.u_lpddr_subsys_wrapper.snps_ddr_subsystem_inst.i_DWC_lpddr5x_phy.VDDQ_DB0_DX1 = 1'b1;"
    iNote "tessent_pragma verilog_insert force DUT_inst.u_lpddr_subsys_wrapper.snps_ddr_subsystem_inst.i_DWC_lpddr5x_phy.VDDQ_DB1_DX0 = 1'b1;"
    iNote "tessent_pragma verilog_insert force DUT_inst.u_lpddr_subsys_wrapper.snps_ddr_subsystem_inst.i_DWC_lpddr5x_phy.VDDQ_DB1_DX1 = 1'b1;"
    iNote "tessent_pragma verilog_insert force DUT_inst.u_lpddr_subsys_wrapper.snps_ddr_subsystem_inst.i_DWC_lpddr5x_phy.VDDQ_DB2_DX0 = 1'b1;"
    iNote "tessent_pragma verilog_insert force DUT_inst.u_lpddr_subsys_wrapper.snps_ddr_subsystem_inst.i_DWC_lpddr5x_phy.VDDQ_DB2_DX1 = 1'b1;"
    iNote "tessent_pragma verilog_insert force DUT_inst.u_lpddr_subsys_wrapper.snps_ddr_subsystem_inst.i_DWC_lpddr5x_phy.VDDQ_DB3_DX0 = 1'b1;"
    iNote "tessent_pragma verilog_insert force DUT_inst.u_lpddr_subsys_wrapper.snps_ddr_subsystem_inst.i_DWC_lpddr5x_phy.VDDQ_DB3_DX1 = 1'b1;"
    iNote "tessent_pragma verilog_insert force DUT_inst.u_lpddr_subsys_wrapper.snps_ddr_subsystem_inst.i_DWC_lpddr5x_phy.VDDQ_AC0_ACX0 = 1'b1;"
    iNote "tessent_pragma verilog_insert force DUT_inst.u_lpddr_subsys_wrapper.snps_ddr_subsystem_inst.i_DWC_lpddr5x_phy.VDDQ_AC0_ACX1 = 1'b1;"
    iNote "tessent_pragma verilog_insert force DUT_inst.u_lpddr_subsys_wrapper.snps_ddr_subsystem_inst.i_DWC_lpddr5x_phy.VDDQ_AC0_ACX2 = 1'b1;"
    iNote "tessent_pragma verilog_insert force DUT_inst.u_lpddr_subsys_wrapper.snps_ddr_subsystem_inst.i_DWC_lpddr5x_phy.VDDQ_AC0_ACX3 = 1'b1;"
    iNote "tessent_pragma verilog_insert force DUT_inst.u_lpddr_subsys_wrapper.snps_ddr_subsystem_inst.i_DWC_lpddr5x_phy.VDDQ_AC0_CKX0 = 1'b1;"
    iNote "tessent_pragma verilog_insert force DUT_inst.u_lpddr_subsys_wrapper.snps_ddr_subsystem_inst.i_DWC_lpddr5x_phy.VDDQ_AC1_ACX0 = 1'b1;"
    iNote "tessent_pragma verilog_insert force DUT_inst.u_lpddr_subsys_wrapper.snps_ddr_subsystem_inst.i_DWC_lpddr5x_phy.VDDQ_AC1_ACX1 = 1'b1;"
    iNote "tessent_pragma verilog_insert force DUT_inst.u_lpddr_subsys_wrapper.snps_ddr_subsystem_inst.i_DWC_lpddr5x_phy.VDDQ_AC1_ACX2 = 1'b1;"
    iNote "tessent_pragma verilog_insert force DUT_inst.u_lpddr_subsys_wrapper.snps_ddr_subsystem_inst.i_DWC_lpddr5x_phy.VDDQ_AC1_ACX3 = 1'b1;"
    iNote "tessent_pragma verilog_insert force DUT_inst.u_lpddr_subsys_wrapper.snps_ddr_subsystem_inst.i_DWC_lpddr5x_phy.VDDQ_AC1_CKX0 = 1'b1;"
    iNote "tessent_pragma verilog_insert force DUT_inst.u_lpddr_subsys_wrapper.snps_ddr_subsystem_inst.i_DWC_lpddr5x_phy.VDD2H = 1'b1;"
    iNote "tessent_pragma verilog_insert force DUT_inst.u_lpddr_subsys_wrapper.snps_ddr_subsystem_inst.i_DWC_lpddr5x_phy.VAA = 1'b1;"
    iNote "TESSENT_PRAGMA simulation_only end"
}


iTopProc pulse_resets { } {

    iRunLoop -time 1us 

    iForcePort i_global_rst_n 0
    iForcePort i_ao_rst_n 0;

    iRunLoop 10

    iForcePort i_global_rst_n 1
    iForcePort i_ao_rst_n 1;

    iRunLoop 10
}

iProc csr_rd { address data } {

    global phy_regs
    set reg_name [dict get $phy_regs [format "0X%08X" $address]]

    iNote "Reading $reg_name expected value $data"

    # shift into dwc_ddrphy_jtag_dfttdrs_cmd
    # 28 bits of address
    # 1 bit of WR_RD set to 0
    # 32 bits of zeros
    
    iWrite dwc_ddrphy_jtag_dfttdrs_Cmd_inst.tdr[60:29] 0x00000000
    iWrite dwc_ddrphy_jtag_dfttdrs_Cmd_inst.tdr[28]    0b0
    iWrite dwc_ddrphy_jtag_dfttdrs_Cmd_inst.tdr[27:0]  $address
    iApply

    #Wait 10 cycles
    iRunLoop 10 -tck
    
    #shift out of dwc_ddrphy_jtag_dfttdrs_RdData
    # 32bit of data
    iRead dwc_ddrphy_jtag_dfttdrs_RdData_inst.tdr $data
    iApply


}
iProc csr_rd_masked { address data mask } {

    global phy_regs
    set reg_name [dict get $phy_regs [format "0X%08X" $address]]

    set exp_data "0b[masked_val $data $mask 32]"  ;# this function is in pcie/dft/pdl
    
    iNote "Reading $reg_name expected value $exp_data"

    # shift into dwc_ddrphy_jtag_dfttdrs_cmd
    # 28 bits of address
    # 1 bit of WR_RD set to 0
    # 32 bits of zeros
    
    iWrite dwc_ddrphy_jtag_dfttdrs_Cmd_inst.tdr[60:29] 0x00000000
    iWrite dwc_ddrphy_jtag_dfttdrs_Cmd_inst.tdr[28]    0b0
    iWrite dwc_ddrphy_jtag_dfttdrs_Cmd_inst.tdr[27:0]  $address
    iApply

    #Wait 10 cycles
    iRunLoop 10 -tck
    
    #shift out of dwc_ddrphy_jtag_dfttdrs_RdData
    # 32bit of data
    iRead dwc_ddrphy_jtag_dfttdrs_RdData_inst.tdr $exp_data
    iApply


}


iProc csr_rd_capture { address } {

    global phy_regs
    set reg_name [dict get $phy_regs [format "0X%08X" $address]]

    set exp_data "0bx"
    
    iNote "Reading $reg_name for capture"

    # shift into dwc_ddrphy_jtag_dfttdrs_cmd
    # 28 bits of address
    # 1 bit of WR_RD set to 0
    # 32 bits of zeros
    
    iWrite dwc_ddrphy_jtag_dfttdrs_Cmd_inst.tdr[60:29] 0x00000000
    iWrite dwc_ddrphy_jtag_dfttdrs_Cmd_inst.tdr[28]    0b0
    iWrite dwc_ddrphy_jtag_dfttdrs_Cmd_inst.tdr[27:0]  $address
    iApply

    #Wait 10 cycles
    iRunLoop 10 -tck
    
    #shift out of dwc_ddrphy_jtag_dfttdrs_RdData
    # 32bit of data
    iNote "tessent_pragma iReadVar ${reg_name}_capture dwc_ddrphy_jtag_dfttdrs_RdData_inst.tdr"
    iRead dwc_ddrphy_jtag_dfttdrs_RdData_inst.tdr $exp_data
    iApply


}


iProc csr_wr { address data } {
    global phy_regs
    set reg_name [dict get $phy_regs [format "0X%08X" $address]]

    iNote "Writing $reg_name with value $data"
    
    # shift into dwc_ddrphy_jtag_dfttdrs_Cmd
    # 28 bits of address
    # 1 bit of WR_RD set to 1
    # 32 bits of data
    
    iNote "tessent_pragma iWriteVar $reg_name dwc_ddrphy_jtag_dfttdrs_Cmd_inst.tdr[60:29]"
    iWrite dwc_ddrphy_jtag_dfttdrs_Cmd_inst.tdr[60:29] $data
    iWrite dwc_ddrphy_jtag_dfttdrs_Cmd_inst.tdr[28]    0b1
    iWrite dwc_ddrphy_jtag_dfttdrs_Cmd_inst.tdr[27:0]  $address
    iApply

}


iProc pll_init { } {

    #  PHY supports at-speed scan test (ASST) with on-chip clock (OCC) controllers implemented inside the hard
    #  macros to generate the scan clocks for internal PHY functional clocks. The OCC controllers are placed on the
    #  scan branch of the clock multiplexers and therefore have no effect on the critical mission-mode clock path.
    #  After the PLL is locked, the PHY has uses integrated logic to latch the PLL controls to maintain the PLL state
    #  when transitioning into scan testing.
    #  Figure 9-1 shows the sequence for scan testing. The times (Tn) shown in the figure between T0 and T5 are
    #  not necessarily consecutive cycles and are used just to show the sequence of operations. The actual timing
    #  between operations is dependent on the feature being initialized, such as PLL initialization timing. The
    #  timing from T5 are cycle accurate. The following describe the steps for scan sequence:
    #  ■ T0 to T1: Power up and reset the PHY. See “PHY Initialization” on page 151, for details.
    #  ■ Set csrPwrOkDlyCtrl=1
    iCall csr_wr 0x30020 0b1
    iCall csr_wr 0x31020 0b1
    #  ■ Set scan_occ_reset to 1 for at least one scan_clk
    iWrite lpddr_p_rtl2_tessent_tdr_scan_occ_reset_inst.tdr    0b1
    iApply
    iWrite lpddr_p_rtl2_tessent_tdr_scan_occ_reset_inst.tdr    0b0
    iApply
    #  ■ T2 to T3: Startup and lock the PLL by doing the following
    #  (PLL in Mission Mode)
    #       ❑ Wait a minimum of 1 us
    iRunLoop -time 1us
    #       ❑ Set CPllPwrDn=0
    iCall csr_wr 0x60000 0b0
    #       ❑ Wait a minimum of 1 ns
    iRunLoop -time 1us
    #       ❑ Set CPllPreset=1 and CPllGearShift=1
    iCall csr_wr 0x60003 0b11
    #       ❑ Set CPllCtrl1, CPllCtrl3, and CPllCtrl4 registers according to frequency and Optimal PLL settings in PHY databook.
    iCall csr_wr 0x060005  0x804
    iCall csr_wr 0x160005  0x804
    iCall csr_wr 0x260005  0x804
    iCall csr_wr 0x360005  0x804

    iCall csr_wr 0x060006  0x40

    iCall csr_wr 0x060007  0x247C
    iCall csr_wr 0x160007  0x247C
    iCall csr_wr 0x260007  0x247C
    iCall csr_wr 0x360007  0x247C

    #       ❑ Wait a minimum of 1 us
    iRunLoop -time 1us
    #       ❑ Set CPllPreset=0
    iCall csr_wr 0x60003 0b10
    #       ❑ Wait a minimum of 0.5 us
    iRunLoop -time 0.5us
    #       ❑ Set CPllGearShift=0
    iCall csr_wr 0x60003 0b0
    #       ❑ Wait a minimum of 10 us for PLL to lock
    iRunLoop -time 10us
    #  ■ T4: scan_asst_mode to 1. This latches and preserves all the PLL controls to maintain the PLL running at locked state. Wait 16 DFI clock cycles for the latch to take effect.
    iWrite lpddr_p_rtl2_tessent_tdr_scan_asst_mode_inst.tdr    0b1
    iWrite lpddr_p_rtl2_tessent_tdr_scan_shift_async_inst.tdr  0b1
    iWrite lpddr_p_rtl2_tessent_tdr_scan_shift_cg_inst.tdr  0b1
    iApply
    #  ■ T5: Set scan_mode to 1 to enter scan test mode and wait 300 ns so that scan_mode is stable to the final hard macro blocks
    iWrite lpddr_p_rtl2_tessent_tdr_scan_mode_inst.tdr 0b1
    iApply
    #  ■ T6: Set scan_shift_async and scan_shift to 1 to start shifting data in all scan chains, including OCC clock chains.
    #  ■ T7: Set scan_shift_async and scan_shift to 0 to capture at speed. Scan capture happens at T9 for RxClk, TxClk and PClk registers, and at T8 for LCDL oscillator clock registers.
    #  ■ T10: scan_shift_async and scan_shift to 1 to start shifting data out of scan chains. Scan shift out starts happening at T11.
    #  
    

    #csrPwrOkDlyCtrl (for j = 0; j <= DWC_LPDDR5XPHY_NUM_DBYTES-1) (0x30000+(j<<12))+0x20
    #CPllPwrDn                                                     0x60000+0x0
    #CPllBypassMode                                                0x60000+0x2
    #CPllStartLock                                                 0x60000+0x3                   CPllPreset CPllGearShift 
    #CPllCtrl1_pX (for X = 0; X <= 3)                              0x60000+0x5+(X*0x100000)
    #CPllCtrl3                                                     0x60000+0x6
    #CPllCtrl4_pX (for X = 0; X <= 3)                              0x60000+0x7+(X*0x100000) 

}




iProc pll_bypass { } {

    #  PHY supports at-speed scan test (ASST) with on-chip clock (OCC) controllers implemented inside the hard
    #  macros to generate the scan clocks for internal PHY functional clocks. The OCC controllers are placed on the
    #  scan branch of the clock multiplexers and therefore have no effect on the critical mission-mode clock path.
    #  After the PLL is locked, the PHY has uses integrated logic to latch the PLL controls to maintain the PLL state
    #  when transitioning into scan testing.
    #  Figure 9-1 shows the sequence for scan testing. The times (Tn) shown in the figure between T0 and T5 are
    #  not necessarily consecutive cycles and are used just to show the sequence of operations. The actual timing
    #  between operations is dependent on the feature being initialized, such as PLL initialization timing. The
    #  timing from T5 are cycle accurate. The following describe the steps for scan sequence:
    #  ■ T0 to T1: Power up and reset the PHY. See “PHY Initialization” on page 151, for details.
    #  ■ Set csrPwrOkDlyCtrl=1
    iCall csr_wr 0x30020 0b1
    iCall csr_wr 0x31020 0b1
    #  ■ Set scan_occ_reset to 1 for at least one scan_clk
    iWrite lpddr_p_rtl2_tessent_tdr_scan_occ_reset_inst.tdr    0b1
    iApply
    iWrite lpddr_p_rtl2_tessent_tdr_scan_occ_reset_inst.tdr    0b0
    iApply
    #  ■ T2 to T3: Startup and lock the PLL by doing the following
    #  (PLL in Bypass Mode)
    #       ❑ Wait a minimum of 1 us
    iRunLoop -time 1us
    #       ❑ Set CPllPwrDn=1
    iCall csr_wr 0x60000 0b1
    #       ❑ Wait a minimum of 1 ns
    iRunLoop -time 1ns
    #       ❑ Set CPllBypassMode=1
    iCall csr_wr 0x60002 0b1
    #       ❑ Wait a minimum of 1 us
    iRunLoop -time 1us
    #  ■ T4: scan_asst_mode to 1. This latches and preserves all the PLL controls to maintain the PLL running at locked state. Wait 16 DFI clock cycles for the latch to take effect.
    iWrite lpddr_p_rtl2_tessent_tdr_scan_asst_mode_inst.tdr    0b1
    iWrite lpddr_p_rtl2_tessent_tdr_scan_shift_async_inst.tdr  0b1
    iWrite lpddr_p_rtl2_tessent_tdr_scan_shift_cg_inst.tdr     0b1
    iApply
    #  ■ T5: Set scan_mode to 1 to enter scan test mode and wait 300 ns so that scan_mode is stable to the final hard macro blocks
    iWrite lpddr_p_rtl2_tessent_tdr_scan_mode_inst.tdr 0b1
    iApply
    #  ■ T6: Set scan_shift_async and scan_shift to 1 to start shifting data in all scan chains, including OCC clock chains.
    #  ■ T7: Set scan_shift_async and scan_shift to 0 to capture at speed. Scan capture happens at T9 for RxClk, TxClk and PClk registers, and at T8 for LCDL oscillator clock registers.
    #  ■ T10: scan_shift_async and scan_shift to 1 to start shifting data out of scan chains. Scan shift out starts happening at T11.
    #  
    
}
