// (C) Copyright Axelera AI 2021
// All Rights Reserved
// *** Axelera AI Confidential ***
//
// Description: hjson desc for ai_core_csr reg
// Owner: Sander Geursen <sander.geursen@axelera.ai>
//        others

{
  name: "aic_csr_mid_part",
  clocking: [{clock: "clk_i", reset: "rst_ni"}],
  bus_interfaces: [{protocol: "tlul", direction: "device"}],
  regwidth: "64",
  addrcap: "0x10000",
  axi_intf: True
  param_list : [
    {name:"AXI_AW", type:"int", default:"40"},
    {name:"AXI_IDW", type:"int", default:"9"},
    {name:"AXI_LENW", type:"int", default:"8"},
    {name:"SVS_NB_MONITOR", type:"int", default:"30"},
    {name:"PR1_NB_MONITOR", type:"int", default:"14"},
    {name:"PR2_NB_MONITOR", type:"int", default:"43"},
    {name:"C2C_CONSTANTS_GRP", type:"int", default:"2"},
    {name:"NOP_INJ_GRP", type:"int", default: "3"},
    {name:"UTIL_GRP", type:"int", default: "3"},
  ]
  registers: [
    { name: "IMC_BIST_CMD",
      desc: "IMC BIST command register.",
      swaccess: "rw",
      hwaccess: "hrw",
      fields: [
        {
            bits: "0",
            name: "MBIST_START",
            desc: '''Set to 1 to start MBIST. HW acknowledges by reseting this field.'''
        }
        {
            bits: "1",
            name: "CBIST_START",
            desc: '''Set to 1 to start CBIST. HW acknowledges by reseting this field.'''
        }
        {
            bits: "2",
            name: "RESUME",
            desc: '''Set to 1 to resume BIST (failure analysis mode). HW acknowledges by reseting this field.'''
        }
        {
            bits: "3",
            name: "STOP",
            desc: '''Set to 1 to stop BIST. HW acknowledges by reseting this field.'''
        }
      ]
    }
    { name: "IMC_BIST_CFG",
      desc: "IMC BIST configuration register.",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
            bits: "0",
            name: "FAIL_ANALYSIS",
            desc: '''Set to 1 to enable failure analysis mode'''
        }
        {
            bits: "1",
            name: "BURN_IN",
            desc: '''Set to 1 to enable burn-in mode'''
        }
        {
            bits: "3:2",
            name: "BIRA_MODE",
            desc: '''
                  BIRA controller mode.<br/>
                  2'b00: Disabled<br/>
                  2'b01: MBIST only<br/>
                  2'b10: CBIST only<br/>
                  2'b11: MBIST and CBIST
                  '''
        }
        {
            bits: "8:4",
            name: "MAX_REPAIR_ATTEMPTS",
            desc: '''Maximum number of BIRA controller iterations offset by 1 (the value of 0 corresponds to maximum of 1 iteration, and so on).'''
            resval: 0x8
        }
        {
            bits: "9",
            name: "CSR_SEL",
            desc: '''CSR interface select (1: CSR; 0: JTAG) '''
        }
      ]
    }
    { name: "IMC_BIST_STATUS",
      desc: "IMC BIST status register.",
      swaccess: "ro",
      hwaccess: "hrw",
      fields: [
        {
            bits: "0",
            name: "BUSY",
            desc: '''Busy'''
        }
        {
            bits: "1",
            name: "DONE",
            desc: '''Done'''
        }
        {
            bits: "2",
            name: "PASS",
            desc: '''Pass'''
        }
        {
            bits: "3",
            name: "REPAIR_NEEDED",
            desc: '''Indicates whether repair was attempted by the BIRA controller'''
        }
        {
            bits: "7:4",
            name: "ERROR_BANK",
            desc: '''Failure detection bank'''
        }
        {
            bits: "12:8",
            name: "ERROR_COL",
            desc: '''Failure detection column'''
        }
        {
            bits: "36:13",
            name: "ERROR_CYCLE",
            desc: '''Failure detection clock cycle'''
        }
      ]
    }
    { name: "IMC_C2C_OBSERVATION_CFG",
      desc: '''
              Configure the observation of the VDD IMC C2C monitor
              The observer supports 2 configurations
                - Fast : It can be used to engage the nop injection, limit the MVM utilisaiton and engage the clock throttle of AI Core
                - Ultra Fast : It can be used to engage the nop injection
            ''',
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
            name: "ultra_fast_off_th"
            bits: "47:40",
            desc: '''
              If the data observed on C2C crosses the ultra_fast_off_th, the output of the observer is disengage
            '''
            resval: "0"
        },
        {
            name: "ultra_fast_on_th"
            bits: "39:32",
            desc: '''
              If the data observed on C2C crosses the ultra_fast_on_th, the output of the observer is engage
            '''
            resval: "0"
        },
        {
            name: "fast_off_th"
            bits: "31:24",
            desc: '''
              If the data observed on C2C crosses the fast_off_th, the output of the observer is disengage
            '''
            resval: "0"
        },
        {
            name: "fast_on_th"
            bits: "23:16",
            desc: '''
              If the data observed on C2C crosses the ast_on_th, the output of the observer is engage
            '''
            resval: "0"
        },
        {
            name: "ultra_fast_polarity"
            bits: "10",
            desc: '''
              Defines the polarity used by the hysteresis comparator of ultra fast observer
              - 1 (negative polarity) => on < off =>
                  * throttle = 1 if data < on;
                  * throttle = 0 if data > off;
              - 0 (positive polarity) => on > off =>
                * throttle = 1 if data > on;
                * throttle = 0 if data < off
            '''
            resval: "0"
        },
        {
            name: "ultra_fast_enable"
            bits: "9",
            desc: '''
              Enable the fast observer
            '''
            resval: "0"
        },
        {
            name: "ultra_fast_sw_overwrite"
            bits: "8",
            desc: '''
              If 1 forces the throttle output of ultra fast observer
            '''
            resval: "0"
        },
        {
            name: "fast_polarity"
            bits: "2",
            desc: '''
              Defines the polarity used by the hysteresis comparator of ultra fast observer
              - 1 (negative polarity) => on < off =>
                  * throttle = 1 if data < on;
                  * throttle = 0 if data > off;
              - 0 (positive polarity) => on > off =>
                * throttle = 1 if data > on;
                * throttle = 0 if data < off
            '''
            resval: "0"
        },
        {
            name: "fast_enable"
            bits: "1",
            desc: '''
              Enable the fast observer
            '''
            resval: "0"
        },
        {
            name: "fast_sw_overwrite"
            bits: "0",
            desc: '''
              If 1 forces the throttle output of fast observer
            '''
            resval: "0"
        }
      ]
    },
    { name: "CORE_C2C_OBSERVATION_CFG",
      desc: '''
              Configure the observation of the VDD Core C2C monitor
              The observer supports 2 configurations
                - Fast : It can be used to engage the nop injection, limit the MVM utilisaiton and engage the clock throttle of AI Core
                - Ultra Fast : It can be used to engage the nop injection
            ''',
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
            name: "ultra_fast_off_th"
            bits: "47:40",
            desc: '''
              If the data observed on C2C crosses the ultra_fast_off_th, the output of the observer is disengage
            '''
            resval: "0"
        },
        {
            name: "ultra_fast_on_th"
            bits: "39:32",
            desc: '''
              If the data observed on C2C crosses the ultra_fast_on_th, the output of the observer is engage
            '''
            resval: "0"
        },
        {
            name: "fast_off_th"
            bits: "31:24",
            desc: '''
              If the data observed on C2C crosses the fast_off_th, the output of the observer is disengage
            '''
            resval: "0"
        },
        {
            name: "fast_on_th"
            bits: "23:16",
            desc: '''
              If the data observed on C2C crosses the fast_on_th, the output of the observer is engage
            '''
            resval: "0"
        },
        {
            name: "ultra_fast_polarity"
            bits: "10",
            desc: '''
              Defines the polarity used by the hysteresis comparator of ultra fast observer
              - 1 (negative polarity) => on < off =>
                  * throttle = 1 if data < on;
                  * throttle = 0 if data > off;
              - 0 (positive polarity) => on > off =>
                * throttle = 1 if data > on;
                * throttle = 0 if data < off
            '''
            resval: "0"
        },
        {
            name: "ultra_fast_enable"
            bits: "9",
            desc: '''
              Enable the fast observer
            '''
            resval: "0"
        },
        {
            name: "ultra_fast_sw_overwrite"
            bits: "8",
            desc: '''
              If 1 forces the throttle output of ultra fast observer
            '''
            resval: "0"
        },
        {
            name: "fast_polarity"
            bits: "2",
            desc: '''
              Defines the polarity used by the hysteresis comparator of ultra fast observer
              - 1 (negative polarity) => on < off =>
                  * throttle = 1 if data < on;
                  * throttle = 0 if data > off;
              - 0 (positive polarity) => on > off =>
                * throttle = 1 if data > on;
                * throttle = 0 if data < off
            '''
            resval: "0"
        },
        {
            name: "fast_enable"
            bits: "1",
            desc: '''
              Enable the fast observer
            '''
            resval: "0"
        },
        {
            name: "fast_sw_overwrite"
            bits: "0",
            desc: '''
              If 1 forces the throttle output of fast observer
            '''
            resval: "0"
        }
      ]
    },
    { name: "OBS_THROTTLE_CFG",
      desc: '''
              Select which C2C Observers should be used to trigger Fast and Ultra Fast Throttle
            ''',
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
            name: "core_fast_enable"
            bits: "3",
            desc: '''
              If 1 the VDD Core Fast Observer will engage the Fast Throttle
            '''
            resval: "0"
        },
        {
            name: "core_ultra_fast_enable"
            bits: "2",
            desc: '''
              If 1 the VDD Core Ultra Fast Observer will engage the Ultra Fast Throttle
            '''
            resval: "0"
        },
        {
            name: "imc_fast_enable"
            bits: "1",
            desc: '''
              If 1 the VDD IMC Fast Observer will engage the Fast Throttle
            '''
            resval: "0"
        },
        {
            name: "imc_ultra_fast_enable"
            bits: "0",
            desc: '''
              If 1 the VDD IMC Ultra Fast Observer to will engage the Ultra Fast Throttle
            '''
            resval: "0"
        }
      ]
    },
    { name: "NOP_INJECTION_RATE_CFG",
      desc: '''
              Defines which rate should be used if the throttle unit is activated without input throttle triggers (AIC, FAST or ULTRA FAST)
            ''',
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
            name: "static_rate"
            bits: "6:0",
            desc: '''
              Default rate value when throttle mode is 0x1 or no throttle triggered
            '''
            resval: "0"
        }
      ]
    },
    { multireg: { name: "NOP_INJECTION_THROTTLE_CFG",
      count: "NOP_INJ_GRP",
      cname: "nopinjcntid",
      compact: false,
      desc: '''
              Configure the NOP injection throttle unit
              NOP_INJECTION_THROTTLE_CFG_0 -> AI Core Throttle configuration
              NOP_INJECTION_THROTTLE_CFG_1 -> Fast Throttle configuration
              NOP_INJECTION_THROTTLE_CFG_2 -> Ultra Fast Throttle configuration
            ''',
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
            name: "throttle_en"
            bits: "51",
            desc: '''
            Enable the observation of the correspondent throttle.
            '''
            resval: "0"
        },
        {
            name: "sw_throttle_en"
            bits: "50",
            desc: '''
            Set to 1 to engage NOP Injection throttle.
            '''
            resval: "0"
        },
        {
            name: "mode"
            bits: "49:48",
            desc: '''
              Throttle mode.<br/>
              b00: Disabled. No limiting or throttling.<br/>
              b01: Max limit mode. Limiting is engaged and set to max_limit.<br/>
              b10: Hard throttle mode. Limiting is engaged. Throttling is globally qualified but not necessarily engaged: when not engaged, the limit is set to max_limit; when engaged, the limit instantly switches to throttle_limit.<br/>
              b11: Soft throttle mode. Same behaviour as hard throttle mode but the limit smoothly ramps between max_limit and throttle_limit according to the soft_throttle configuration fields.
            '''
            resval: "0"
        },
        {
            name: "throttle_limit"
            bits: "46:40",
            desc: '''
              Utilization limit if throttling is engaged (`mode` is `2'b10` or `2'b11`
              and at least one throttle source is qualified and engaged).
              Set value in range [0 to 64] (inclusive) to limit utilization from 0 to 100%.
            '''
            resval: "0"
        },
        {
            name: "soft_throttle_prescale"
            bits: "39:32",
            desc: '''
              Multiplying factor for soft throttle incr and decr times as described in the
              `soft_throttle_decr_time` and `soft_throttle_incr_time` formulas. If set to `0`,
               the prescaler is bypassed which results in the same behavior as being set to `1`.
            '''
            resval: "0"
        },
        {
            name: "soft_throttle_decr_time"
            bits: "31:16",
            desc: '''
              Time after which the utilization limit decreases by 1 if the throttle engages during soft throtting mode.<br/>
              Decrement time is: `t_decrement(soft_throttle_decr_time > 0) = soft_throttle_decr_time * non_zero_soft_throttle_prescale * t_ai_core_clk`<br/>
              If set to `0`, decrement timer is bypassed: `t_decrement(soft_throttle_decr_time == 0) = 1 * t_ai_core_clk`<br/>
              Note: `non_zero_soft_throttle_prescale = (soft_throttle_prescale > 0) ? soft_throttle_prescale : 1`
            '''
            resval: "0"
        },
        {
            name: "soft_throttle_incr_time"
            bits: "15:0",
            desc: '''
              Time after which the utilization limit increases by 1 if the throttle disengages during soft throtting mode.<br/>
              Increment time is: `t_increment(soft_throttle_incr_time > 0) = soft_throttle_incr_time * non_zero_soft_throttle_prescale * t_ai_core_clk`<br/>
              If set to `0`, increment timer is bypassed: `t_increment(soft_throttle_incr_time == 0) = 1 * t_ai_core_clk`<br/>
              Note: `non_zero_soft_throttle_prescale = (soft_throttle_prescale > 0) ? soft_throttle_prescale : 1`
            '''
            resval: "0"
        }
      ]
    }},
    { multireg: { name: "UTIL_THROTTLE_CFG",
      count: "UTIL_GRP",
      cname: "utilcntid",
      compact: false,
      desc: '''
              Configure the throttle unit that sets the MVM utilisation limit
              UTIL_THROTTLE_CFG_0 -> AI Core Throttle configuration
              UTIL_THROTTLE_CFG_1 -> Fast Throttle configuration
              UTIL_THROTTLE_CFG_2 -> Thermal Throttle configuration
            ''',
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
            name: "throttle_en"
            bits: "51",
            desc: '''
            Enable the observation of the correspondent throttle.
            '''
            resval: "0"
        },
        {
            name: "sw_throttle_en"
            bits: "50",
            desc: '''
            Set to 1 to engage NOP Injection throttle.
            '''
            resval: "0"
        },
        {
            name: "mode"
            bits: "49:48",
            desc: '''
              Throttle mode.<br/>
              b00: Disabled. No limiting or throttling.<br/>
              b01: Max limit mode. Limiting is engaged and set to max_limit.<br/>
              b10: Hard throttle mode. Limiting is engaged. Throttling is globally qualified but not necessarily engaged: when not engaged, the limit is set to max_limit; when engaged, the limit instantly switches to throttle_limit.<br/>
              b11: Soft throttle mode. Same behaviour as hard throttle mode but the limit smoothly ramps between max_limit and throttle_limit according to the soft_throttle configuration fields.
            '''
            resval: "0"
        },
        {
            name: "throttle_limit"
            bits: "47:40",
            desc: '''
              Utilization limit if throttling is engaged (`mode` is `2'b10` or `2'b11`
              and at least one throttle source is qualified and engaged).
              Set value in range [0 to 64] (inclusive) to limit utilization from 0 to 100%.
            '''
            resval: "0"
        },
        {
            name: "soft_throttle_prescale"
            bits: "39:32",
            desc: '''
              Multiplying factor for soft throttle incr and decr times as described in the
              `soft_throttle_decr_time` and `soft_throttle_incr_time` formulas. If set to `0`,
               the prescaler is bypassed which results in the same behavior as being set to `1`.
            '''
            resval: "0"
        },
        {
            name: "soft_throttle_decr_time"
            bits: "31:16",
            desc: '''
              Time after which the utilization limit decreases by 1 if the throttle engages during soft throtting mode.<br/>
              Decrement time is: `t_decrement(soft_throttle_decr_time > 0) = soft_throttle_decr_time * non_zero_soft_throttle_prescale * t_ai_core_clk`<br/>
              If set to `0`, decrement timer is bypassed: `t_decrement(soft_throttle_decr_time == 0) = 1 * t_ai_core_clk`<br/>
              Note: `non_zero_soft_throttle_prescale = (soft_throttle_prescale > 0) ? soft_throttle_prescale : 1`
            '''
            resval: "0"
        },
        {
            name: "soft_throttle_incr_time"
            bits: "15:0",
            desc: '''
              Time after which the utilization limit increases by 1 if the throttle disengages during soft throtting mode.<br/>
              Increment time is: `t_increment(soft_throttle_incr_time > 0) = soft_throttle_incr_time * non_zero_soft_throttle_prescale * t_ai_core_clk`<br/>
              If set to `0`, increment timer is bypassed: `t_increment(soft_throttle_incr_time == 0) = 1 * t_ai_core_clk`<br/>
              Note: `non_zero_soft_throttle_prescale = (soft_throttle_prescale > 0) ? soft_throttle_prescale : 1`
            '''
            resval: "0"
        }
      ]
    }},
    { name: "BOOST_REQUESTER_CFG",
      desc: '''
              Configure the boost requester
            ''',
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
            name: "boost_max_util"
            bits: "39:32",
            desc: '''
              Boost mode maximum for the MVM utilisation
            '''
            resval: "0"
        },
        {
            name: "normal_max_util"
            bits: "31:24",
            desc: '''
              Normal maximum for the MVM utilisation
            '''
            resval: "0"
        },
        {
            name: "off_th"
            bits: "23:16",
            desc: '''
              Value that engages a boost request
            '''
            resval: "0"
        },
        {
            name: "on_th"
            bits: "15:8",
            desc: '''
              Value that disengage a the boost request
            '''
            resval: "0"
        },
        {
            name: "ultra_fast_disengage"
            bits: "4",
            desc: '''
              If 1 Ultra Fast throttle disengage the boost requester
            '''
            resval: "0"
        },
        {
            name: "fast_disengage"
            bits: "3",
            desc: '''
              If 1 Fast throttle disengage the boost requester
            '''
            resval: "0"
        },
        {
            name: "thermal_disengage"
            bits: "2",
            desc: '''
              If 1 Thermal throttle disengage the boost requester
            '''
            resval: "0"
        },
        {
            name: "aic_disengage"
            bits: "1",
            desc: '''
              If 1 AIC throttle disengage the boost requester
            '''
            resval: "0"
        },
        {
            name: "enable"
            bits: "0",
            desc: '''
              Enable the boost requester
            '''
            resval: "0"
        }
      ]
    },
    { name: "IRQ_THROTTLE_CFG",
      desc: '''
              Configure IRQs related to the C2C observation readers
            ''',
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
            name: "warning_core_c2c_ultra_fast"
            bits: "10",
            desc: '''
              Trigger warning IRQ if the Core VDD C2C Observer engages the ultra fast observer throttle
            '''
            resval: "0"
        },
        {
            name: "warning_core_c2c_fast"
            bits: "9",
            desc: '''
              Trigger warning IRQ if the Core VDD C2C Observer engages the fast observer throttle
            '''
            resval: "0"
        },
        {
            name: "warning_imc_c2c_ultra_fast"
            bits: "8",
            desc: '''
              Trigger warning IRQ if the IMC C2C Observer engages the ultra fast observer throttle
            '''
            resval: "0"
        },
        {
            name: "warning_imc_c2c_fast"
            bits: "7",
            desc: '''
              Trigger warning IRQ if the IMC C2C Observer engages the fast observer throttle
            '''
            resval: "0"
        }
        {
            name: "critical_core_c2c_ultra_fast"
            bits: "3",
            desc: '''
              Trigger critical IRQ if the Core VDD C2C Observer engages the ultra fast observer throttle
            '''
            resval: "0"
        },
        {
            name: "critical_core_c2c_fast"
            bits: "2",
            desc: '''
              Trigger critical IRQ if the Core VDD C2C Observer engages the fast observer throttle
            '''
            resval: "0"
        },
        {
            name: "critical_imc_c2c_ultra_fast"
            bits: "1",
            desc: '''
              Trigger critical IRQ if the IMC C2C Observer engages the ultra fast observer throttle
            '''
            resval: "0"
        },
        {
            name: "critical_imc_c2c_fast"
            bits: "0",
            desc: '''
              Trigger critical IRQ if the IMC C2C Observer engages the fast observer throttle
            '''
            resval: "0"
        }
      ]
    },
    { name: "THROTTLE_CFG_ERROR_IRQ_ENABLE",
      desc: '''
              Enable the IRQs reporting wrong configuration of the throttle unit IRQs
            ''',
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
            name: "core_ultra_fast_obs_error"
            bits: "4",
            desc: '''
              Enable the IRQ reporting wrong configuration of the threshold value for the Core VDD C2C Ultra Fast observer
            '''
            resval: "0"
        },
        {
            name: "core_fast_obs_error"
            bits: "3",
            desc: '''
              Enable the IRQ reporting wrong configuration of the threshold value for the Core VDD C2C Fast observer
            '''
            resval: "0"
        },
        {
            name: "imc_ultra_fast_obs_error"
            bits: "2",
            desc: '''
              Enable the IRQ reporting wrong configuration of the threshold value for the IMC C2C Ultra Fast observer
            '''
            resval: "0"
        },
        {
            name: "imc_fast_obs_error"
            bits: "1",
            desc: '''
              Enable the IRQ reporting wrong configuration of the threshold value for the IMC C2C Fast observer
            '''
            resval: "0"
        },
        {
            name: "boost_req_error"
            bits: "0",
            desc: '''
              Enable the IRQ reporting wrong configuration of the boost requester threshold
            '''
            resval: "0"
        }
      ]
    },
    { name: "THROTTLE_CFG_ERROR_IRQ_STATUS",
      desc: '''
              IRQ reporting wrong configuration of the throttle unit
            ''',
      swaccess: "rw",
      hwaccess: "hrw",
      fields: [
        {
            name: "core_ultra_fast_obs_error"
            bits: "4",
            desc: '''
              Wrong configuration of the threshold value for the Core VDD C2C Ultra Fast observer
              - CORE_C2C_OBSERVATION_CFG.ultra_fast_polarity == 1 =>  CORE_C2C_OBSERVATION_CFG.ultra_fast_on_th < CORE_C2C_OBSERVATION_CFG.ultra_fast_off_th
              - CORE_C2C_OBSERVATION_CFG.ultra_fast_polarity == 0 =>  CORE_C2C_OBSERVATION_CFG.ultra_fast_on_th > CORE_C2C_OBSERVATION_CFG.ultra_fast_off_th
            '''
            resval: "0"
        },
        {
            name: "core_fast_obs_error"
            bits: "3",
            desc: '''
              Wrong configuration of the threshold value for the Core VDD C2C Fast observer
              - CORE_C2C_OBSERVATION_CFG.fast_polarity == 1 =>  CORE_C2C_OBSERVATION_CFG.fast_on_th < CORE_C2C_OBSERVATION_CFG.fast_off_th
              - CORE_C2C_OBSERVATION_CFG.fast_polarity == 0 =>  CORE_C2C_OBSERVATION_CFG.fast_on_th > CORE_C2C_OBSERVATION_CFG.fast_off_th
            '''
            resval: "0"
        },
        {
            name: "imc_ultra_fast_obs_error"
            bits: "2",
            desc: '''
              Wrong configuration of the threshold value for the IMC C2C Ultra Fast observer
              - IMC_C2C_OBSERVATION_CFG.ultra_fast_polarity == 1 =>  IMC_C2C_OBSERVATION_CFG.ultra_fast_on_th < IMC_C2C_OBSERVATION_CFG.ultra_fast_off_th
              - IMC_C2C_OBSERVATION_CFG.ultra_fast_polarity == 0 =>  IMC_C2C_OBSERVATION_CFG.ultra_fast_on_th > IMC_C2C_OBSERVATION_CFG.ultra_fast_off_th
            '''
            resval: "0"
        },
        {
            name: "imc_fast_obs_error"
            bits: "1",
            desc: '''
              Wrong configuration of the threshold value for the IMC C2C Fast observer
              - IMC_C2C_OBSERVATION_CFG.fast_polarity == 1 =>  IMC_C2C_OBSERVATION_CFG.fast_on_th < IMC_C2C_OBSERVATION_CFG.fast_off_th
              - IMC_C2C_OBSERVATION_CFG.fast_polarity == 0 =>  IMC_C2C_OBSERVATION_CFG.fast_on_th > IMC_C2C_OBSERVATION_CFG.fast_off_th
            '''
            resval: "0"
        },
        {
            name: "boost_req_error"
            bits: "0",
            desc: '''
              ON threshold should be higher than OFF threshold in the boost requester configuration.
            '''
            resval: "0"
        }
      ]
    },
    { name: "MONITOR_MIN_MAX_VALUE",
      desc: "Tracks the minimum and maximum margin from both IMC VDD and Core VDD monitors and the MVM average utilisation. Values are reset on read.",
      swaccess: "ro",
      hwaccess: "hrw",
      hwext: "true",
      hwre: "true",
      fields: [
        {
            name: "max_avg_util"
            bits: "47:40",
            desc: '''Maximum MVM utilisation average. Clears on read.'''
            resval: 0
        },
        {
            name: "min_avg_util"
            bits: "39:32",
            desc: '''Minimum MVM utilisation average. Clears on read.'''
            resval: 0
        },
        {
            name: "max_core_c2c_margin"
            bits: "31:24",
            desc: '''VDD Core maximum margin. Clears on read.'''
            resval: 0
        },
        {
            name: "min_core_c2c_margin"
            bits: "23:16",
            desc: '''VDD Core minimum margin. Clears on read.'''
            resval: 0
        },
        {
            name: "max_imc_c2c_margin"
            bits: "15:8",
            desc: '''VDD IMC maximum margin. Clears on read.'''
            resval: 0
        },
        {
            name: "min_imc_c2c_margin"
            bits: "7:0",
            desc: '''VDD IMC minimum margin. Clears on read.'''
            resval: 0
        }
      ]
    },
    { name: "MVM_AVG_UTIL_CFG",
      desc: "MVM average utilization monitoring configuration",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
            name: "col_upscaling_factor"
            bits: "14:12",
            desc: '''
              Upcaling factor applied to the in col for the utilisation computation.
              `UxT + row_upscaling_factor x U + col_upscaling_factor x T
            '''
            resval: 0
        },
        {
            name: "row_upscaling_factor"
            bits: "10:8",
            desc: '''
              Upcaling factor applied to the in row for the utilisation computation.
              `UxT + row_upscaling_factor x U + col_upscaling_factor x T
            '''
            resval: 0
        },
        {
            name: "filter_nominator"
            bits: "7:0",
            desc: '''IIR filter nominator. Filter formula: `y[k] = y[k-1]*(filter_nominator/256) + x[k]*((256-filter_nominator)/256)`.'''
            resval: 0
        }
      ]
    },
    { name: "MVM_RAMP_UP_CFG",
      desc: "MVM Ramp Up configuration",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
            name: "budget_increment"
            bits: "7:0",
            desc: '''Incremental value added to the budget at each clock cycle'''
            resval: 72
        },
        {
            name: "budget_clip"
            bits: "15:8",
            desc: '''Maximum value for the usage budget'''
            resval: 72
        },
        {
            name: "budget_cost_base"
            bits: "23:16",
            desc: '''Base cost for each MVM operation'''
            resval: 72
        },
        {
            name: "budget_cost_per_col"
            bits: "27:24",
            desc: '''Additional cost per column'''
            resval: 0
        },
        {
            name: "budget_cost_per_row"
            bits: "31:28",
            desc: '''Additional cost per row'''
            resval: 0
        },
        {
            name: "budget_cost_per_rc"
            bits: "32",
            desc: '''Complement cost per row and column'''
            resval: 0
        }
      ]
    },
    { name: "DBG_SCRATCH0",
      desc: "Scratch 0 register only accessible through SW for debugging purposes.",
      swaccess: "rw",
      hwaccess: "none"
      fields: [
        {
            bits: "63:0",
            name: "SCRATCH",
            desc: '''Scratch register field 0.''',
            resval: 0x0
        }
      ]
    },
    { name: "DBG_SCRATCH1",
      desc: "Scratch 1 register only accessible through SW for debugging purposes.",
      swaccess: "rw",
      hwaccess: "none"
      fields: [
        {
            bits: "63:0",
            name: "SCRATCH",
            desc: '''Scratch register field 1.''',
            resval: 0x0
        }
      ]
    },
    { name: "P1_CONTROL",
      desc: "Control signals for P1 Monitor",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
          name: "enable",
          bits: "0",
          resval: 0,
          desc: '''
                0: initialises the macro, 1: stats measurement. Must stay at 1 until measurement has completed.
                '''
        }
        {
          name: "target",
          bits: "3:1",
          resval: 0,
          desc: '''
                Measure during `2**target` ref_clk cycles.
                '''
        }
      ]
    },
    { multireg: { name: "P1_RO_SELECT",
      count: "PR1_NB_MONITOR",
      cname: "p1cntid",
      compact: false,
      desc: "Bit-mask indicating which ring oscillators to use. Use[k]=0: do not use RO k.",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
          name: "use_ro",
          bits: "0",
          resval: 0,
          desc: '''
                Bit-mask indicating which ring oscillators to use. Use[k]=0: do not use RO k.
                '''
        }
      ]
    }},
    { multireg: {name: "P1_COUNTERS",
      count: "PR1_NB_MONITOR",
      cname: "p1cntid",
      compact: false,
      desc: "Measure results per counter",
      swaccess: "ro",
      hwaccess: "hrw",
      fields: [
        {
            bits: "15:0",
            name: "count",
            resval: 0,
            desc: '''
                  Measurement result for RO with index k
                  X whenever valid=0
                  0 if use[k] was 0 when starting the measurement
                  '''
        }
      ]
    }},
    { name: "P2_CONTROL",
      desc: "Control signals for P2 Monitor",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
          name: "enable",
          bits: "0",
          resval: 0,
          desc: '''
                0: initialises the macro, 1: stats measurement. Must stay at 1 until measurement has completed.
                '''
        }
        {
          name: "target",
          bits: "3:1",
          resval: 0,
          desc: '''
                Measure during `2**target` ref_clk cycles.
                '''
        }
      ]
    },
    { multireg: { name: "P2_RO_SELECT",
      count: "PR2_NB_MONITOR",
      cname: "p2cntid",
      compact: false,
      desc: "Bit-mask indicating which ring oscillators to use. Use[k]=0: do not use RO k.",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
          name: "use_ro",
          bits: "0",
          resval: 0,
          desc: '''
                Bit-mask indicating which ring oscillators to use. Use[k]=0: do not use RO k.
                '''
        }
      ]
    }},
    { multireg: {name: "P2_COUNTERS",
      count: "PR2_NB_MONITOR",
      cname: "p2cntid",
      compact: false,
      desc: "Measure results per counter",
      swaccess: "ro",
      hwaccess: "hrw",
      fields: [
        {
            bits: "15:0",
            name: "count",
            resval: 0,
            desc: '''
                  Measurement result for RO with index k
                  X whenever valid=0
                  0 if use[k] was 0 when starting the measurement
                  '''
        }
      ]
    }},
    { name: "SVS_CORE_CONTROL",
      desc: "Control signals for SVS Core Monitor",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
          name: "enable",
          bits: "0",
          resval: 0,
          desc: '''
                0: initialises the macro, 1: stats measurement. Must stay at 1 until measurement has completed.
                '''
        }
        {
          name: "target",
          bits: "3:1",
          resval: 0,
          desc: '''
                Measure during `2**target` ref_clk cycles.
                '''
        }
      ]
    },
    { name: "SVS_CORE_RO_SELECT",
      desc: "Bit-mask indicating which ring oscillators to use. Use[k]=0: do not use RO k.",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
          name: "use_ro",
          bits: "29:0",
          resval: 0,
          desc: '''
                Bit-mask indicating which ring oscillators to use. Use[k]=0: do not use RO k.
                '''
        }
      ]
    },
    { multireg: {name: "SVS_CORE_COUNTERS",
      count: "SVS_NB_MONITOR",
      cname: "svscntid",
      compact: false,
      desc: "Measure results per counter",
      swaccess: "ro",
      hwaccess: "hrw",
      fields: [
        {
            bits: "15:0",
            name: "count",
            resval: 0,
            desc: '''
                  Measurement result for RO with index k
                  X whenever valid=0
                  0 if use[k] was 0 when starting the measurement
                  '''
        }
      ]
    }},
    { name: "SVS_IMC_CONTROL",
      desc: "Control signals for SVS IMC Monitor",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
          name: "enable",
          bits: "0",
          resval: 0,
          desc: '''
                0: initialises the macro, 1: stats measurement. Must stay at 1 until measurement has completed.
                '''
        }
        {
          name: "target",
          bits: "3:1",
          resval: 0,
          desc: '''
                Measure during `2**target` ref_clk cycles.
                '''
        }
      ]
    },
    { name: "SVS_IMC_RO_SELECT",
      desc: "Bit-mask indicating which ring oscillators to use. Use[k]=0: do not use RO k.",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
          name: "use_ro",
          bits: "29:0",
          resval: 0,
          desc: '''
                Bit-mask indicating which ring oscillators to use. Use[k]=0: do not use RO k.
                '''
        }
      ]
    },
    { multireg: {name: "SVS_IMC_COUNTERS",
      count: "SVS_NB_MONITOR",
      cname: "svscntid",
      compact: false,
      desc: "Measure results per counter",
      swaccess: "ro",
      hwaccess: "hrw",
      fields: [
        {
            bits: "15:0",
            name: "count",
            resval: 0,
            desc: '''
                  Measurement result for RO with index k
                  X whenever valid=0
                  0 if use[k] was 0 when starting the measurement
                  '''
        }
      ]
    }},
    { name: "C2C_IMC_CONTROL",
      desc: "Set C2C IMC Monitor",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
            bits: "0",
            name: "enable",
            resval: 0,
            desc: '''
                  Enable C2C monitor
                  '''
        }
        {
            bits: "5:1",
            name: "voting_cfg",
            resval: 0,
            desc: '''
                  Selects voting configuration:
                  0: c2c_0
                  1: c2c_1
                  2: c2c_2
                  3: medium_vote
                  '''
        }
        {
            bits: "7:6",
            name: "scale",
            resval: 0,
            desc: '''
                  Scale factoring to compensate margin result
                  margin_result = margin_calculated >> scale
                  '''
        }
      ]
    },
    { multireg: { name: "C2C_IMC_CONSTANTS",
      count: "C2C_CONSTANTS_GRP",
      cname: "c2ccntid",
      compact: false,
      desc: '''
      Set the constants used to calculate the margin
      `margin = constA*NLVT*NSVT + constB*NSVT + constC*NLVT + constD`
      ''',
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
            bits: "3:0",
            name: "A",
            resval: 0,
            desc: '''
                  Constant A
                  '''
        }
        {
            bits: "13:4",
            name: "B",
            resval: 0,
            desc: '''
                  Constant B
                  '''
        }
        {
            bits: "23:14",
            name: "C",
            resval: 0,
            desc: '''
                  Constant C
                  '''
        }
        {
            bits: "43:24",
            name: "D",
            resval: 0,
            desc: '''
                  Constant D
                  '''
        }
      ]
    }},
    { name: "C2C_IMC_MARGIN",
      desc: "Margin for the C2C IMC VDD",
      swaccess: "ro",
      hwaccess: "hwo",
      fields: [
        {
            bits: "7:0",
            name: "margin",
            resval: 0,
            desc: '''
                  Minimum between margin 1 and margin 2
                  '''
        }
      ]
    },
    { name: "C2C_CORE_CONTROL",
      desc: "Set C2C CORE Monitor",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
            bits: "0",
            name: "enable",
            resval: 0,
            desc: '''
                  Enable C2C monitor
                  '''
        }
        {
            bits: "5:1",
            name: "voting_cfg",
            resval: 0,
            desc: '''
                  Selects voting configuration:
                  0: c2c_0
                  1: c2c_1
                  2: c2c_2
                  3: medium_vote
                  '''
        }
        {
            bits: "7:6",
            name: "scale",
            resval: 0,
            desc: '''
                  Scale factoring to compensate margin result
                  margin_result = margin_calculated >> scale
                  '''
        }
      ]
    },
    { multireg: { name: "C2C_CORE_CONSTANTS",
      count: "C2C_CONSTANTS_GRP",
      cname: "c2ccntid",
      compact: false,
      desc: '''
      Set the constants used to calculate the margin
      `margin = constA*NLVT*NSVT + constB*NSVT + constC*NLVT + constD`
      ''',
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
            bits: "3:0",
            name: "A",
            resval: 0,
            desc: '''
                  Constant A
                  '''
        }
        {
            bits: "13:4",
            name: "B",
            resval: 0,
            desc: '''
                  Constant B
                  '''
        }
        {
            bits: "23:14",
            name: "C",
            resval: 0,
            desc: '''
                  Constant C
                  '''
        }
        {
            bits: "43:24",
            name: "D",
            resval: 0,
            desc: '''
                  Constant D
                  '''
        }
      ]
    }},
    { name: "C2C_CORE_MARGIN",
      desc: "Margin for the C2C CORE VDD",
      swaccess: "ro",
      hwaccess: "hwo",
      fields: [
        {
            bits: "7:0",
            name: "margin",
            resval: 0,
            desc: '''
                  Minimum between margin 1 and margin 2
                  '''
        }
      ]
    },
  ]
}
