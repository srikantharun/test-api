// (C) Copyright Axelera AI 2021
// All Rights Reserved
// *** Axelera AI Confidential ***
//
// Description: hjson desc for ai_core_csr reg
// Owner: Luyi <yi.lu@axelera.ai>

{
  name: "aic_csr",
  clocking: [{clock: "clk_i", reset: "rst_ni"}],
  bus_interfaces: [{protocol: "tlul", direction: "device"}],
  regwidth: "64",
  addrcap: "0x10000",
  axi_intf: True
  param_list : [
    {name:"AXI_AW", type:"int", default:"40"},
    {name:"AXI_IDW", type:"int", default:"7"},
    {name:"AXI_LENW", type:"int", default:"8"}
    {name:"LT_DMA_ATU_ENTRIES", type:"int", default:"8"}
    {name:"LT_DMA_ATU_PO_SIZE", type:"int", default:"16"}
    {name:"HT_DMA_ATU_ENTRIES", type:"int", default:"8"}
    {name:"HT_DMA_ATU_PO_SIZE", type:"int", default:"16"}
    {name:"TIMELOG_ATU_ENTRIES", type:"int", default:"8"}
    {name:"TIMELOG_ATU_PO_SIZE", type:"int", default:"16"}
    {name:"PERF_COUNT_NUM", type:"int", default:"16"}
    {name:"PERF_COUNT_WIDTH", type:"int", default:"32"}
    {name:"CVA6V_MEMREG_NUM", type:"int", default:"2"}
  ]
  registers: [
      { name: "ID",
      desc: "Identification register.",
      swaccess: "ro",
      hwaccess: "hwo",
      hwext : True
      fields: [
        {
            bits: "7:0",
            name: "BLOCK_ID",
            desc: '''Unique identifier of the CSR block.'''
        }
        {
            bits: "19:8",
            name: "CORE_ID",
            desc: '''`CORE_ID` aka `CID` is a unique identifier of the `AI Core` instance.'''
        }
        {
            bits: "39:32",
            name: "HW_REVISION_MIN",
            desc: '''Minor hardware revision number.'''
        }
        {
            bits: "47:40",
            name: "HW_REVISION_MAJ",
            desc: '''Major hardware revision number.'''
        }
      ]
    },
    {
      name: "AI_CORE_STATUS",
      desc: "General status of the AI Core RISC-V.",
      swaccess: "ro",
      hwaccess: "hwo",
      hwext : True
      fields: [
        {
            bits: "0",
            name: "CVA6V_WFI_MODE",
            desc: '''The register goes high whenever the core is in the wait for interrupt state.'''
        }
      ]
    },
    {
      name: "OBS_CTRL",
      desc: "Observation Control.",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
            name: "OBS_MUX",
            bits: "2:0",
            desc: '''Observation MUX settings: 0: SW_OBS, 1: IDLE, 2: BUSY, 3: Activity, 4: Throttle
            '''
            resval: 0x0
            enum: [
              { value:  "0", name: "SW_OBS",   desc: "SW_OBS[15:0]"},
              { value:  "1", name: "IDLE",     desc: "[15]: dma, [14]: d_dpu, [13]: d_iau, [12]: d_dwpu, [11]: m_dpu, [10]: m_iau, [9]: m_mvmprg, [8]: m_mvmexe, [7]: d_odr, [6]: d_ifd_1, [5]: d_ifd_0, [4]: m_odr, [3]: m_ifd_w, [2]: m_ifd_2, [1]: m_ifd_1, [0]: m_ifd_0"},
              { value:  "2", name: "BUSY",     desc: "[15]: dma, [14]: d_dpu, [13]: d_iau, [12]: d_dwpu, [11]: m_dpu, [10]: m_iau, [9]: m_mvmprg, [8]: m_mvmexe, [7]: d_odr, [6]: d_ifd_1, [5]: d_ifd_0, [4]: m_odr, [3]: m_ifd_w, [2]: m_ifd_2, [1]: m_ifd_1, [0]: m_ifd_0"},
              { value:  "3", name: "Activity", desc: "[15:14]: throttle[14:13], [13]: dma_1, [12]: dma_0, [11]: d_odr, [10]: d_dwpu, [9]: d_ifd_1, [8]: d_ifd_0, [7]: m_mvmprg, [6]: m_ifd_w, [5]: m_odr, [4]: m_mvmexe, [3]: m_ifd_2, [2]: m_ifd_1, [1]: m_ifd_0 [0]: sw_obs[0]"},
              { value:  "4", name: "Throttle", desc: "[15:1]: throttle[14:0], [0]: sw_obs[0]"}
            ]
        }
      ]
    },
    { multireg: {
      name: "OBS_REARANGE",
      desc: "Rearange Observation bits.",
      count: "16",
      cname: "OBS_BIT"
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
            name: "bit_sel",
            bits: "3:0",
            desc: 'Select which bit from the mux output to select for the obs port'
            resval: 0x00
        }
      ]
    }
    },
    {
      name: "SW_OBS",
      desc: "Software Observation.",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
            name: "SW_OBS_OUT",
            bits: "15:0",
            desc: '''Software observation output.
            Software controllable observation pins that can be exposable to external pins using the `obs mux` in the ai core and the `smartmux` in system controller.
            '''
            resval: 0x00
        }
      ]
    },
    {
      name: "OBS_SIG",
      desc: "Observation Signals",
      swaccess: "ro",
      hwaccess: "hwo",
      hwext: "true"
      fields: [
        {
          name: "MVMEXE_STATE",
          desc: "State of the device. 0: Idle, 1: Fill, 2: Ready, 3: Exec",
          bits: "1:0",
        },
        {
          name: "MVMPRG_STATE",
          desc: "State of the device. 0: Idle, 1: Fill, 2: Ready, 3: Exec",
          bits: "3:2",
        },
        {
          name: "M_IAU_STATE",
          desc: "State of the device. 0: Idle, 1: Fill, 2: Ready, 3: Exec",
          bits: "5:4",
        },
        {
          name: "M_DPU_STATE",
          desc: "State of the device. 0: Idle, 1: Fill, 2: Ready, 3: Exec",
          bits: "7:6",
        },
        {
          name: "D_DWPU_STATE",
          desc: "State of the device. 0: Idle, 1: Fill, 2: Ready, 3: Exec",
          bits: "9:8",
        },
        {
          name: "D_IAU_STATE",
          desc: "State of the device. 0: Idle, 1: Fill, 2: Ready, 3: Exec",
          bits: "11:10",
        },
        {
          name: "D_DPU_STATE",
          desc: "State of the device. 0: Idle, 1: Fill, 2: Ready, 3: Exec",
          bits: "13:12",
        },
        {
          name: "M_IDF0_STATE",
          desc: "State of the device. 0: Idle, 1: Fill, 2: Ready, 3: Exec",
          bits: "15:14",
        },
        {
          desc: "State of the device. 0: Idle, 1: Fill, 2: Ready, 3: Exec",
          bits: "17:16",
        },
        {
          name: "M_IDF1_STATE",
          desc: "State of the device. 0: Idle, 1: Fill, 2: Ready, 3: Exec",
          bits: "19:18",
        },
        {
          name: "M_IDF2_STATE",
          desc: "State of the device. 0: Idle, 1: Fill, 2: Ready, 3: Exec",
          bits: "21:20",
        },
        {
          name: "M_IDFW_STATE",
          desc: "State of the device. 0: Idle, 1: Fill, 2: Ready, 3: Exec",
          bits: "23:22",
        },
        {
          name: "M_ODR_STATE",
          desc: "State of the device. 0: Idle, 1: Fill, 2: Ready, 3: Exec",
          bits: "25:24",
        },
        {
          name: "D_IDF0_STATE",
          desc: "State of the device. 0: Idle, 1: Fill, 2: Ready, 3: Exec",
          bits: "27:26",
        },
        {
          name: "D_IDF1_STATE",
          desc: "State of the device. 0: Idle, 1: Fill, 2: Ready, 3: Exec",
          bits: "29:28",
        },
        {
          name: "D_ODR_STATE",
          desc: "State of the device. 0: Idle, 1: Fill, 2: Ready, 3: Exec",
          bits: "31:30",
        },
        {
          name: "TU_OBS",
          desc: "Obs of Throttle Unit",
          bits: "46:32",
        },
      ]
    },
    { name: "LT_DMA_DEBUG_CTRL",
      desc: "LT DMA debug ctrl.",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
            name: "DEBUG_CH_NUM",
            bits: "0",
            desc: '''Channel select for the debug signals'''
        }
      ]
    },
    { name: "LT_DMA_DEBUG",
      desc: "LT DMA debug signals.",
      swaccess: "ro",
      hwaccess: "hwo",
      hwext: "true",
      fields: [
        {
            bits: "19:0",
            desc: '''Debug 0 signal -> see `5.1 Debug Interface Signals` in `DW_axi_dmac` Databook'''
        }
      ]
    },
    { name: "DBG_SCRATCH0",
      desc: "Scratch 0 register only accessible through SW for debugging purposes.",
      swaccess: "rw",
      hwaccess: "none"
      fields: [
        {
            bits: "63:0",
            name: "SCRATCH",
            desc: '''Scratch register field 0.''',
            resval: 0x0
        }
      ]
    },
    { name: "DBG_SCRATCH1",
      desc: "Scratch 1 register only accessible through SW for debugging purposes.",
      swaccess: "rw",
      hwaccess: "none"
      fields: [
        {
            bits: "63:0",
            name: "SCRATCH",
            desc: '''Scratch register field 1.''',
            resval: 0x0
        }
      ]
    },
    ###############################
    ## Datapath firewall         ##
    ###############################
    { name: "DATAPATH_FIREWALL",
      desc: "datapath firewall, switch between cva6/noc_lp_s and ACD",
      swaccess: "rw",
      hwaccess: "hro"
      fields: [
        {
            bits: "0",
            name: "SEL",
            desc: '''Give access to either cva6/noc_lp_s or ACD, 0: cav6/noc_lp_s, 1: ACD''',
            resval: 0x0
        }
      ]
    },
    ###############################
    ## clock enable for cva6v    ##
    ###############################
    { name: "CVA6_CLK_EN",
      desc: "clock enable for cva6v",
      swaccess: "rw",
      hwaccess: "hro"
      fields: [
        {
            bits: "0",
            name: "CLK_EN",
            desc: '''clock enable to cva6v, 1: clock enable, 0: gated''',
            resval: 0x0
        }
      ]
    },
    ###############################
    ## Memory region cfg cva6v   ##
    ###############################
    { multireg:
      { name: "CVA6V_MEMREG",
        desc: "The Configuration values for the memory regions for cva6v. After reset uses hardware Default. Values here are not reflecting the default! These values will be used after the first write.",
        count: "CVA6V_MEMREG_NUM",
        swaccess: "rw",
        hwaccess: "hro",
        hwqe: "true",
        compact: false,
        cname: "cva6v_memreg",
        fields: [
          { bits: "39:0",
            name: "ADDR",
            desc: "The base address of a region. I.e. L1 of the AI-Core."
            resval: "0x0",
          },
          { bits: "45:40",
            name: "SIZE",
            desc: "The size of the region. Must be the log2 of the byte size."
            resval: "0x15",
          },
          { bits: "48",
            name: "TCDM",
            desc: "If this region is a tightly coupled data memory.",
            resval: "0x1",
          },
        ]
      },
    },
    ###############################
    ## LowPower Control          ##
    ###############################
    { name: "LOW_POWER_CONTROL",
      desc: "Low Power control for the fabric",
      swaccess: "rw",
      hwaccess: "hro"
      fields: [
        {
            bits: "0",
            name: "LP_EN",
            desc: '''LowPower enable for the fabric''',
            resval: 0x1
        },
        {
            bits: "13:8",
            name: "IDLE_DELAY",
            desc: '''Delay going to a low power state for `IDLE_DELAY` amount of cycles''',
            resval: 0x8
        }
      ]
    },
    ###############################
    ## SPM error status          ##
    ###############################
    { name: "SPM_ERR_STATUS",
      desc: "SPM ECC error status",
      swaccess: "ro",
      hwaccess: "hwo"
      fields: [
        {
            name: "ECC_ERR_PRESENT",
            bits: "0",
            desc: '''SPM error indication (0:not present, 1:present)'''
        }
        {
            name: "ECC_ERR_TYPE",
            bits: "1",
            desc: '''SPM Error type: 0 for single, 1 for double ''',
        }
        {
            name: "ECC_ERR_SYNDROME",
            bits: "9:2",
            desc: '''SPM Error syndrome ''',
        }
        {
            name: "ECC_ERR_INDEX",
            bits: "29:10",
            desc: '''SPM Error index ''',
        }
      ]
    },
    ###############################
    ## SWEP Token select         ##
    ###############################
    { name: "SWEP_TOKEN_SELECT",
      desc: "Select where the SWEP tokens will end up. TokenMGR (0) or ACD (1)",
      swaccess: "rw",
      hwaccess: "hro"
      fields: [
        {
            bits: "0",
            name: "SEL",
            desc: '''Select where the SWEP tokens will end up. TokenMGR (0) or ACD (1)''',
            resval: 0x0
        }
      ]
    },
    ####################
    ## Global sync    ##
    ####################
    { name: "GLOBAL_SYNC_CONTROL",
      desc: "Control the global sync routing",
      swaccess: "rw",
      hwaccess: "hro"
      fields: [
        {
            bits: "0",
            name: "EN",
            desc: '''Enable the global sync routing''',
            resval: 0x0
        }
        {
            bits: "1",
            name: "SELECT",
            desc: '''Select the endpoint for the global sync. 0: TimestampLogger 1: MVM EXE Token''',
            resval: 0x0
        }
      ]
    },
    ###############################
    ## Address Translation Units ##
    ###############################
    { name: "ATU_BYPASS",
      desc: "ATU bypass configuration",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
            name: "lt_dma"
            bits: "0",
            desc: '''LT DMA ATU bypass enable. All requests are routed directly and no address translation is performed.'''
            resval: 1
        },
        {
            name: "timelog"
            bits: "1",
            desc: '''TimestampLogger ATU bypass enable for port 0. All requests are routed directly and no address translation is performed.'''
            resval: 1
        },
      ]
    },
    { multireg:
      { name: "LT_DMA_ATU_CFG",
        desc: "LT DMA Address Translation Unit (ATU) configuration",
        count: "LT_DMA_ATU_ENTRIES",
        swaccess: "rw",
        hwaccess: "hro",
        cname: "lt_dma_atu_cfg",
        fields: [
          { bits: "0",
            name: "valid",
            desc: '''Enable this translation entry''',
            resval: "0"
          },
          { bits: "1",
            name: "read_only",
            desc: '''Entry is only for read access, write is not allowed''',
            resval: "0"
          }
        ]
      },
    },
    { multireg:
      { name: "LT_DMA_ATU_FIRST",
        desc: "LT_DMA ATU first address",
        count: "LT_DMA_ATU_ENTRIES",
        swaccess: "rw",
        hwaccess: "hro",
        compact: false,
        cname: "lt_dma_atu_first",
        fields: [
          { bits: "AXI_AW-LT_DMA_ATU_PO_SIZE-1:0",
            name: "first",
            desc: '''Lower (including) address bound for translation match''',
            resval: "0"
          }
        ]
      },
    },
    { multireg:
      { name: "LT_DMA_ATU_LAST",
        desc: "LT_DMA ATU last address",
        count: "LT_DMA_ATU_ENTRIES",
        swaccess: "rw",
        hwaccess: "hro",
        compact: false,
        cname: "lt_dma_atu_last",
        fields: [
          { bits: "AXI_AW-LT_DMA_ATU_PO_SIZE-1:0",
            name: "last",
            desc: '''Upper (including) address bound for translation match''',
            resval: "0"
          }
        ]
      },
    },
    { multireg:
      { name: "LT_DMA_ATU_BASE",
        desc: "LT_DMA ATU base translation address",
        count: "LT_DMA_ATU_ENTRIES",
        swaccess: "rw",
        hwaccess: "hro",
        compact: false,
        cname: "lt_dma_atu_base",
        fields: [
          { bits: "AXI_AW-LT_DMA_ATU_PO_SIZE-1:0",
            name: "base",
            desc: '''On match, subtract first and add base''',
            resval: "0"
          }
        ]
      },
    },
    { multireg:
      { name: "TIMELOG_ATU_CFG",
        desc: "TimestampLogger Address Translation Unit (ATU) configuration",
        count: "TIMELOG_ATU_ENTRIES",
        swaccess: "rw",
        hwaccess: "hro",
        cname: "timelog_atu_cfg",
        fields: [
          { bits: "0",
            name: "valid",
            desc: '''Enable this translation entry''',
            resval: "0"
          },
          { bits: "1",
            name: "read_only",
            desc: '''Entry is only for read access, write is not allowed''',
            resval: "0"
          }
        ]
      },
    },
    { multireg:
      { name: "TIMELOG_ATU_FIRST",
        desc: "TIMELOG ATU first address",
        count: "TIMELOG_ATU_ENTRIES",
        swaccess: "rw",
        hwaccess: "hro",
        compact: false,
        cname: "timelog_atu_first",
        fields: [
          { bits: "AXI_AW-TIMELOG_ATU_PO_SIZE-1:0",
            name: "first",
            desc: '''Lower (including) address bound for translation match''',
            resval: "0"
          }
        ]
      },
    },
    { multireg:
      { name: "TIMELOG_ATU_LAST",
        desc: "TIMELOG ATU last address",
        count: "TIMELOG_ATU_ENTRIES",
        swaccess: "rw",
        hwaccess: "hro",
        compact: false,
        cname: "timelog_atu_last",
        fields: [
          { bits: "AXI_AW-TIMELOG_ATU_PO_SIZE-1:0",
            name: "last",
            desc: '''Upper (including) address bound for translation match''',
            resval: "0"
          }
        ]
      },
    },
    { multireg:
      { name: "TIMELOG_ATU_BASE",
        desc: "TIMELOG ATU base translation address",
        count: "TIMELOG_ATU_ENTRIES",
        swaccess: "rw",
        hwaccess: "hro",
        compact: false,
        cname: "timelog_atu_base",
        fields: [
          { bits: "AXI_AW-TIMELOG_ATU_PO_SIZE-1:0",
            name: "base",
            desc: '''On match, subtract first and add base''',
            resval: "0"
          }
        ]
      },
    },

    ### Performance Counters
    { multireg:
      { name: "GEN_PERF_COUNTERS",
        desc: "Shared Generic Performance Counters",
        count: "PERF_COUNT_NUM",
        swaccess: "rc",
        hwaccess: "hrw",
        compact: true,
        cname: "gen_perf_counters",
        fields: [
          { bits: "PERF_COUNT_WIDTH-1:0",
            name: "PERFC",
            desc: '''Shared performance counters''',
            resval: "0"
          }
        ]
      },
    },
    { name: "PERF_CTRL",
      desc: "Control register of the shared performance counters.",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
            bits: "PERF_COUNT_NUM-1:0",
            name: "PERFC_EN",
            desc: '''The counter is enabled and ready to increment. Each bit corresponds different shared counter.'''
        }
      ]
    },
    { name: "PERF_CNT_MODE",
      desc: "Mode selection for Performance Counters. Each mode selects different incrementers for the counters.",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        {
            bits: "1:0",
            name: "PERFC_MODE",
            desc: '''Shared Performance Counters Mode Selection.''',
            enum: [
                    { value: "0", name: "Utilization", desc: "Counts for busy states and all stalls" },
                    { value: "1", name: "Token_Stalls", desc: "Counts for token stalls" },
                    { value: "2", name: "Stall_Analysis_MVM_DP", desc: "Counts all stalls for MVM DP" },
                    { value: "3", name: "Stall_Analysis_DWPU_DP", desc: "Counts all stalls for DWPU DP" }
                  ]
        }
      ]
    },

  #### Top Token Network:

%%include:"{REPO_ROOT}/hw/impl/europa/data/top_token_network/top_token_regs.hjson"

  ]
}
