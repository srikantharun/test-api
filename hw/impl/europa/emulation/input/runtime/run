#!/usr/bin/env bash

set -e

source info.txt

RUNTIME_DIR="$(readlink -e $(dirname $0))"
SW_DIR=$REPO_ROOT/sw
SW_BUILD_DIR=$RUNTIME_DIR/build


#--------------------------------------------------------------
# functions
#--------------------------------------------------------------
usage() {
  cat << EOF
usage: $(basename $0) [ARGS] [TEST_NAME]

run FW test on the emulator

where TEST_NAME is: the cmake test to be run on the emulator,
if empty, open velrun and wait for use inputs

where ARGS are:
  -h|--help                 : display this help

  --dump_ax65_instructions  : dump AX65 CPU instructions in ./instruction_dump_ax65_id*.log
  --dump_cva6v_instructions : dump CVA6V CPU instructions in ./instruction_dump_cva6v_id*.log

  -d|--dryrun               : dryrun, generate and copy all files but don't execute velrun
  -g|--gui                  : use GUI and does stop after reset sequence and memory backdoor loading
  -i|--interactive          : stop after reset sequence and memory backdoor loading
  -l|--list                 : list available tests
  --licqueue                : try running velrun until licenses/boards are available
  --no_sw_build             : don't call verifsdk, test has to be compiled beforehand
  -s|--status               : emulator's status, available boards etc
  --timeout SECONDS         : timeout after SECONDS sec, license waiting not taken into account (default: 3600)

  -c|--clocks CONFIG        : program clocks after reset (e.g.: -c canonical)

  -t|--tcl_server           : run in TCL server mode, use ./tcl_send_cmd to send commands afterwards
  --wait_tcl_server_is_up   : do nothing but block until tcl_server is up
  -a|--attach_to_tcl_server : play test on tcl_server instead of starting a new velrun
  --coverage_suffix SUFFIX  : add suffix to ucdb to make coverage filename unique

  --fast_printf             : bypass UART logic to print chars as soon as they are written on the APB bus
  --no_printf               : build software with log_level >= WARNING

  --emmc_hex_file=*         : Hex file to preload into the EMMC softmodel
  --spi_hex_file=*          : Hex file to preload into the SPINOR softmodel
EOF
}


error() {
  >&2 echo "ERROR: $@"
  exit 1
}


get_verifsdk_platform() {
  cat "$RUNTIME_DIR/verifsdk_platform.txt"
}


print_test_list() {
  verifsdk -P $(get_verifsdk_platform) --list | sort
}


build_sw() {
  mkdir -p $SW_BUILD_DIR
  cd $SW_BUILD_DIR

  if ((do_sw_build)); then
    verifsdk -P $(get_verifsdk_platform) --only $test_name $verifsdk_extra_args -F clocks.${clock_config^^}
  fi

  # needed by fw_trace_utils
  ln -sf $SW_BUILD_DIR/$test_name/$test_name.S $RUNTIME_DIR/.latest_test.S
  ln -sf $SW_BUILD_DIR/$test_name/$test_name $RUNTIME_DIR/.latest_test
}

#TODO: add ddr_0 texthexify once we have a lpddr module in ddr_0 space.
dump_texthex() {
  texthexify --elf $test_binary_basepath -w 64 --memory sys_spm
  texthexify --elf $test_binary_basepath -w 64  --memory pve_0.spm
  texthexify --elf $test_binary_basepath -w 128 --memory pve_0.l1_0
  texthexify --elf $test_binary_basepath -w 128 --memory pve_0.l1_1
  texthexify --elf $test_binary_basepath -w 128 --memory pve_0.l1_2
  texthexify --elf $test_binary_basepath -w 128 --memory pve_0.l1_3
  texthexify --elf $test_binary_basepath -w 64 --memory aicore_0.spm
  texthexify --elf $test_binary_basepath -w 64 --memory aicore_1.spm
  texthexify --elf $test_binary_basepath -w 64 --memory aicore_2.spm
  texthexify --elf $test_binary_basepath -w 64 --memory aicore_3.spm
  texthexify --elf $test_binary_basepath -w 64 --memory aicore_4.spm
  texthexify --elf $test_binary_basepath -w 64 --memory aicore_5.spm
  texthexify --elf $test_binary_basepath -w 64 --memory aicore_6.spm
  texthexify --elf $test_binary_basepath -w 64 --memory aicore_7.spm
  texthexify --elf $test_binary_basepath -w 64  --memory pve_1.spm
  texthexify --elf $test_binary_basepath -w 128 --memory pve_1.l1_0
  texthexify --elf $test_binary_basepath -w 128 --memory pve_1.l1_1
  texthexify --elf $test_binary_basepath -w 128 --memory pve_1.l1_2
  texthexify --elf $test_binary_basepath -w 128 --memory pve_1.l1_3
  texthexify --elf $test_binary_basepath -w 128 --memory l2 --l2_interleaving INTER_1X8_4K
  texthexify --elf $test_binary_basepath -w 128 --memory aicore_0.l1
  texthexify --elf $test_binary_basepath -w 128 --memory aicore_1.l1
  texthexify --elf $test_binary_basepath -w 128 --memory aicore_2.l1
  texthexify --elf $test_binary_basepath -w 128 --memory aicore_3.l1
  texthexify --elf $test_binary_basepath -w 128 --memory aicore_4.l1
  texthexify --elf $test_binary_basepath -w 128 --memory aicore_5.l1
  texthexify --elf $test_binary_basepath -w 128 --memory aicore_6.l1
  texthexify --elf $test_binary_basepath -w 128 --memory aicore_7.l1
  texthexify --elf $test_binary_basepath -w 256 --memory ddr_1
}


create_run_tcl() {
  sed \
    -e "s#__DUT__#$dut#g" \
    -e "s#__TEST_NAME__#$test_name#g" \
    -e "s#__TEST_BINARY_BASEPATH__#$hex_basepath#g" \
    -e "s#__INTERACTIVE_MODE__#$stop_after_init#g" \
    -e "s#__TCL_CMD_SERVER_PORT__#$tcl_cmd_server_port#g" \
    -e "s#__ENABLE_DUMP_AX65_INSTRUCTIONS__#$dump_ax65_instructions#g" \
    -e "s#__ENABLE_DUMP_CVA6V_INSTRUCTIONS__#$dump_cva6v_instructions#g" \
    -e "s#__FAST_PRINTF__#$fast_printf#g" \
    -e "s#__EMMC_HEX_FILE__#$emmc_hex_file#g" \
    -e "s#__SPI_HEX_FILE__#$spi_hex_file#g" \
    -e "s#__CLOCK_CONFIG__#$clock_config#g" \
    -e "s#__PLATFORM_NAME__#"$(get_verifsdk_platform)"#g" \
    -e "s#__KSE_BOOTROM_FILES__#$kse_rom_files#g" \
    $RUNTIME_DIR/run_tcl_templates/$run_tcl > $RUNTIME_DIR/$run_tcl
}


stop_test() {
  touch stop_test
}


wait_tcl_server_is_up() {
  local tcl_server_log="run_logs/tcl_server.log"
  while ((1)); do
    [ -f "$tcl_server_log" ] && grep -q  "tcl_cmd_server is ready" $tcl_server_log && break
    sleep 1
    echo "waiting for tcl server..."
  done
}


remove_velrun_generated_files() {
  mkdir -p veloce.log
  echo "" > veloce.log/velrun.transcript
}


get_log_name() {
  local log_name
  log_name="$test_name"
  [ "$tcl_server" == 1 ] && log_name="tcl_server"
  [ "$attach_to_tcl_server" == 1 ] && log_name="attach_$test_name"
  echo "$log_name"
}


run_veloce() {
  local timeout="$1"
  local cmd="$2"

  mkdir -p run_logs
  run_log="run_logs/$(get_log_name).log"
  [ "$attach_to_tcl_server" == 1 ] || ln -sf $run_log run.log

  rm -f stop_test
  rm -f exit_value.log
  (
  exit_value=0
  # --foreground allows COMMAND to read from the TTY and get TTY signals;
  # in this mode, children of COMMAND will not be timed out
  eval timeout --foreground $timeout $cmd || exit_value="$?"
  echo "$exit_value" > exit_value.log
  ) 2>&1 | tee $run_log

  # stop test on timeout
  if [ "$(cat exit_value.log)" = 124 ]; then
    stop_test
  fi
}


extract_log_from_tcl_server() {
  sed -n "/^start: $test_name/,\$p" run_logs/tcl_server.log > run_logs/$test_name.log
}


exit_and_print_status() {
  local run_log_to_grep
  local last_report_test_status

  if [ "$(cat exit_value.log)" = 124 ]; then
    echo "timeout"
    sleep 10 # time to cleanly exit velrun
    exit 2
  else
    run_log_to_grep="$run_log"
    [ "$attach_to_tcl_server" == 1 ] && run_log_to_grep="run_logs/tcl_server.log"
    # only check on last report_test_status print in case we run multiple tests in 1 velrun session
    last_report_test_status="$(grep "^report_test_status:" $run_log_to_grep | tail -n1)"
    if [ "$last_report_test_status" == "report_test_status: [PASS] $test_name" ] || [ "$stil" == 1 ]; then
      echo "passed"
      exit 0
    fi
  fi
  echo "failed"
  exit 1
}


#--------------------------------------------------------------
# execution
#--------------------------------------------------------------
cd $RUNTIME_DIR

dump_ax65_instructions=0
dump_cva6v_instructions=0
dryrun=0
do_sw_build=1
stop_after_init=0
cli_gui_options="-c"
test_name=""
test_binary_basepath=""
licqueue=0
timeout=3600 # 1h default timeout
clock_config="default"
tcl_server=0
attach_to_tcl_server=0
fast_printf=0
verifsdk_extra_args=""
emmc_hex_file=""
spi_hex_file=""
plusargs=""
coverage_suffix=""
while [ "$#" -gt 0 ]
do
  case "$1" in
    -h|--help)
      usage
      exit 0
      ;;
    --dump_ax65_instructions)
      shift 1
      dump_ax65_instructions=1
      ;;
    --dump_cva6v_instructions)
      shift 1
      dump_cva6v_instructions=1
      ;;
    -s|--status)
      shift 1
      velec -avbstat
      exit 0
      ;;
    -l|--list)
      shift 1
      print_test_list
      exit 0
      ;;
    -d|--dryrun)
      shift 1
      dryrun=1
      ;;
    -i|--interactive)
      shift 1
      stop_after_init=1
      ;;
    -g|--gui)
      shift 1
      stop_after_init=1
      cli_gui_options="-gui"
      ;;
    --no_sw_build)
      shift 1
      do_sw_build=0
      ;;
    --licqueue)
      shift 1
      licqueue=1
      ;;
    --timeout)
      shift 1
      timeout=$1
      shift 1
      ;;
    -c|--clocks)
      shift 1
      clock_config="$1"
      shift 1
      ;;
    -t|--tcl_server)
      shift 1
      tcl_server=1
      ;;
    --wait_tcl_server_is_up)
      wait_tcl_server_is_up
      exit 0
      ;;
    -a|--attach_to_tcl_server)
      shift 1
      attach_to_tcl_server=1
      ;;
    --no_printf)
      shift 1
      verifsdk_extra_args+=" -F log_level.WARNING"
      ;;
    +VELOCE_FAST_PRINTF|--fast_printf)
      shift 1
      fast_printf=1
      ;;
    +EMMC_USER_0_MEM_0_FILE=*|--emmc_hex_file=*)
      emmc_hex_file="${1#*=}"
      shift
      ;;
    +SPINOR_MEMFILE=*|--spi_hex_file=*)
      spi_hex_file="${1#*=}"
      shift 1
      ;;
    --coverage_suffix)
      shift 1
      coverage_suffix="_$1"
      shift 1
      ;;
    +*)
      plusargs+=" $1"
      shift 1
      ;;
    *)
      test_name="$1"
      shift 1
      ;;
  esac
done

#setting kse rom files
kse_rom_files="./kse3_rom_integration_lower.hex ./kse3_rom_integration_upper.hex ./KSE3_2.8.0_ROM_lower.hex ./KSE3_2.8.0_ROM_upper.hex"

# generate SW binary
if [ "$test_name" != "" ]; then
  if [ -f "$test_name" ]; then
    # Check if it's an existing file path
    test_binary_basepath=$test_name
    test_name=$(basename "$test_name")
  else
    build_sw
    cd $RUNTIME_DIR
    test_binary_basepath=$SW_BUILD_DIR/$test_name/$test_name
  fi
  test_dir=$(dirname "$test_binary_basepath")
  hex_basepath=$test_dir/texthexify/$test_name

  # generate SW texthex files
  dump_texthex
fi

# generate run.tcl
do_create_run_tcl=1
if [ "$tcl_server" == 1 ]; then
  run_tcl="run_tcl_server.tcl"
  tcl_cmd_server_port="$(./get_unused_local_ports.py)"
elif [ "$attach_to_tcl_server" == 1 ]; then
  run_tcl="run_back_to_back.tcl"
else
  run_tcl=run.tcl
fi
[ "$do_create_run_tcl" == 1 ] && create_run_tcl
[ -f "$run_tcl" ] || error "$run_tcl not found"

[ "$dryrun" = 1 ] && exit 0

# run
if [ "$attach_to_tcl_server" == 1 ]; then
  wait_tcl_server_is_up
  ./tcl_send_cmd "catch {run -stop}" # make sure clocks are stopped
  # CTRL-C will call stop_test for the server to stop executing the test
  trap stop_test INT
  client_cmd="./tcl_send_cmd \"source run_back_to_back.tcl\""
  run_veloce "$timeout" "$client_cmd"
  extract_log_from_tcl_server
else
  coverage_options=""
  if [ "$ccov" = 1 ]; then
    mkdir -p coverage_veloce
    coverage_options="-generate_ucdb coverage_veloce/$(get_log_name)${coverage_suffix}.ucdb"
  fi

  velrun_cmd="velrun $cli_gui_options $coverage_options -emul $Emulator -sv_lib libdpi $plusargs"
  velrun_cmd+=" -do $run_tcl -exit_on_assertion"
  echo $velrun_cmd

    # keep on starting velrun until emulation starts
  while ((1)); do
    remove_velrun_generated_files
    run_veloce "$timeout" "$velrun_cmd"
    [ "$licqueue" != 1 ] && break
    grep -q '\[TCLC-5501\]: : Emulation started' veloce.log/velrun.transcript && break
    grep -q '\[VELDFT-1055\]: : DFT pattern simulation completed' veloce.log/velrun.transcript && break
    sleep 60
  done
fi

exit_and_print_status
